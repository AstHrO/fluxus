Fluxus Documentation 0.15
============================================================

Section: "fluxa"

Fluxa is the fluxus audio synth

------------------------------------------------------------

(sine frequency-number-or-node)
Returns node-id-number

Creates a sine wave generator node

 (play-now (mul (sine 440) (asdr 0.1 0.1 0 0)))

------------------------------------------------------------

(saw frequency-number-or-node)
Returns node-id-number

Creates a saw wave generator node

 (play-now (mul (saw 440) (asdr 0.1 0.1 0 0)))

------------------------------------------------------------

(tri frequency-number-or-node)
Returns node-id-number

Creates a triangle wave generator node

 (play-now (mul (tri 440) (asdr 0.1 0.1 0 0)))

------------------------------------------------------------

(squ frequency-number-or-node)
Returns node-id-number

Creates a square wave generator node

 (play-now (mul (squ 440) (asdr 0.1 0.1 0 0)))

------------------------------------------------------------

(white frequency-number-or-node)
Returns node-id-number

Creates a white noise generator node

 (play-now (mul (white 5) (asdr 0.1 0.1 0 0)))

------------------------------------------------------------

(pink frequency-number-or-node)
Returns node-id-number

Creates a pink noise generator node

 (play-now (mul (pink 5) (asdr 0.1 0.1 0 0)))

------------------------------------------------------------

(add number-or-node number-or-node)
Returns node-id-number

Maths node - adds two signals together

 (play-now (mul (add (sine 440) (sine 220)) (asdr 0.1 0.1 0 0)))

------------------------------------------------------------

(sub number-or-node number-or-node)
Returns node-id-number

Maths node - subtracts two signals

 (play-now (mul (sub (sine 440) (sine 220)) (asdr 0.1 0.1 0 0)))

------------------------------------------------------------

(mul number-or-node number-or-node)
Returns node-id-number

Maths node - multiplies two signals

 (play-now (mul (mul (sine 440) (sine 220)) (asdr 0.1 0.1 0 0)))

------------------------------------------------------------

(mul number-or-node number-or-node)
Returns node-id-number

Maths node - multiplies two signals

 (play-now (mul (div (sine 440) 2) (asdr 0.1 0.1 0 0)))

------------------------------------------------------------

(pow number-or-node number-or-node)
Returns node-id-number

Maths node - produces a signal raised to the power of another

 (play-now (mul (pow (adsr 0 0.1 0 0) 10) (sine 440)))

------------------------------------------------------------

(adsr attack-number-or-node decay-number-or-node sustain-number-or-node release-number-or-node)
Returns node-id-number

Creates an envelope generator node

 (play-now (mul (sine 440) (asdr 0.1 0.1 0 0)))

------------------------------------------------------------

(mooglp signal-node cutoff-number-or-node resonance-number-or-node)
Returns node-id-number

Creates an low pass moog filter node

 (play-now (mul (mooglp (squ 440) 0.1 0.4) (asdr 0.1 0.1 0 0)))

------------------------------------------------------------

(moogbp signal-node cutoff-number-or-node resonance-number-or-node)
Returns node-id-number

Creates an band pass moog filter node

 (play-now (mul (moogbp (squ 440) 0.1 0.4) (asdr 0.1 0.1 0 0)))

------------------------------------------------------------

(mooghp signal-node cutoff-number-or-node resonance-number-or-node)
Returns node-id-number

Creates an high pass moog filter node

 (play-now (mul (mooghp (squ 440) 0.1 0.4) (asdr 0.1 0.1 0 0)))

------------------------------------------------------------

(formant signal-node cutoff-number-or-node resonance-number-or-node)
Returns node-id-number

Creates a formant filter node

 (play-now (mul (formant (squ 440) 0.1 0.4) (asdr 0.1 0.1 0 0)))

============================================================

Section: "osc"

OSC stands for Open Sound Control, and is a widely used protocol 
for passing data between multimedia applications. Fluxus can send 
or receive messages.

 An example of using osc to communicate between pd and fluxus.
 A fluxus script to move a cube based on incoming osc messages.
 -- osc.scm

 (define value 0)

 (define (test)
     (push)
     (if (osc-msg "/zzz")
         (set! value (osc 0)))
     (translate (vector 1 0 value))
     (draw-cube)
     (pop))
 
 (osc-source "6543")
 (every-frame (test))
 
 --- EOF
 A PD patch to send control messages to fluxus:
 --- zzz.pd
 #N canvas 618 417 286 266 10;
 #X obj 58 161 sendOSC;
 #X msg 73 135 connect localhost 6543;
 #X msg 58 82 send /zzz \$1;
 #X floatatom 58 29 5 0 0 0 - - -;
 #X obj 58 54 / 100;
 #X obj 73 110 loadbang;
 #X connect 1 0 0 0;
 #X connect 2 0 0 0;
 #X connect 3 0 4 0;
 #X connect 4 0 2 0;
 #X connect 5 0 1 0;

------------------------------------------------------------

(osc-source port-string)
Returns void

Starts up the osc server, or changes port. Known bug: seems to 
fail if you set it back to a port used previously.

 (osc-source "4444")	 ; listen to port 4444 for osc messages

------------------------------------------------------------

(osc-msg name-string)
Returns msgreceived-boolean

Returns true if the message has been received since the last frame, 
and sets it as the current message for subsequent calls to (osc) 
for reading the arguments.

 (cond 
     ((osc-msg "/hello")              ; if a the /hello message is recieved
         (display (osc 1))(newline)))	; print out the first argument

------------------------------------------------------------

(osc argument-number)
Returns oscargument

Returns the argument from the current osc message.

 (cond 
     ((osc-msg "/hello")              ; if a the /hello message is recieved
         (display (osc 1))(newline)))	; print out the first argument

------------------------------------------------------------

(osc-destination port-string)
Returns void

Specifies the destination for outgoing osc messages. The port 
name needs to specify the whole url and should look something 
like this "osc.udp://localhost:4444"

 (osc-destination "osc.udp:localhost:4444")
 (osc-send "/hello" "s" (list "boo!"))  ; send a message to this destination

------------------------------------------------------------

(osc-peek)
Returns msg-string

This util function returns the name, and format string and number/string 
arguments of the last sent message as a string - for debugging 
your osc network.

 (display (osc-peek))(newline) 

------------------------------------------------------------

(osc-send name-string format-string argument-list)
Returns void

Sends an osc message with the argument list as the osc data. Only 
supports floats, ints and strings as data. The format-string should 
be composed of "i", "f" and "s", and must match the types given 
in the list. This could probably be removed by using the types 
directly, but doing it this way allows you to explicitly set the 
typing for the osc message.

 (osc-destination "osc.udp:localhost:4444")
 (osc-send "/hello" "sif" (list "boo!" 3 42.3))  ; send a message to this destination

============================================================

Section: "renderer"

These commands are the low level renderer controls. You shouldn't 
need to deal with these unless you are being wily, or implementing 
a fluxus renderer outside of the scratchpad interface.

------------------------------------------------------------

(make-renderer)
Returns rendererid-number

Makes a new scenegraph renderer.

 (make-renderer) 

------------------------------------------------------------

(renderer-grab rendererid-number)
Returns void

Make this renderer the current context for commands.

 (renderer-grab renderer) 

------------------------------------------------------------

(renderer-ungrab)
Returns void

Pop the renderer context stack.

 (renderer-grab renderer) 

------------------------------------------------------------

(fluxus-render)
Returns void

Clears the backbuffer, and renders everything

 (fluxus-render) 

------------------------------------------------------------

(tick-physics)
Returns void

Update the physics system.

 (tick-physics) 

------------------------------------------------------------

(render-physics)
Returns void

Render the physics system (for helper graphics). This is the low 
level command - use set-physics-debug instead.

 (render-physics) 

------------------------------------------------------------

(reset-renderers)
Returns void

Deletes all the renderers and makes a new default one.

 (reset-renderers) 

------------------------------------------------------------

(reshape width-number height-number)
Returns void

Calls reshape on the current renderer

 (reshape 100 100) 

------------------------------------------------------------

(fluxus-init)
Returns void

Inits the whole rendering system, only needs calling once.

 (fluxus-init) 

------------------------------------------------------------

(fluxus-error-log)
Returns void

Returns a string containing error information for the last frame.

 (display (fluxus-error-log))

============================================================

Section: "turtle"

The turtle polybuilder is an experimental way of building polygonal 
objects using a logo style turtle in 3D space. As you drive the 
turtle around you can place vertices and build shapes procedurally. 
The turtle can also be used to deform existing polygonal primitives, 
by attaching it to objects you have already created.

 (define (build n)
     (turtle-reset)
     (turtle-prim 4)
     (build-loop n n)
     (turtle-build))
 
 (define (build-loop n t)
     (turtle-turn (vector 0 (/ 360 t) 0))
     (turtle-move 1)
     (turtle-vert)
     (if (< n 1)
         0
         (build-loop (- n 1) t)))

------------------------------------------------------------

(turtle-prim type-number)
Returns void

Starts building a new polygon primitive with the turtle. The type 
specifies the polygon face type and is one of the following: 0: 
triangle strip, 1: quad list, 2: triangle list, 3: triangle fan, 
4: general polygon

 (turtle-prim 0)

------------------------------------------------------------

(turtle-vert)
Returns void

Creates a new vertex in the current position, or sets the current 
vertex if the turtle builder is attached.

 (turtle-vert)

------------------------------------------------------------

(turtle-build)
Returns primitiveid-number

Builds the object with the vertex list defined and gives it to 
the renderer. Has no effect if the turtle builder is attached 
to a primitive.

 (define mynewshape (turtle-build))

------------------------------------------------------------

(turtle-move distance-number)
Returns void

Moves the turtle forward in it's current orientation.

 (turtle-move 1)

------------------------------------------------------------

(turtle-push)
Returns void

The turtle build has it's own transform stack. Push remembers 
the current position and orientation.

 (turtle-push)

------------------------------------------------------------

(turtle-pop)
Returns void

The turtle build has it's own transform stack. Pop forgets the 
current position and orientation, and goes back to the state at 
the last push.

 (turtle-pop)

------------------------------------------------------------

(turtle-turn rotation-vector)
Returns void

Rotates the turtle's orientation with the supplied euler angles 
(rotations in x, y and z).

 (turtle-turn (vector 45 0 0))

------------------------------------------------------------

(turtle-reset)
Returns void

Resets the current position and rotation of the turtle to the 
origin.

 (turtle-reset)

------------------------------------------------------------

(turtle-attach primitiveid-number)
Returns void

Attaches the turtle to an existing poly primitive. This means 
you are able to deform an existing objects points using the turtle 
builder.

 (define myshape (build-sphere 10 10))
 (turtle-attach myshape)

------------------------------------------------------------

(turtle-skip count-number)
Returns void

When attached, causes the turtle to skip vertices. This value 
may be negative, which will set the turtle to write to previous 
vertices.

 (turtle-skip -1)

------------------------------------------------------------

(turtle-position)
Returns count-number

When attached, returns the current pdata index the turtle is writing 
to.

 (display (turtle-position))(newline)

------------------------------------------------------------

(turtle-seek position-number)
Returns void

When attached, sets the absolute pdata index the turtle is writing 
to.

 (turtle-seek 0)

============================================================

Section: "physics"

The physics system used in fluxus is based on the ode library, 
which allows you to add physical properties to objects and set 
them in motion. Since ODE is designed for rigid-body simulations, 
structures are described in terms of objects, joints and forces. 
A much more comprehensive explanation of these concepts can be 
found in the ODE documentation, which you have probably downloaded 
if you have compiled fluxus, or can be found at @url{http://ode.org/ode-docs.html} 
To help with debugging joints, try calling (render-physics) every 
frame, which will render locators showing you positions and axes 
of joints that have positional information.

------------------------------------------------------------

(collisions on/off-number)
Returns void

Enables or disables collision detection. Defaults to off.

 (collisions 1)

------------------------------------------------------------

(ground-plane plane-vector offset-number)
Returns void

Create an infinite passive plane for use as the 'ground'

 (ground-plane (vector 0 1 0) 0)

------------------------------------------------------------

(active-box primitiveid-number)
Returns void

Enable the object to be acted upon by the physics system, using 
a box as the bounding volume. As an active object, it will be 
transformed by ode. Note: rotations only work correctly if you 
specify your transforms scale first, then rotate (translate doesn't 
matter) basically, ode can't deal with shearing transforms.

 (define mycube (build-cube))
 (active-box mycube)

------------------------------------------------------------

(active-cylinder primitiveid-number)
Returns void

Enable the object to be acted upon by the physics system, using 
a cylinder as the bounding volume. As an active object, it will 
be transformed by ode. Note: rotations only work correctly if 
you specify your transforms scale first, then rotate (translate 
doesn't matter) basically, ode can't deal with shearing transforms.

 (define mycube (build-cube))
 (active-cylinder mycube)

------------------------------------------------------------

(active-sphere primitiveid-number)
Returns void

Enable the object to be acted upon by the physics system, using 
a sphere as the bounding volume. As an active object, it will 
be transformed by ode. Note: rotations only work correctly if 
you specify your transforms scale first, then rotate (translate 
doesn't matter) basically, ode can't deal with shearing transforms.

 (define mycube (build-cube))
 (active-sphere mycube)

------------------------------------------------------------

(passive-box primitiveid-number)
Returns void

Enable the object to be acted upon by the physics system, using 
a box as the bounding volume. As a passive object, active objects 
will collide with it, but it will not be transformed. Note: rotations 
only work correctly if you specify your transforms scale first, 
then rotate (translate doesn't matter) basically, ode can't deal 
with shearing transforms.

 (define mycube (build-cube))
 (passive-box mycube)

------------------------------------------------------------

(passive-cylinder primitiveid-number)
Returns void

Enable the object to be acted upon by the physics system, using 
a cylinder as the bounding volume. As a passive object, active 
objects will collide with it, but it will not be transformed. 
Note: rotations only work correctly if you specify your transforms 
scale first, then rotate (translate doesn't matter) basically, 
ode can't deal with shearing transforms.

 (define mycube (build-cube))
 (passive-cylinder mycube)

------------------------------------------------------------

(passive-sphere primitiveid-number)
Returns void

Enable the object to be acted upon by the physics system, using 
a sphere as the bounding volume. As a passive object, active objects 
will collide with it, but it will not be transformed. Note: rotations 
only work correctly if you specify your transforms scale first, 
then rotate (translate doesn't matter) basically, ode can't deal 
with shearing transforms.

 (define mycube (build-cube))
 (passive-sphere mycube)

------------------------------------------------------------

(surface-params slip1-number slip2-number softerp-number softcfm-number)
Returns void

Sets some global surface attributes that affect friction and bouncyness. 
see section 7.3.7 of the ODE docs for an explanation of these 
parameters

 (surface-params 0.1 0.1 0.1 0.1)

------------------------------------------------------------

(build-balljoint primitiveid-number primitiveid-number axis-vector)
Returns void

Creates a balljoint to connect two objects (see the ode docs for 
a detailed description of the differences between the joint types). 
ODE considers joints to be a constraint that is enforced between 
two objects. When creating a joint, it is important to have the 
two primitives being joined in the desired positions before creating 
the joint. Joints can be created, modified and indexed in a similar 
way to other primitives.

 (clear)
 (ground-plane (vector 0 1 0) -1)
 (collisions 1)
 
 (define shape1 (with-state 
         (translate (vector -1 0 0))
         (build-cube)))
 (active-box shape1)
 
 (define shape2 (with-state 
         (translate (vector 1 0 0))
         (build-cube)))
 (active-box shape2)
 
 (build-balljoint shape1 shape2 (vector 0 0 0)) 
 (kick shape1 (vector 0 2 0))
 
 (set-physics-debug #t)

------------------------------------------------------------

(build-fixedjoint primitiveid-number)
Returns void

Creates a joint to connect an object to the global environment. 
This locks the object in place.

 (clear)
 (define shape1 (with-state 
         (translate (vector 0 1 0))
         (build-cube)))
 (active-box shape1)
 
 (build-fixedjoint shape1) ; not very exciting... 

------------------------------------------------------------

(build-hingejoint primitiveid1-number primitiveid2-number anchor-vector axis-vector)
Returns hingeid-number

Creates a ball joint to connect two objects (see the ode docs 
for a detailed description of the differences between the joint 
types). ODE considers joints to be a constraint that is enforced 
between two objects. When creating a joint, it is important to 
have the two primitives being joined in the desired positions 
before creating the joint. Joints can be created, modified and 
indexed in a similar way to other primitives.

 (clear)
 (ground-plane (vector 0 1 0) -1)
 (collisions 1)
 
 (define shape1 (with-state 
         (translate (vector -1 0 0))
         (build-cube)))
 (active-box shape1)
 
 (define shape2 (with-state 
         (translate (vector 1 0 0))
         (build-cube)))
 (active-box shape2)
 
 (build-hingejoint shape1 shape2 (vector 0 0 0) (vector 0 0 1)) 
 (kick shape1 (vector 0 2 0))
 
 (set-physics-debug #t)

------------------------------------------------------------

(build-sliderjoint primitiveid1-number primitiveid2-number axis-vector)
Returns hingeid-number

Creates a slider joint to connect two objects (see the ode docs 
for a detailed description of the differences between the joint 
types). ODE considers joints to be a constraint that is enforced 
between two objects. When creating a joint, it is important to 
have the two primitives being joined in the desired positions 
before creating the joint. Joints can be created, modified and 
indexed in a similar way to other primitives.

 (clear)
 (ground-plane (vector 0 1 0) -1)
 (collisions 1)
 
 (define shape1 (with-state 
         (translate (vector -1 0 0))
         (build-cube)))
 (active-box shape1)
 
 (define shape2 (with-state 
         (translate (vector 1 0 0))
         (build-cube)))
 (active-box shape2)
 
 (build-sliderjoint shape1 shape2 (vector 1 0 0)) 
 (kick shape1 (vector 0 2 0))
 
 (set-physics-debug #t)

------------------------------------------------------------

(build-hinge2joint primitiveid1-number primitiveid2-number anchor-vector axis1-vector axis2-vector)
Returns hingeid-number

Creates a hinge2 joint to connect two objects (see the ode docs 
for a detailed description of the differences between the joint 
types). ODE considers joints to be a constraint that is enforced 
between two objects. When creating a joint, it is important to 
have the two primitives being joined in the desired positions 
before creating the joint. Joints can be created, modified and 
indexed in a similar way to other primitives.

 (clear)
 (ground-plane (vector 0 1 0) -1)
 (collisions 1)
 
 (define shape1 (with-state 
         (translate (vector -1 0 0))
         (build-cube)))
 (active-box shape1)
 
 (define shape2 (with-state 
         (translate (vector 1 0 0))
         (build-cube)))
 (active-box shape2)
 
 (build-hinge2joint shape1 shape2 (vector 0 0 0) (vector 1 0 0) (vector 0 1 0)) 
 (kick shape1 (vector 0 2 0))
 
 (set-physics-debug #t)

------------------------------------------------------------

(build-amotorjoint primitiveid1-number primitiveid2-number axis-vector)
Returns hingeid-number

Creates a angular motor joint to connect two objects (see the 
ode docs for a detailed description of the differences between 
the joint types). ODE considers joints to be a constraint that 
is enforced between two objects. When creating a joint, it is 
important to have the two primitives being joined in the desired 
positions before creating the joint. Joints can be created, modified 
and indexed in a similar way to other primitives.

 (clear)
 (ground-plane (vector 0 1 0) -1)
 (collisions 1)
 
 (define shape1 (with-state 
         (translate (vector -1 0 0))
         (build-cube)))
 (active-box shape1)
 
 (define shape2 (with-state 
         (translate (vector 1 0 0))
         (build-cube)))
 (active-box shape2)
 
 (build-amotorjoint shape1 shape2 (vector 1 0 0)) 
 (kick shape1 (vector 0 2 0))
 
 (set-physics-debug #t)

------------------------------------------------------------

(joint-param jointid-number param-string value-number)
Returns hingeid-number

Sets the joint parameter for a joint where param is one of the 
following: "HiStop", "Vel", "FMax", "FudgeFactor", "Bounce", "CFM", 
"StopERP", "StopCFM","SuspensionERP", "SuspensionCFM", "Vel2", 
"FMax2". see section 7.5.1 of the ODE docs for an explanation 
of each of these parameters, and which joint types they apply 
to.

 (clear)
 (ground-plane (vector 0 1 0) -1)
 (collisions 1)
 
 (define shape1 (with-state 
         (translate (vector -1 0 0))
         (build-cube)))
 (active-box shape1)
 
 (define shape2 (with-state 
         (translate (vector 1 0 0))
         (build-cube)))
 (active-box shape2)
 
 (define j (build-hinge2joint shape1 shape2 (vector 0 0 0) (vector 1 0 0) (vector 1 0 0)))
 (joint-param j "Vel2" 0.1)
 (joint-param j "FMax2" 0.2)
 (joint-param j "LoStop" -0.75)
 (joint-param j "HiStop" 0.75)
 
 (set-physics-debug #t)

------------------------------------------------------------

(joint-angle jointid-number angle-number vel-number)
Returns void

Set a new angle for this joint, with a given velocity taken to 
get there

 (clear)
 (ground-plane (vector 0 1 0) -1)
 (collisions 1)
 
 (define shape1 (with-state 
         (translate (vector -1 0 0))
         (build-cube)))
 (active-box shape1)
 
 (define shape2 (with-state 
         (translate (vector 1 0 0))
         (build-cube)))
 (active-box shape2)
 
 (define j (build-hingejoint shape1 shape2 (vector 0 0 0) (vector 0 1 0)))
 (joint-param j "FMax" 20)
 (joint-param j "LoStop" -1)
 (joint-param j "HiStop" 1)
 
 (set-physics-debug #t)
 
 (define (animate)
     (joint-angle j 0.1 (* 5 (sin (time)))))

------------------------------------------------------------

(set-max-physical max-number)
Returns void

Sets the maximum number of objects the physics system can deal 
with. When the max level has been reached the oldest objects are 
automatically destroyed.

 (clear)
 (set-max-physical 200)
 
 (every-frame
     (with-state
     (translate (vector 0 5 0))
         (scale (srndvec))
         (colour (rndvec))
         (let ((ob (build-cube)))    
             (active-box ob)
             (kick ob (vmul (srndvec) 3))
             (twist ob (vmul (srndvec) 2)))))

------------------------------------------------------------

(set-mass primitiveid-number mass-number)
Returns void

Sets the mass of an active object

 (clear)
 (ground-plane (vector 0 1 0) 0)
 (collisions 1)
 (set-max-physical 20)
 
 ; not a great example, but these boxes will have 
 ; different mass, so behave a bit differently.
 
 (every-frame
     (when (> (rndf) 0.92)
         (with-state
             (translate (vector 0 5 0))
             (scale (vmul (rndvec) 5))
             (colour (rndvec))
             (let ((ob (build-cube)))    
                 (active-box ob)
                 (set-mass ob (* (rndf) 10))
                 (kick ob (vmul (srndvec) 3))
                 (twist ob (vmul (srndvec) 2))))))    

------------------------------------------------------------

(gravity gravity-vector)
Returns void

Sets the strength and direction of gravity.

 (clear)
 (ground-plane (vector 0 1 0) 0)
 (collisions 1)
 (set-max-physical 20)
 
 (every-frame
     (begin
         (gravity (vector 0 (sin (time)) 0)) ; change gravity! :)
         (when (> (rndf) 0.92)
             (with-state
                 (translate (vector 0 5 0))
                 (scale (rndvec))
                 (colour (rndvec))
                 (let ((ob (build-cube)))    
                     (active-box ob)
                     (kick ob (vmul (srndvec) 3))
                     (twist ob (vmul (srndvec) 2)))))))

------------------------------------------------------------

(kick primitiveid-number kick-vector)
Returns void

Applies translation force to the object

 (clear)
 (collisions 1)
 (set-max-physical 20)
 (gravity (vector 0 0 0)) 
 
 (every-frame
     (when (> (rndf) 0.92)
         (with-state
             (scale (rndvec))
             (colour (rndvec))
             (let ((ob (build-cube)))    
                 (active-box ob)
                 (kick ob (vmul (srndvec) 3))
                 (twist ob (vmul (srndvec) 2))))))

------------------------------------------------------------

(twist primitiveid-number spin-vector)
Returns void

Applies rotational force to the object

 (clear)
 (collisions 1)
 (set-max-physical 20)
 (gravity (vector 0 0 0)) 
 
 (every-frame
     (when (> (rndf) 0.92)
         (with-state
             (scale (rndvec))
             (colour (rndvec))
             (let ((ob (build-cube)))    
                 (active-box ob)
                 (kick ob (vmul (srndvec) 3))
                 (twist ob (vmul (srndvec) 2))))))

------------------------------------------------------------

(has-collided primitiveid-number)
Returns void

Returns true if the grabbed object collided in the last frame

 (clear)
 (ground-plane (vector 0 1 0) 0)
 (collisions 1)
 (set-max-physical 20)
 
 (define ob (with-state
     (translate (vector 0 5 0))
     (build-cube)))
 
 (active-box ob)
 
 (every-frame
     (when (has-collided ob)
         (with-primitive ob
             (colour (rndvec)))))

============================================================

Section: "maths"

These functions are optimised for 3D graphics, and the collision 
of computer science and maths is apparent here, so scheme vectors 
representing maths vectors are in this context taken to be 3 elements 
long, quaternions are vectors of length 4, and matrices are vectors 
of 16 elements long.

------------------------------------------------------------

(vmul vector number)
Returns result-vector

Multiplies a vector by a number

 (vmul (vector 1 2 3) 2)

------------------------------------------------------------

(vadd vector vector)
Returns result-vector

Adds two vectors together

 (vadd (vector 1 2 3) (vector 1 2 3))

------------------------------------------------------------

(vsub vector vector)
Returns result-vector

Subtracts a vector from another

 (vsub (vector 1 2 3) (vector 1 2 3))

------------------------------------------------------------

(vdiv vector number)
Returns result-vector

Divides a vector by a number

 (vdiv (vector 1 2 3) 2)

------------------------------------------------------------

(vtransform vector matrix)
Returns result-vector

Multiplies (transforms) a vector by a matrix

 (vtransform (vector 0 1 0) (mrotate (vector 90 0 0)))

------------------------------------------------------------

(vtransform-rot vector matrix)
Returns result-vector

Multiplies (transforms) a vector by a matrix, but leaves out the 
translation part. For operations involving normals.

 (vtransform-rot (vector 0 1 0) (mrotate (vector 90 0 0)))

------------------------------------------------------------

(vnormalise vector)
Returns result-vector

Returns the normalised form of the vector (length=1)

 (vtransform-rot (vector 0 1 0) (mrotate (vector 90 0 0)))

------------------------------------------------------------

(vdot vector vector)
Returns result-number

Returns the dot product of two vectors

 (vdot (vector 0 1 0) (vector 1 0 0))

------------------------------------------------------------

(vmag vector)
Returns result-number

Returns the magnitude, or length of the vector

 (vmag (vector 0 1 1))

------------------------------------------------------------

(vreflect vector vector)
Returns result-vector

Returns the reflection of one vector against another.

 (vreflect (vector 0 1 1) (vector 1 0 1))

------------------------------------------------------------

(vdist vector vector)
Returns result-number

Treating the vectors as points, returns the distance between them.

 (vdist (vector 100 100 0) (vector 0 0 100))

------------------------------------------------------------

(vcross vector vector)
Returns result-vector

Returns the cross product of two vectors, resulting in a vector 
that is perpendicular to the crossed ones.

 (vcross (vector 100 100 0) (vector 0 0 100))

------------------------------------------------------------

(mmul matrix-vector matrix-vector)
Returns matrix-vector

Multiplies two matrices together

 (mmul (mtranslate (vector 1 0 0)) (mrotate (vector 0 90 0)))

------------------------------------------------------------

(madd matrix-vector matrix-vector)
Returns matrix-vector

Adds two matrices together

 (madd (mtranslate (vector 1 0 0)) (mrotate (vector 0 90 0)))

------------------------------------------------------------

(msub matrix-vector matrix-vector)
Returns matrix-vector

Subtracts a matrix from another.

 (msub (mtranslate (vector 1 0 0)) (mrotate (vector 0 90 0)))

------------------------------------------------------------

(mdiv matrix-vector matrix-vector)
Returns matrix-vector

Divides a matrix by another

 (mdiv (mtranslate (vector 1 0 0)) (mrotate (vector 0 90 0)))

------------------------------------------------------------

(mident)
Returns matrix-vector

Returns the identity matrix

 (mident)

------------------------------------------------------------

(mtranslate vector)
Returns matrix-vector

Returns a matrix representing the specified transform

 (mtranslate (vector 100 0 0))

------------------------------------------------------------

(mrotate vector)
Returns matrix-vector

Returns a matrix representing the specified rotation. Accepts 
a vector of euler angles, or a quaternion.

 (mrotate (vector 0 45 0))

------------------------------------------------------------

(mscale vector)
Returns matrix-vector

Returns a matrix representing the specified scaling.

 (mscale (vector 0.5 2 0.5))

------------------------------------------------------------

(mtranspose matrix-vector)
Returns matrix-vector

Returns the transpose of the input vector

 (mtranspose (mident))

------------------------------------------------------------

(minverse matrix-vector)
Returns matrix-vector

Returns the inverse of the input vector.

 (minverse (mscale (vector 0.5 2 0.5)))

------------------------------------------------------------

(maim aim-vector up-vector)
Returns matrix-vector

Returns a matrix representing an aiming rotation so that the x 
axis points down the aim direction, and the y axis points up the 
up vector. Probably suffers from gimbal lock.

 (maim (vector 0 0 1) (vector 0 1 0))

------------------------------------------------------------

(qaxisangle axis-vector angle-number)
Returns quaternion-vector

Returns the quaternion representing rotation of angle degrees 
about the specified axis.

 (qaxisangle (vector 0 1 0) 45)

------------------------------------------------------------

(qmul quaternion-vector quaternion-vector)
Returns quaternion-vector

Multiplies two quaternions together.

 (qmul (qaxisangle (vector 0 1 0) 45) (qaxisangle (vector 0 0 1) 180))

------------------------------------------------------------

(qnormalise quaternion-vector)
Returns quaternion-vector

Normalises a quaternion.

 (qnormalise (qaxisangle (vector 0 19 0) 45))

------------------------------------------------------------

(qtomatrix quaternion-vector)
Returns matrix-vector

Converts a quaternion into a rotation matrix.

 (qtomatrix (qaxisangle (vector 0 1 0) 45))

------------------------------------------------------------

(qconjugate quaternion-vector)
Returns quaternion-vector

Conjugatea a quaternion.

 (qconjugate (qaxisangle (vector 0 1 0) 45))

------------------------------------------------------------

(fmod numerator-number denominator-number)
Returns real-number

Returns the floating-point remainder of numerator/denominator.

 (fmod 14.4 10)

============================================================

Section: "lights"

Without lights you wouldn't be able to see anything. Luckily fluxus 
gives you one for free by default, a white diffuse point light 
attached to the camera. For more interesting lighting, you'll 
need these functions. Using the standard fixed function graphics 
pipeline, simplistically speaking, OpenGL multiplies these values 
with the surface material (set with local state commands like 
ambient and diffuse) and the texture colour value to give the 
final colour.

 ; turn off the main light
 (light-diffuse 0 (vector 0 0 0))
 (light-specular 0 (vector 0 0 0))
 (light-ambient 0 (vector 0 0 0))
 
 (define mylight (make-light 'point 'free))
 (light-position mylight (vector 5 2 0))
 (light-diffuse mylight (rndvec))
 (light-ambient mylight (vmul (rndvec) 0.1))
 (light-specular mylight (vmul (rndvec) 10))
 
 (with-state
     (ambient (vector 1 1 1))
     (colour (vector 1 1 1))
     (specular (vector 0.5 0.5 0.5))
     (shinyness 20)
     (build-torus 1 2 20 20)) 

------------------------------------------------------------

(make-light type-symbol cameralocked-symbol)
Returns lightid-number

Makes a new light. The type can be one of: point, directional 
or spot. If the cameralocked string is not free then it will be 
attached to the camera, and move around when you move the camera.

 ; turn off the main light
 (light-diffuse 0 (vector 0 0 0))
 (light-specular 0 (vector 0 0 0))
 (light-ambient 0 (vector 0 0 0))
 
 (define mylight (make-light 'point 'free))
 (light-position mylight (vector 5 2 0))
 (light-diffuse mylight (rndvec))
 (light-ambient mylight (vmul (rndvec) 0.1))
 (light-specular mylight (vmul (rndvec) 10))
 
 (with-state
     (ambient (vector 1 1 1))
     (colour (vector 1 1 1))
     (specular (vector 0.5 0.5 0.5))
     (shinyness 20)
     (build-torus 1 2 20 20)) 

------------------------------------------------------------

(light-ambient lightid-number colour)
Returns void

Sets the ambient contribution for the specified light.

 ; turn off the main light
 (light-diffuse 0 (vector 0 0 0))
 (light-specular 0 (vector 0 0 0))
 (light-ambient 0 (vector 0 0 0))
 
 (define mylight (make-light 'point 'free))
 (light-position mylight (vector 5 2 0))
 (light-diffuse mylight (rndvec))
 (light-ambient mylight (vmul (rndvec) 0.1))
 (light-specular mylight (vmul (rndvec) 10))
 
 (with-state
     (ambient (vector 1 1 1))
     (colour (vector 1 1 1))
     (specular (vector 0.5 0.5 0.5))
     (shinyness 20)
     (build-torus 1 2 20 20)) 

------------------------------------------------------------

(light-diffuse lightid-number colour)
Returns void

Sets the diffuse contribution for the specified light.

 ; turn off the main light
 (light-diffuse 0 (vector 0 0 0))
 (light-specular 0 (vector 0 0 0))
 (light-ambient 0 (vector 0 0 0))
 
 (define mylight (make-light 'point 'free))
 (light-position mylight (vector 5 2 0))
 (light-diffuse mylight (rndvec))
 (light-ambient mylight (vmul (rndvec) 0.1))
 (light-specular mylight (vmul (rndvec) 10))
 
 (with-state
     (ambient (vector 1 1 1))
     (colour (vector 1 1 1))
     (specular (vector 0.5 0.5 0.5))
     (shinyness 20)
     (build-torus 1 2 20 20)) 

------------------------------------------------------------

(light-specular lightid-number colour)
Returns void

Sets the specular contribution for the specified light.

 ; turn off the main light
 (light-diffuse 0 (vector 0 0 0))
 (light-specular 0 (vector 0 0 0))
 (light-ambient 0 (vector 0 0 0))
 
 (define mylight (make-light 'point 'free))
 (light-position mylight (vector 5 2 0))
 (light-diffuse mylight (rndvec))
 (light-ambient mylight (vmul (rndvec) 0.1))
 (light-specular mylight (vmul (rndvec) 10))
 
 (with-state
     (ambient (vector 1 1 1))
     (colour (vector 1 1 1))
     (specular (vector 0.5 0.5 0.5))
     (shinyness 20)
     (build-torus 1 2 20 20)) 

------------------------------------------------------------

(light-position lightid-number position-vector)
Returns void

Sets the position of the specified light. In worldspace if free, 
in camera space is attached.

 ; turn off the main light
 (light-diffuse 0 (vector 0 0 0))
 (light-specular 0 (vector 0 0 0))
 (light-ambient 0 (vector 0 0 0))
 
 (define mylight (make-light 'point 'free))
 (light-position mylight (vector 5 2 0))
 (light-diffuse mylight (rndvec))
 (light-ambient mylight (vmul (rndvec) 0.1))
 (light-specular mylight (vmul (rndvec) 10))
 
 (with-state
     (ambient (vector 1 1 1))
     (colour (vector 1 1 1))
     (specular (vector 0.5 0.5 0.5))
     (shinyness 20)
     (build-torus 1 2 20 20)) 

------------------------------------------------------------

(light-spot-angle lightid-number angle-number)
Returns void

Sets the spotlight cone angle of the specified light. If it's 
not a spot light, this command has no effect.

 ; turn down the main light
 (light-diffuse 0 (vector 0.1 0.1 0.1))
 (light-specular 0 (vector 0 0 0))
 (light-ambient 0 (vector 0 0 0))
 
 (define mylight (make-light 'spot 'free))
 (light-position mylight (vector (+ 4 (crndf)) (crndf) 2))
 (light-diffuse mylight (rndvec))
 (light-ambient mylight (vmul (rndvec) 0.1))
 (light-specular mylight (vmul (rndvec) 10))
 (light-spot-angle mylight (+ 5 (random 40)))
 (light-spot-exponent mylight 500)
 (light-attenuation mylight 'constant 1) 
 (light-direction mylight (vector -1 0 -1))
 
 (with-state
     (ambient (vector 1 1 1))
     (colour (vector 1 1 1))
     (specular (vector 0.5 0.5 0.5))
     (shinyness 20)
     (build-torus 1 2 20 20)
     (scale (vector 10 10 10))
     (translate (vector -0.5 -0.5 0))
     (build-seg-plane 20 20)) 

------------------------------------------------------------

(light-spot-exponent lightid-number exponent-number)
Returns void

Sets the spotlight exponent (fuzzyness of the cone) of the specified 
light. If it's not a spot light, this command has no effect.

 ; turn down the main light
 (light-diffuse 0 (vector 0.1 0.1 0.1))
 (light-specular 0 (vector 0 0 0))
 (light-ambient 0 (vector 0 0 0))
 
 (define mylight (make-light 'spot 'free))
 (light-position mylight (vector (+ 4 (crndf)) (crndf) 2))
 (light-diffuse mylight (rndvec))
 (light-ambient mylight (vmul (rndvec) 0.1))
 (light-specular mylight (vmul (rndvec) 10))
 (light-spot-angle mylight (+ 5 (random 40)))
 (light-spot-exponent mylight 500)
 (light-attenuation mylight 'constant 1) 
 (light-direction mylight (vector -1 0 -1))
 
 (with-state
     (ambient (vector 1 1 1))
     (colour (vector 1 1 1))
     (specular (vector 0.5 0.5 0.5))
     (shinyness 20)
     (build-torus 1 2 20 20)
     (scale (vector 10 10 10))
     (translate (vector -0.5 -0.5 0))
     (build-seg-plane 20 20)) 

------------------------------------------------------------

(light-attenuation lightid-number type-symbol attenuation-number)
Returns void

Sets the light attenuation (fade off with distance) of the specified 
light. The type symbol can be one of: constant, linear or quadratic.

 ; turn down the main light
 (light-diffuse 0 (vector 0.1 0.1 0.1))
 (light-specular 0 (vector 0 0 0))
 (light-ambient 0 (vector 0 0 0))
 
 (define mylight (make-light 'spot 'free))
 (light-position mylight (vector (+ 4 (crndf)) (crndf) 2))
 (light-diffuse mylight (rndvec))
 (light-ambient mylight (vmul (rndvec) 0.1))
 (light-specular mylight (vmul (rndvec) 10))
 (light-spot-angle mylight (+ 5 (random 40)))
 (light-spot-exponent mylight 500)
 (light-attenuation mylight 'constant 1) 
 (light-direction mylight (vector -1 0 -1))
 
 (with-state
     (ambient (vector 1 1 1))
     (colour (vector 1 1 1))
     (specular (vector 0.5 0.5 0.5))
     (shinyness 20)
     (build-torus 1 2 20 20)
     (scale (vector 10 10 10))
     (translate (vector -0.5 -0.5 0))
     (build-seg-plane 20 20)) 

------------------------------------------------------------

(light-direction lightid-number direction-vector)
Returns void

Sets the direction of a directional light. If it's not a directional 
light, this command has no effect.

 ; turn down the main light
 (light-diffuse 0 (vector 0.1 0.1 0.1))
 (light-specular 0 (vector 0 0 0))
 (light-ambient 0 (vector 0 0 0))
 
 (define mylight (make-light 'spot 'free))
 (light-position mylight (vector (+ 4 (crndf)) (crndf) 2))
 (light-diffuse mylight (rndvec))
 (light-ambient mylight (vmul (rndvec) 0.1))
 (light-specular mylight (vmul (rndvec) 10))
 (light-spot-angle mylight (+ 5 (random 40)))
 (light-spot-exponent mylight 500)
 (light-attenuation mylight 'constant 1) 
 (light-direction mylight (vector -1 0 -1))
 
 (with-state
     (ambient (vector 1 1 1))
     (colour (vector 1 1 1))
     (specular (vector 0.5 0.5 0.5))
     (shinyness 20)
     (build-torus 1 2 20 20)
     (scale (vector 10 10 10))
     (translate (vector -0.5 -0.5 0))
     (build-seg-plane 20 20)) 

============================================================

Section: "audio"

This part of fluxus is responsible for capturing the incoming 
sound, and processing it into harmonic data, using fft (Fast Fourier 
Transform). The harmonics are bands of frequency which the sound 
is split into, giving some indication of the quality of the sound. 
It's the same as you see on a graphic equaliser - in fact, one 
of the example scripts (bars.scm) acts as a graphic equaliser 
display, and should be used to test the audio is working.

 (start-audio "alsa_pcm:capture_1" 1024 44100)
 (define (animate)
		(colour (vector (gh 1) (gh 2) (gh 3))) ; make a colour from the harmonics, and set it to be the current colour 
		(draw-cube)) ; draw a cube with this colour
 (every-frame (animate))

------------------------------------------------------------

(start-audio jackport-string buffersize-number samplerate-number)
Returns void

Starts up the audio with the specified settings, you'll need to 
call this first, or put it into $HOME/.fluxus.scm to call it automatically 
at startup. Make the jack port name an empty string and it won't 
try to connect to anything for you. You can use qjackctrl or equivelent 
to do the connection manually. Fluxus reads a single mono source.

 (start-audio "alsa_pcm:capture_1" 1024 44100)

------------------------------------------------------------

(gh harmonic-number)
Returns harmonic-real

Fluxus converts incoming audio into harmonic frequencies, which 
can then be plugged into your animations using this command. There 
are 16 harmonic bands availible, the harmonic-value argument will 
be wrapped around if greater or less than 16, so you can use this 
command without worrying about out of range errors.

 (define (animate)
		(colour (vector (gh 1) (gh 2) (gh 3))) ; make a colour from the harmonics, and set it to be the current colour 
		(draw-cube)) ; draw a cube with this colour
 (every-frame (animate))

------------------------------------------------------------

(gain gain-number)
Returns void

Sets the gain level for the fft sound, it's 1 by default.

 (gain 100) ; too quiet?!

------------------------------------------------------------

(process wavfile-string)
Returns void

This command temporarally disables the realtime reading of the 
input audio stream and reads a wav file instead. For use with 
the framedump command to process audio offline to make music videos. 
The advantage of this is that it locks the framerate so the right 
amount of audio gets read for each frame - making syncing of the 
frames and audio files possible.

 (process "somemusic.wav") ; read a precorded audio file

------------------------------------------------------------

(smoothing-bias value-number)
Returns void

A kind of weighted average for the harmonic bands which smooth 
them out over time. This setting defaults to 1.5. The best value 
really depends on the quality of the music, and the buffer sizes, 
and ranges from 0 -> 2. It's more obvious if you give it a try 
with the bars.scm script

 (smoothing-bias 0) ; no smoothing

------------------------------------------------------------

(update-audio)
Returns void

Updates the audio subsytem. This function is called for you (per 
frame) in fluxus-canvas.ss.


============================================================

Section: "global-state"

Global state is really anything that controls the renderer globally, 
so it affects all primitives or controls the renderer directly 
- ie camera control or full screen effects like blurring.

------------------------------------------------------------

(clear-engine)
Returns void

Clears the renderer, and physics system. This command should not 
be called directly, use clear instead, as this clears a few other 
things, and calls clear-engine itself.

 (clear-engine) ; woo hoo!

------------------------------------------------------------

(blur amount-number)
Returns void

Sets the full screen blur setting. Less is more, but if you set 
it too low it will make the on screen editing impossible to read, 
so save your script first :)

 (blur 0.1) ; for nice trails

------------------------------------------------------------

(fog fogcolour-vector amount-number begin-number end-number)
Returns void

Sets the fogging parameters to give a visual depth cue (aerial 
perspective in painter's jargon). This can obscure the on screen 
editing, so keep the amount small.

 (clear-colour (vector 0 0 1))   ; looks nice if the background matches
 (fog (vector 0 0 1) 0.01 1 100) ; blue fog

------------------------------------------------------------

(show-axis show-number)
Returns void

Shows the worldspace origin axis used.

 (show-axis 1)

------------------------------------------------------------

(show-fps show-number)
Returns void

Shows an fps count in the lower left of the screen. used.

 (show-fps 1)

------------------------------------------------------------

(lock-camera primitiveid-number)
Returns void

Locks the camera transform onto the specified primitive's transform. 
It's like parenting the camera to the object. This is the easiest 
way to procedurally drive the camera. Use an id number of 0 to 
unlock the camera.

 (clear)
 (define obj (build-cube)) ; make a cube for the camera to lock to
 
 (with-state ; make a background cube so we can tell what's happening
     (hint-wire)
     (hint-unlit)
     (texture (load-texture "test.png"))
     (colour (vector 0.5 0.5 0.5))
     (scale (vector -20 -10 -10))
     (build-cube))
 
 (lock-camera obj) ; lock the camera to our first cube
 (camera-lag 0.1)  ; set the lag amount, this will smooth out the cube jittery movement
 
 (define (animate)
     (with-primitive obj
         (identity)
         (translate (vector (fmod (time) 5) 0 0)))) ; make a jittery movement
 
 (every-frame (animate))

------------------------------------------------------------

(camera-lag amount-number)
Returns void

The camera locking has an inbuilt lagging which means it will 
smoothly blend the movement relative to the primitive it's locked 
to.

 (clear)
 (define obj (build-cube)) ; make a cube for the camera to lock to
 
 (with-state ; make a background cube so we can tell what's happening
     (hint-wire)
     (hint-unlit)
     (texture (load-texture "test.png"))
     (colour (vector 0.5 0.5 0.5))
     (scale (vector -20 -10 -10))
     (build-cube))
 
 (lock-camera obj) ; lock the camera to our first cube
 (camera-lag 0.1)  ; set the lag amount, this will smooth out the cube jittery movement
 
 (define (animate)
     (with-primitive obj
         (identity)
         (translate (vector (fmod (time) 5) 0 0)))) ; make a jittery movement
 
 (every-frame (animate))

------------------------------------------------------------

(load-texture pngfilename-string optional-create-params-list)
Returns textureid-number

Loads a texture from disk, converts it to a texture, and returns 
the id number. The texture loading is memory cached, so repeatedly 
calling this will not cause it to load again. The cache can be 
cleared with clear-texture-cache. The png may be RGB or RGBA to 
use alpha transparency. To get more control how your texture is 
created you can use a list of parameters. See the example for 
more explanation. Use id for adding more texture data to existing 
textures as mipmap levels, or cube map faces. Note: if turning 
mipmapping off and only specifing one texture it should be set 
to mip level 0, and you'll need to turn the min and mag filter 
settings to linear or nearest (see texture-params).

 ; simple usage:
 (texture (load-texture "mytexture.png"))
 (build-cube) ; the cube will be texture mapped with the image
 
 ; complex usages:
 
 ; the options list can contain the following keys and values:
 ; id: texture-id-number (for adding images to existing textures - for mipmapping and cubemapping)
 ; type: [texture-2d cube-map-positive-x cube-map-negative-x cube-map-positive-y 
 ;         cube-map-negative-y cube-map-positive-z cube-map-negative-z]
 ; generate-mipmaps : exact integer, 0 or 1
 ; mip-level : exact integer
 ; border : exact integer
 
 ; setup an environment cube map
 (define t (load-texture "cube-left.png" (list 'type 'cube-map-positive-x)))
 (load-texture "cube-right.png" (list 'id t 'type 'cube-map-negative-x))
 (load-texture "cube-top.png" (list 'id t 'type 'cube-map-positive-y))
 (load-texture "cube-bottom.png" (list 'id t 'type 'cube-map-negative-y))
 (load-texture "cube-front.png" (list 'id t 'type 'cube-map-positive-z))
 (load-texture "cube-back.png" (list 'id t 'type 'cube-map-negative-z))
 (texture t)

 ; setup a mipmapped texture with our own images
 ; you need as many levels as it takes you to get to 1X1 pixels from your
 ; level 0 texture size
 (define t2 (load-texture "m0.png" (list 'generate-mipmaps 0 'mip-level 0)))
 (load-texture "m1.png" (list 'id t2 'generate-mipmaps 0 'mip-level 1))
 (load-texture "m2.png" (list 'id t2 'generate-mipmaps 0 'mip-level 2))
 (load-texture "m3.png" (list 'id t2 'generate-mipmaps 0 'mip-level 3))


 (texture (load-texture "mytexture.png"
				(list
					'generate-mipmaps 0  ; turn mipmapping off
      		    'border 2)))          ; add a border to the texture
 
 (build-cube) ; the cube will be texture mapped with the image


------------------------------------------------------------

(clear-texture-cache)
Returns void

Clears the texture cache, meaning changed textures on disk are 
reloaded.

 (clear-texture-cache)

------------------------------------------------------------

(frustum top-number bottom-number left-number right-number)
Returns void

Sets the camera frustum, and thus the aspect ratio of the frame.

 (frustum -1 1 -0.75 0.75) ; default settings

------------------------------------------------------------

(clip front-number back-number)
Returns void

Sets the front & back clipping planes for the camera frustum, 
and thus the viewing angle. Change the front clipping distance 
to alter the perspective from telephoto to fisheye.

 (clip 1 10000) ; default settings

------------------------------------------------------------

(ortho)
Returns void

Sets orthographic projection - i.e. no perspective.

 (ortho) 

------------------------------------------------------------

(persp)
Returns void

Sets perspective projection (the default) after ortho has been 
set.

 (persp) 

------------------------------------------------------------

(set-ortho-zoom amount-number)
Returns void

Sets the zoom level for the orthographic projection.

 (set-ortho-zoom 2) 

------------------------------------------------------------

(clear-colour colour-vector)
Returns void

Sets the colour we clear the renderer with, this forms the background 
colour for the scene.

 (clear-colour (vector 1 0 0)) ; RED!!!

------------------------------------------------------------

(clear-frame setting-number)
Returns void

Sets the frame clearing on or off.

 (clear-frame 0) 
 (clear-frame 1)  

------------------------------------------------------------

(clear-zbuffer setting-number)
Returns void

Sets the zbuffer clearing on or off.

 (clear-zbuffer 0) 
 (clear-zbuffer 1)

------------------------------------------------------------

(clear-accum setting-number)
Returns void

Sets the accumulation buffer clearing on or off.

 (clear-accum 1) 

------------------------------------------------------------

(build-camera)
Returns cameraid-number

Adds a new camera/view and returns it's id

 (clear)
 (viewport 0 0.5 0.5 0.5)
 
 (define cam2 (build-camera))
 (current-camera cam2)
 (viewport 0.5 0 0.5 1)
 
 (define cam3 (build-camera))
 (current-camera cam3)
 (set-camera (mmul (mtranslate (vector 0 0 -5))
         (mrotate (vector 0 45 0))))
 (viewport 0 0 0.5 0.5)
 
 ; render a primitive in one view only
 (define t (with-state
     (translate (vector 3 0 0))
     (scale 0.3)
     (colour (vector 1 0 0))
     (build-torus 1 2 10 10)))
 
 (with-primitive t
     (hide 1) ; hide in all
     (camera-hide 0)) ; unhide in current camera
 
 
 (current-camera 0)
 
 (define c (with-state
         (hint-cull-ccw)
         (hint-unlit)
         (hint-wire)
         (line-width 2)
         (colour (vector 0.4 0.3 0.2))
         (wire-colour (vector 0 0 0))
         (scale 10)    
         (build-cube)))
 
 (define p (with-state
         (scale 3)
         (load-primitive "widget.obj")))
 
 (every-frame
     (with-primitive p
         (rotate (vector 0 1 0))))

------------------------------------------------------------

(current-camera cameraid-number)
Returns void

Sets the current camera to use

 (clear)
 (viewport 0 0.5 0.5 0.5)
 
 (define cam2 (build-camera))
 (current-camera cam2)
 (viewport 0.5 0 0.5 1)
 
 (define cam3 (build-camera))
 (current-camera cam3)
 (set-camera (mmul (mtranslate (vector 0 0 -5))
         (mrotate (vector 0 45 0))))
 (viewport 0 0 0.5 0.5)
 
 ; render a primitive in one view only
 (define t (with-state
     (translate (vector 3 0 0))
     (scale 0.3)
     (colour (vector 1 0 0))
     (build-torus 1 2 10 10)))
 
 (with-primitive t
     (hide 1) ; hide in all
     (camera-hide 0)) ; unhide in current camera
 
 
 (current-camera 0)
 
 (define c (with-state
         (hint-cull-ccw)
         (hint-unlit)
         (hint-wire)
         (line-width 2)
         (colour (vector 0.4 0.3 0.2))
         (wire-colour (vector 0 0 0))
         (scale 10)    
         (build-cube)))
 
 (define p (with-state
         (scale 3)
         (load-primitive "widget.obj")))
 
 (every-frame
     (with-primitive p
         (rotate (vector 0 1 0))))

------------------------------------------------------------

(viewport x-number y-number width-number height-number)
Returns void

Sets the viewport on the current camera. This is the area of the 
window the camera renders to, where 0,0 is the bottom left and 
1,1 is the top right.

 (clear)
 (viewport 0 0.5 0.5 0.5)
 
 (define cam2 (build-camera))
 (current-camera cam2)
 (viewport 0.5 0 0.5 1)
 
 (define cam3 (build-camera))
 (current-camera cam3)
 (set-camera (mmul (mtranslate (vector 0 0 -5))
         (mrotate (vector 0 45 0))))
 (viewport 0 0 0.5 0.5)
 
 ; render a primitive in one view only
 (define t (with-state
     (translate (vector 3 0 0))
     (scale 0.3)
     (colour (vector 1 0 0))
     (build-torus 1 2 10 10)))
 
 (with-primitive t
     (hide 1) ; hide in all
     (camera-hide 0)) ; unhide in current camera
 
 
 (current-camera 0)
 
 (define c (with-state
         (hint-cull-ccw)
         (hint-unlit)
         (hint-wire)
         (line-width 2)
         (colour (vector 0.4 0.3 0.2))
         (wire-colour (vector 0 0 0))
         (scale 10)    
         (build-cube)))
 
 (define p (with-state
         (scale 3)
         (load-primitive "widget.obj")))
 
 (every-frame
     (with-primitive p
         (rotate (vector 0 1 0))))

------------------------------------------------------------

(get-camera)
Returns matrix-vector

Gets the current camera transform matrix. This is the low level 
function, use get-camera-transform instead.

 (get-camera) 

------------------------------------------------------------

(get-locked-matrix)
Returns matrix-vector

Gets the current camera lock transform matrix. Takes the lag into 
account

 (get-locked-matrix) 

------------------------------------------------------------

(set-camera)
Returns void

Sets the camera transform matrix. This is the low level interface 
used by set-camera-transform, which you should generally use instead.

 (set-camera (mtranslate (vector 0 0 -10))) 

------------------------------------------------------------

(get-projection-transform)
Returns projection-matrix

Gets the current projection matrix.

 (get-projection-transform) 

------------------------------------------------------------

(get-screen-size)
Returns size-vector

Returns a vector containing the current width and height of the 
window.

 (get-screen-size) 

------------------------------------------------------------

(set-screen-size size-vector)
Returns void

Sets the window width and height.

 (set-screen-size (vector 10 10)) ; small window time :) 
 (set-screen-size (vector 720 576)) ; and back again!

------------------------------------------------------------

(select screenxpos-number screenypos-number pixelssize-number)
Returns primitiveid-number

Looks in the region specified and returns the id of the closest 
primitive to the camera rendered there, or 0 if none exist.

 (display (select 10 10 2))(newline)

------------------------------------------------------------

(desiredfps fps-number)
Returns void

Throttles the renderer so as to not take 100% cpu. This gives 
an upper limit on the fps rate, which doesn't quite match the 
given number, but I'm working on it...

 (desiredfps 100000) ; makes fluxus render as fast as it can, and take 100% cpu.

------------------------------------------------------------

(draw-buffer buffer_name)
Returns void

Select which buffer to draw in for stereo mode you'd do 'back-right 
and 'back-left

 (draw-buffer 'back)

------------------------------------------------------------

(read-buffer buffer_name)
Returns void

Select which buffer to read from

 (read-buffer 'back)

------------------------------------------------------------

(set-stereo-mode mode)
Returns bool

select which stereo mode to use currently only 'crystal-eyes and 
'no-stereo are supported the return indicates if the operation 
was successful or not 'crystal-eyes will return false if you don't 
have a stereo window

 (set-stereo-mode 'crystal-eyes)

------------------------------------------------------------

(set-colour-mask vector)
Returns void

sets the colour mask give it a quat of booleans which correspond 
to the red, green, blue and alpha channels respectively after 
this operation you'll only see those colour which you set to true 
(this is useful for stereo with red-blue glasses)

 (set-colour-mask #(#t #f #f #t))

------------------------------------------------------------

(shadow-light number-setting)
Returns void

Sets the light to use for generating shadows, set to 0 to disable 
shadow rendering.

 (shadow-light 1) 

------------------------------------------------------------

(shadow-length number-setting)
Returns void

Sets the length of the shadow volume rendering.

 (shadow-length 10) 

------------------------------------------------------------

(shadow-debug number-setting)
Returns void

Turns on debug rendering of the shadow volume rendering.

 (shadow-debug 1) 

------------------------------------------------------------

(accum mode-symbol value-number)
Returns void

Controls the accumulation buffer (just calls glAccum under the 
hood). Possible symbols are: accum load return add mult

 (accum 'add 1) 

------------------------------------------------------------

(print-info)
Returns void

Prints out a load of renderer information

 (print-info) 

============================================================

Section: "local-state"

The local state functions control rendering either for the current 
state - or the state of the current primitive. In fluxus state 
means the way that things are displayed, either turning on and 
off rendering features, changing the style of different features, 
or altering the current transform.

------------------------------------------------------------

(push)
Returns void

Pushes a copy of the current drawing state to the top of the stack. 
The drawing state contains information about things like the current 
colour, transformation and hints. This function has been superseded 
by (with-state).

 (colour (vector 1 0 0)) ; set current colour to red
 (push)                  ; copy and push drawing state
 (colour (vector 0 1 0)) ; set current colour to green
 (draw-cube)             ; draws a green cube
 (pop)				   ; forget old drawing state
 ; current colour is now red again

------------------------------------------------------------

(pop)
Returns void

Destroys the current drawing state, and sets the current one to 
be the previously pushed one in the stack. The drawing state contains 
information about things like the current colour, transformation 
and hints. This function has been superseded by (with-state).

 (colour (vector 1 0 0)) ; set current colour to red
 (push)                  ; copy and push drawing state
 (colour (vector 0 1 0)) ; set current colour to green
 (draw-cube)             ; draws a green cube
 (pop)                   ; forget old drawing state
 ; current colour is now red again

------------------------------------------------------------

(grab object-id)
Returns void

Grabs the specified object. Once an object has grabbed it's state 
can be modified using the same commands used to set the current 
drawing state. (ungrab) needs to be used to return to the normal 
drawing state. Grabbing can also be stacked, in which case ungrab 
pops to the last grabbed primitive. This function has been superseded 
by (with-primitive).

 (colour (vector 1 0 0))      ; set the current colour to red
 (define mycube (build-cube)) ; makes a red cube 
 (grab mycube)  				       
 (colour (vector 0 1 0)) ; sets the cubes colour to green 
 (ungrab)				   ; return to normal state

------------------------------------------------------------

(ungrab)
Returns void

Ungrabs the current object, and either returns to the normal drawing 
state, or pops to the last grabbed primitive. This function has 
been superseded by (with-primitive).

 (colour (vector 1 0 0))      ; set the current colour to red
 (define mycube (build-cube)) ; makes a red cube 
 (grab mycube)  				       
 (colour (vector 0 1 0)) ; sets the cubes colour to green 
 (ungrab)				   ; return to normal state

------------------------------------------------------------

(apply-transform optional-object-id)
Returns void

Applies the current object transform to the vertex positions of 
the current object and sets it's transform to identity. Will also 
use the optional id passed in for the aniquated version of this 
command

 (rotate (vector 45 0 0))     
 (define mycube (build-cube)) ; makes a cube with a rotation 
 (with-primitive mycube (apply-transform)) ; applies the rotation to the points of the cube

------------------------------------------------------------

(opacity value)
Returns void

Sets the opacity of the current drawing state, or the current 
primitive.

 (opacity 0.5)
 (define mycube (build-cube)) ; makes a half transparent cube

------------------------------------------------------------

(wire-opacity value)
Returns void

Sets the wireframe opacity of the current drawing state, or the 
current primitive.

 (hint-none)
 (hint-wire)
 (backfacecull 0)
 (line-width 5)
 (wire-colour (vector 1 1 1))
 (wire-opacity 0.5)
 (build-cube) ; makes a half transparent wireframe cube

------------------------------------------------------------

(shinyness value)
Returns void

Sets the shinyness of the current drawing state, or the current 
primitive. This value sets the tightness of the specular highlight.

 (shinyness 100)     
 (specular (vector 1 1 1)) ; sets the specular colour
 (define mysphere (build-sphere 10 10)) ; makes a shiny cube 

------------------------------------------------------------

(colour colour-vector)
Returns void

Sets the colour of the current drawing state, or the current primitive.

 (colour (vector 1 0.5 0.1)) ; mmm orange...
 (define mycube (build-cube)) ; makes an orange cube

------------------------------------------------------------

(colour-mode mode)
Returns void

Changes the way Fluxus interprets colour data for the current 
drawing state, or the current primitive. Colourmode symbols can 
consist of: rgb hsv

 (clear)
 (colour-mode 'hsv)

 (for ((x (in-range 0 10)))
   (translate (vector 1 0 0))
   (colour (vector (/ x 10) 1 1))
   (build-cube))

------------------------------------------------------------

(rgb->hsv colour-vector)
Returns vector

Converts the RGB colour to HSV.

 (rgb->hsv (vector 1 0.5 0.1))

------------------------------------------------------------

(hsv->rgb colour-vector)
Returns vector

Converts the HSV colour to RGB.

 (clear)
 (for* ((x (in-range 0 10))  ; builds a 10x10 HSV colour pattern
        (y (in-range 0 10)))
     (identity)
     (translate (vector x y 0))
     (colour (hsv->rgb (vector (/ x 10) (/ y 10) 1)))
     (build-cube))

------------------------------------------------------------

(wire-colour colour-vector)
Returns void

Sets the wire frame colour of the current drawing state, or the 
current primitive. Visible with (hint-wire) on most primitives.

 (wire-colour (vector 1 1 0)) ; set yellow as current wire colour
 (hint-wire)
 (define mycube (build-cube)) ; makes a cube with yellow wireframe

------------------------------------------------------------

(specular colour-vector)
Returns void

Sets the specular colour of the current drawing state, or the 
current primitive.

 (specular (vector 0 0 1)) ; set blue as specular colour
 (define mysphere (build-sphere 10 10)) ; makes a shiny blue sphere

------------------------------------------------------------

(ambient colour-vector)
Returns void

Sets the ambient colour of the current drawing state, or the current 
primitive.

 (ambient (vector 0 0 1)) ; set blue as ambient colour
 (define mysphere (build-sphere 10 10)) ; makes a boringly blue sphere

------------------------------------------------------------

(opacity value)
Returns void

Sets the emissive colour of the current drawing state, or the 
current primitive.

 (emissive (vector 0 0 1)) ; set blue as emissive colour
 (define mysphere (build-sphere 10 10)) ; makes an bright blue sphere

------------------------------------------------------------

(identity)
Returns void

Sets the drawing state transform to identity, on the state stack, 
or the current primitive.

 (define mycube (with-state
     (scale (vector 2 2 2)) ; set the current scale to double in each dimension
     (build-cube))) ; make a scaled cube 

 (with-primitive mycube
     (identity)) ; erases the transform and puts the cube back to its original state

------------------------------------------------------------

(concat matrix)
Returns void

Concatenates (multiplies) a matrix on to the current drawing state 
or current primitive.

 (define mymatrix (mrotate (vector 0 45 0))) ; make a matrix
 (concat mymatrix) ; concat it into the current state
 (build-cube) ; make a cube with this rotation

------------------------------------------------------------

(translate vector)
Returns void

Applies a translation to the current drawing state transform or 
current primitive.

 (translate (vector 0 1.4 0)) ; translates the current transform up a bit
 (build-cube) ; build a cube with this transform

------------------------------------------------------------

(rotate vector-or-quaternion)
Returns void

Applies a rotation to the current drawing state transform or current 
primitive.

 (rotate (vector 0 45 0)) ; turns 45 degrees in the Y axis
 (build-cube) ; build a cube with this transform

------------------------------------------------------------

(scale vector)
Returns void

Applies a scale to the current drawing state transform or current 
primitive.

 (scale (vector 0.5 0.5 0.5)) ; scales the current transform to half the size
 (build-cube) ; build a cube with this transform

------------------------------------------------------------

(get-transform)
Returns matrix-vector

Returns a matrix representing the current state transform or for 
the current primitive.

 (translate (vector 1 0 0))
 (display (get-transform))(newline) ; prints the current transform
 (define shape (build-sphere 10 10))
 (grab shape)
 (translate (vector 0 1 0))
 (display (get-transform))(newline) ; prints shape's transform
 (ungrab)

------------------------------------------------------------

(parent primitive-id)
Returns void

Parents the current primitive to the supplied parent primitive. 
The current primitive will now be moved around with the parent 
by aquiring all the parent's transforms.

 (define parent-prim (build-cube)) ; make a parent cube
 (translate (vector 2 0 0)) ; move a bit in x
 (parent parent-prim) ; set parent-prim as the current parent
 (define child-prim (build-cube)) ; make a child cube
 (grab parent-prim) 
 (rotate (vector 0 45 0)) ; the child will now be moved by this transform in addition to its own
 (ungrab)

------------------------------------------------------------

(line-width value)
Returns void

Sets the line width (in screen space) of the current drawing state, 
or the current primitive. Affects wireframe and things like that.

 (line-width 5)
 (hint-wire)
 (build-sphere 10 10) ; make a sphere with thick wireframe

------------------------------------------------------------

(point-width value)
Returns void

Sets the point width (in screen space) of the current drawing 
state, or the current primitive. Affects point rendering and particles 
in hardware point mode.

 (point-width 5)
 (hint-points)
 (build-sphere 10 10) ; make a sphere with thick points

------------------------------------------------------------

(blend-mode src dst)
Returns void

Sets the blend mode of the current drawing state, or the current 
primitive. This is the way that alpha is composited to the rendering 
surface. Blendmode symbols can consist of: zero one dst-color 
one-minus-dst-color src-alpha one-minus-src-alpha dst-alpha one-minus-dst-alpha 
Also src-alpha-saturate as an option for the source blendmode 
only.

 ; list out all the possible blendmodes
 
 (define src-blend (vector 'zero 'one 'dst-color 'one-minus-dst-color 'src-alpha
                     'one-minus-src-alpha 'dst-alpha 'one-minus-dst-alpha
                     'src-alpha-saturate))
 
 (define dst-blend (vector 'zero 'one 'dst-color 'one-minus-dst-color 'src-alpha
                     'one-minus-src-alpha 'dst-alpha 'one-minus-dst-alpha))
 
 ; picks a random element
 (define (pick-rnd-item l)
     (vector-ref l (random (vector-length l))))
 
 ; make lots of random spheres
 (define (rnd-sphere n)
     (push)
     (hint-depth-sort)
     (opacity 0.5)
     (colour (vector (flxrnd) (flxrnd) (flxrnd)))
 
     ; set a random blendmode
     (blend-mode (pick-rnd-item src-blend) (pick-rnd-item dst-blend))
 
     (translate (vector (flxrnd) (flxrnd) (flxrnd)))
     (scale (vector 0.1 0.1 0.1))
     (build-sphere 10 10)
     (pop)
     (if (zero? n)
         0
         (rnd-sphere (- n 1))))
 
 (clear)
 (clear-colour (vector 0.5 0.5 0.5))
 (rnd-sphere 100)

------------------------------------------------------------

(hint-solid)
Returns void

Sets the render hints to solid of the current drawing state, or 
the current primitive. Render hints change the way that primitives 
are rendered, but may have different effects - or no effect on 
certain primitive types, hence the name hint.

 (hint-solid) ; this is the default render style so this isn't too exciting
 (build-cube) ; make a solid rendered cube 

------------------------------------------------------------

(hint-wire)
Returns void

Sets the render hints to wireframe of the current drawing state, 
or the current primitive. Render hints change the way that primitives 
are rendered, but may have different effects - or no effect on 
certain primitive types, hence the name hint.

 (hint-wire)
 (build-cube) ; make a wirefame rendered cube 

------------------------------------------------------------

(hint-normal)
Returns void

Sets the render hints to display normals in the current drawing 
state, or the current primitive. Render hints change the way that 
primitives are rendered, but may have different effects - or no 
effect on certain primitive types, hence the name hint.

 (hint-normal)
 (build-cube) ; display the normals on this cube 

------------------------------------------------------------

(hint-points)
Returns void

Sets the render hints to display points in the current drawing 
state, or the current primitive. Render hints change the way that 
primitives are rendered, but may have different effects - or no 
effect on certain primitive types, hence the name hint.

 (hint-points)
 (build-cube) ; display the vertex points on this cube 

------------------------------------------------------------

(hint-anti-alias)
Returns void

Sets the render hints to anti-alias in the current drawing state, 
or the current primitive. Render hints change the way that primitives 
are rendered, but may have different effects - or no effect on 
certain primitive types, hence the name hint.

 (hint-anti-alias)
 (build-cube) ; display a smoothed cube 

------------------------------------------------------------

(hint-unlit)
Returns void

Sets the render hints to unlit in the current drawing state, or 
the current primitive. Render hints change the way that primitives 
are rendered, but may have different effects - or no effect on 
certain primitive types, hence the name hint.

 (hint-unlit)
 (build-cube) ; display an unlit cube

------------------------------------------------------------

(hint-vertcols)
Returns void

Sets the render hints to use vertex colours in the current drawing 
state, or the current primitive. Render hints change the way that 
primitives are rendered, but may have different effects - or no 
effect on certain primitive types, hence the name hint. Vertex 
colours override the current (colour) state.


 (clear)
 (hint-vertcols)
 (define mycube (build-cube)) ; make a cube with vertcols enabled
 
 (with-primitive mycube
     (pdata-map! 
         (lambda (c)
             (rndvec)) ; randomise the vertcols
         "c")) 

------------------------------------------------------------

(hint-box)
Returns void

Sets the render hints to bounding box display in the current drawing 
state, or the current primitive. Render hints change the way that 
primitives are rendered, but may have different effects - or no 
effect on certain primitive types, hence the name hint.

 (hint-box)
 (build-sphere 10 10) ; make a sphere with bounding box displayed

------------------------------------------------------------

(hint-multitex)
Returns void

Sets the render hints to use multitexturing in the current drawing 
state, or the current primitive. Render hints change the way that 
primitives are rendered, but may have different effects - or no 
effect on certain primitive types, hence the name hint.

 (hint-multitex)
 (multitexture 0 (load-texture "tex1.png"))
 (multitexture 1 (load-texture "tex2.png"))
 (build-sphere 10 10) ; make a sphere with overlayed textures

------------------------------------------------------------

(hint-none)
Returns void

Clears the render hints in the current drawing state, or the current 
primitive. This allows you mainly to get rid of the default solid 
style, but also means that you can turn on and off hints without 
using push or pop.

 (hint-none)
 (hint-wire)
 (build-cube) ; make a cube only visible with wireframe

------------------------------------------------------------

(hint-origin)
Returns void

Sets the render hints to display the object space origin of the 
primitive in the current drawing state, or the current primitive. 
Render hints change the way that primitives are rendered, but 
may have different effects - or no effect on certain primitive 
types, hence the name hint.

 (hint-origin)
 (build-sphere 10 10) ; make a sphere with the origin displayed

------------------------------------------------------------

(hint-cast-shadow)
Returns void

(note: Not yet implemented) Sets the render hints to cast shadows 
for the current drawing state, or the current primitive. Render 
hints change the way that primitives are rendered, but may have 
different effects - or no effect on certain primitive types, hence 
the name hint.

 (hint-origin)
 (build-sphere 10 10) ; make a sphere with the origin displayed

------------------------------------------------------------

(hint-depth-sort)
Returns void

Sets the render hints to depth sort for the current drawing state, 
or the current primitive. Render hints change the way that primitives 
are rendered, but may have different effects - or no effect on 
certain primitive types, hence the name hint.

 (hint-depth-sort)
 (build-sphere 10 10) 

------------------------------------------------------------

(hint-ignore-depth)
Returns void

Sets the render hints to ignore depth tests for the current drawing 
state, or the current primitive. Render hints change the way that 
primitives are rendered, but may have different effects - or no 
effect on certain primitive types, hence the name hint. This feature 
is useful for rendering transparent objects, as it means objects 
will be shown behind previously rendered ones.

 (clear)
 (with-state
     (hint-ignore-depth)
     (opacity 0.6)
     (with-state
         (colour (vector 1 0 0))
         (build-cube))
     (with-state
         (colour (vector 0 1 0))
         (translate (vector 1 0 0))
         (build-cube)))

------------------------------------------------------------

(hint-lazy-parent)
Returns void

Sets the render hints to prevent this primitive passing it's transform 
to it's children. Render hints change the way that primitives 
are rendered, but may have different effects - or no effect on 
certain primitive types, hence the name hint.

 (hint-lazy-parent)
 (build-sphere 10 10) ; make a sphere with the origin displayed

------------------------------------------------------------

(hint-cull-ccw)
Returns void

Flips the faces which get backface culled

 (hint-cull-ccw)
 (build-sphere 10 10) ; make an inside out

------------------------------------------------------------

(texture textureid-number)
Returns void

Sets the texture of the current drawing state, or the current 
primitive. Texture ids can be generated by the load-texture function.

 (texture (load-texture "mytexture.png"))
 (build-sphere 10 10) ; make a sphere textured with mytexture.png

------------------------------------------------------------

(multitexture textureunit-number textureid-number)
Returns void

Sets the texture of the current drawing state, or the current 
primitive in the same way as the texture function, but allows 
you to specify the texture unit (0-7) to apply the texture to. 
Multitexturing allows you to apply different textures and texture 
coordinates to the same object at once. Texture unit 0 is the 
default one (which uses the pdata "t" for it's texture coords) 
texture unit n looks for pdata "tn" - ie multitexture 1 looks 
for "t1". You need to add these yourself using (pdata-add) or 
(pdata-copy). Multitexturing is useful when the textures contain 
alpha, as they can be overlayed, i.e. decals placed on background 
textures. Note: fluxus needs to be built using scons MULTITEXTURE=1 
to enable this feature.

 (define obj (build-sphere 10 10)) ; make a sphere 
 (grab obj)
 (multitexture 0 (load-texture "mytextureA.png")) 
 (multitexture 1 (load-texture "mytextureB.png"))
 (pdata-add "t1" "v")   ; make some texture coords for texture B
 (pdata-copy "t" "t1")  ; copy them from the default texture coords
 (ungrab)

------------------------------------------------------------

(print-scene-graph)
Returns void

Prints out the current scene graph, useful for debugging.

 (print-scene-graph) ; exciting...

------------------------------------------------------------

(hide hidden-number)
Returns void

Sets the hidden state for the current primitive (also affects 
all child primitives). Hidden primitives can be treated as normal 
in every way - they just won't be rendered.

 (define obj (build-cube))
 (grab obj)
 (hide 1) ; hide this cube
 (ungrab)

------------------------------------------------------------

(camera-hide hidden-number)
Returns void

Sets the hidden state for the current primitive, with the current 
camera (also affects all child primitives). Allows you to turn 
off rendering for primitives under different cameras

 (define obj (build-cube))
 (with-primitive obj
     (camera-hide 1)) ; hide this cube

------------------------------------------------------------

(selectable selectable-number)
Returns void

Sets whether the current primitive can be selected or not using 
the select command.

 (define obj (build-cube))
 (grab obj)
 (selectable 0) ; now it won't be "seen" by calling select
 (ungrab)

------------------------------------------------------------

(backfacecull setting-number)
Returns void

Turns backface culling on or off. Backface culling speeds up rendering 
by removing faces not orientated towards the camera. Defaults 
to on, but this is not always desired, eg for double sided polygons.

 (backfacecull 0) 

------------------------------------------------------------

(shader vertexprogram-string fragmentprogram-string)
Returns void

Loads, compiles and sets the GLSL harware shader pair for the 
current drawing state, or the current primitive. Requires OpenGL 
2 support. The shader's uniform data can be controlled via shader-set! 
and all the pdata is sent through as per-vertex attribute data 
to the shader.

 ; you need to have built fluxus with GLSL=1
 (clear)
 (fluxus-init) ; this is important to add when using shaders 
               ; at the moment, it will be moved somewhere
               ; to run automatically...
 
 (define s (with-state
     ; assign the shaders to the surface
     (shader "simple.vert.glsl" "simple.frag.glsl")
     (build-sphere 20 20)))
     
 (with-primitive s
     ; add and set the pdata - this is then picked up in the vertex shader 
     ; as an input attribute called "testcol"
     (pdata-add "testcol" "v")
     ; set the testcol pdata with a random colour for every vertex
     (pdata-map! 
         (lambda (c) 
             (rndvec)) 
         "testcol"))
     
 (define (animate)
     (with-primitive s
         ; animate the deformamount uniform input parameter 
         (shader-set! (list "deformamount" (cos (time))))))
 
 (every-frame (animate))

------------------------------------------------------------

(clear-shader-cache)
Returns void

Clears the shader cache

 (clear-shader-cache)

------------------------------------------------------------

(shader-set! argument-list)
Returns void

Sets the uniform shader parameters for the GLSL shader. The list 
consists of token-string value pairs, which relate to the corresponding 
shader parameters names and values.

 ; you need to have built fluxus with GLSL=1
 (clear)
 (fluxus-init) ; this is important to add when using shaders 
               ; at the moment, it will be moved somewhere
               ; to run automatically...
 
 (define s (with-state
     ; assign the shaders to the surface
     (shader "simple.vert.glsl" "simple.frag.glsl")
     (build-sphere 20 20)))
     
 (with-primitive s
     ; add and set the pdata - this is then picked up in the vertex shader 
     ; as an input attribute called "testcol"
     (pdata-add "testcol" "v")
     ; set the testcol pdata with a random colour for every vertex
     (pdata-map! 
         (lambda (c) 
             (rndvec)) 
         "testcol"))
     
 (define (animate)
     (with-primitive s
         ; animate the deformamount uniform input parameter 
         (shader-set! (list "deformamount" (cos (time))))))
 
 (every-frame (animate))

------------------------------------------------------------

(texture-params texture-unit-number parameter-list)
Returns void

Sets the current texture state for the specified texture unit. 
This state controls how the texture is applied to the surface 
of the object, and how it's filtered in texels, or miplevels. 
The texture unit is used if you are using multitexturing - the 
default texture unit is 0. You may need to read up a bit on OpenGL 
or experiment to find out more about these options.

 ; parameters are the following:
 ; tex-env : [modulate decal blend replace]
 ; min : [nearest linear nearest-mipmap-nearest linear-mipmap-nearest linear-mipmap-linear]
 ; mag : [nearest linear]
 ; wrap-s : [clamp repeat]
 ; wrap-t : [clamp repeat]
 ; wrap-r : [clamp repeat] (for cube maps)
 ; border-colour : (vector of length 4)
 ; priority : real number 0 -> 1
 ; env-colour : (vector of length 4)
 ; min-lod : real number (for mipmap blending - default -1000)
 ; max-lod : real number (for mipmap blending - default 1000)
 (clear-texture-cache)

============================================================

Section: "primitive-data"

Primitive data (pdata for short) is fluxus' name for data which 
comprises primitives. In polygon primitives this means the vertex 
information, in particle primitives it corresponds to the particle 
information, in NURBS primitives it's the control vertices. Access 
to pdata gives you the ability to use primitives which are otherwise 
not very interesting, and deform and shape other primitives to 
give much more detailed models and animations. You can also add 
your own pdata, which is treated exactly like the built in types. 
Primitive data is named by type strings, the names of which depend 
on the sort of primitive. All pdata commands operate on the currently 
grabbed primitive.

 ; a function to deform the points of an object
 (define (deform n)
     (pdata-set! "p" n (vadd  (pdata-ref "p" n)                ; the original point, plus
         (vmul (vector (flxrnd) (flxrnd) (flxrnd)) 0.1)))     ; a small random vector
     (if (zero? n)
         0
         (deform (- n 1))))
     
 (hint-unlit) ; set some render settings to
 (hint-wire)  ; make things easier to see
 (line-width 4)
 (define myobj (build-sphere 10 10)) ; make a sphere
 (grab myobj)
 (deform (pdata-size)) ; deform it
 (ungrab)

------------------------------------------------------------

(pdata-ref type-string index-number)
Returns value-vector/colour/matrix/number

Returns the corresponding pdata element.

 (pdata-ref "p" 1)

------------------------------------------------------------

(pdata-set! type-string index-number value-vector/colour/matrix/number)
Returns void

Writes to the corresponding pdata element.

 (pdata-set! "p" 1 (vector 0 100 0))

------------------------------------------------------------

(pdata-add type-string name-string)
Returns void

Adds a new user pdata array. Type is one of "v":vector, "c":colour, 
"f":float or "m":matrix.

 (pdata-add "v" "mydata")
 (pdata-set "mydata" 0 (vector 1 2 3))

------------------------------------------------------------

(pdata-op funcname-string pdataname-string operator)
Returns void

This is an experimental feature allowing you to do operations 
on pdata very quickly, for instance adding element for element 
one array of pdata to another. You can implement this in Scheme 
as a loop over each element, but this is slow as the interpreter 
is doing all the work. It's much faster if you can use a pdata-op 
as the same operation will only be one Scheme call.

 (clear)
 (define t (build-torus 1 4 10 10))
 
 (with-primitive t
     (pdata-op "+" "p" (vector 1 0 0))  ; add a vector to all the pdata vectors
     (pdata-op "+" "p" "n")  ; add two pdata vectors element for element
     (pdata-op "*" "n" (vector -1 -1 -1)) ;  multiply a vector to all the pdata vectors
     (pdata-op "*" "n" "p")  ; multiply two pdata vectors element for element
     (let ((pos (pdata-op "closest" "p" (vector 100 0 0)))) ;  returns position of the closest vertex to this point
         (with-state ; draw a sphere there
             (translate pos)
             (scale (vector 0.1 0.1 0.1))
             (build-sphere 5 5)))
     ; can't think of a good example for these...
     ;(pdata-op "sin" "mydata" "myotherdata")  ; sine of one float pdata to another
     ;(pdata-op "cos" "mydata" "myotherdata")  ; cosine of one float pdata to another
     )
 
 ; most common example of pdata op is for particles
 (define p (with-state
     (hint-points)
     (point-width 10)
     (build-particles 100)))
 
 (with-primitive p
     (pdata-add "vel" "v") ; add a velocity vector
     (pdata-map!
         (lambda (vel)
             (srndvec)) ; set random velocities
         "vel")
     (pdata-map!
         (lambda (c)
             (rndvec)) ; set random colours
         "c"))
 
 (every-frame (with-primitive p
     (pdata-op "+" "p" "vel"))) 

------------------------------------------------------------

(pdata-copy pdatafrom-string pdatato-string)
Returns void

Copies the contents of one pdata array to another. Arrays must 
match types.

 (pdata-copy "p" "mydata") ; copy the vertex positions to a user array

------------------------------------------------------------

(pdata-size)
Returns count-number

Returns the size of the pdata arrays (they must all be the same). 
This is mainly used for iterating over the arrays.

 (define (mashup n)
     (pdata-set "p" n (vector (flxrnd) (flxrnd) (flxrnd))) ; randomise the vertex position
     (if (zero? n)
         0
         (mashup (- n 1)))) ; loops till n is 0

 (define shape (build-sphere 10 10))
 (grab shape)
 (mashup (pdata-size)) ; randomise verts on currently grabbed primitive
 (ungrab)

------------------------------------------------------------

(finalise)
Returns void

Doesn't do anything anymore, I need to remove this :)


------------------------------------------------------------

(recalc-normals smoothornot-number)
Returns void

For polygon primitives only. Looks at the vertex positions and 
calculates the lighting normals for you automatically. Call with 
"1" for smooth normals, "0" for faceted normals.

 (define shape (build-sphere 10 10)) ; build a sphere (which is smooth by default)
 (grab shape)
 (recalc-normals 0) ; make the sphere faceted
 (ungrab)

============================================================

Section: "primitives"

Primitives are objects that you can render. There isn't really 
much else in a fluxus scene, except lights, a camera and lots 
of primitives.



------------------------------------------------------------

(build-cube)
Returns primitiveid-number

A simple cube, texture mapped placement per face.

 (define mynewcube (build-cube))

------------------------------------------------------------

(build-polygons verts-number type-symbol)
Returns primitiveid-number

Builds a raw polygon primitive with size vertices (everything 
is initially set to zero). Type is a symbol that refers to the 
way the vertices are interpreted to build polygons, and can be 
one of the following: triangle-strip quad-list triangle-list triangle-fan 
polygon

 (define mynewshape (build-polygons 100 'triangle-strip))

------------------------------------------------------------

(build-sphere slices-number stacks-number)
Returns primitiveid-number

A sphere with the resolution specified, texture mapped in normal 
"world map" style.

 (define mynewshape (build-sphere 10 10))

------------------------------------------------------------

(build-torus inner-radius-number outer-radius-number slices-number stacks-number)
Returns primitiveid-number

A torus with the resolution specified, control the size and thickness 
of the donut with the inner and outer radius.

 (define mynewshape (build-torus 0.5 1 12 12))

------------------------------------------------------------

(build-plane)
Returns primitiveid-number

A single quad plane, texture mapped from 0->1 in both dimensions.

 (define mynewshape (build-plane))

------------------------------------------------------------

(build-seg-plane vertsx-number vertsy-number)
Returns primitiveid-number

A tesselated poly plane, texture mapped from 0->1 in both dimensions.

 (define mynewshape (build-plane))

------------------------------------------------------------

(build-cylinder hsegments rsegments)
Returns primitiveid-number

A capped cylinder, texture map wrapped around, and badly wrapped 
around the ends.

 (define mynewshape (build-cylinder 10 10))

------------------------------------------------------------

(build-ribbon numpoints-number)
Returns primitiveid-number

Builds a ribbon consisting of numpoints points. The geometry is 
constantly camera facing and is texture mapped so the texture 
is stretched along the ribbon from start to finish. You use the 
pdata functions to edit the postions and widths of the segments. 
If used lit, the normals are faked to approximate a circular cross 
section. Additionally, if solid rendering is cleared with (hint-none) 
and (hint-wire) is activated, a faster constant width line will 
be drawn - width specified by the (line-width) command.

 (define mynewshape (build-ribbon 10))

------------------------------------------------------------

(build-text text-string)
Returns primitiveid-number

Builds a sequence of planes, texture mapped so that a font texture 
can be used to display text. Might also be useful for more abstract 
things. The font assumed to be non proportional - there is an 
example font shipped with fluxus Ok, so this isn't a very good 
font texture :)

 (texture (load-texture "font.png"))
 (define mynewshape (build-text "hello"))

------------------------------------------------------------

(build-nurbs-sphere hsegments rsegments)
Returns primitiveid-number

Builds a tesselated nurbs sphere, texture mapped in the same fashion 
as the poly sphere.

 (define mynewshape (build-nurbs-sphere 10 10))

------------------------------------------------------------

(build-nurbs-plane hsegments rsegments)
Returns primitiveid-number

Builds a tesselated nurbs plane, texture mapped in uv direction.

 (define mynewshape (build-nurbs-plane 10 10))

------------------------------------------------------------

(build-particles count-number)
Returns primitiveid-number

Builds a particles primitive containing num points, all initially 
set to the origin. You use the pdata functions to edit the postions, 
colours and sizes. Particles come in two flavors, camera facing 
sprites, which are the default, can be textured and individually 
scaled; and points (when hint-points is set), which cannot be 
textured but are much faster to render, as they are hardware supported 
gl points. By default these point particles are square, turn on 
hint-anti-alias to make them circular.

 (define mynewshape (build-particles 100))

------------------------------------------------------------

(build-locator)
Returns primitiveid-number

A locator is an empty primitive, useful for parenting to (when 
you don't want to have the parent object visible). This primitive 
can only be visualised with (hint-origin) to display it's local 
transform origin.

 (define mynewshape (build-locator))

------------------------------------------------------------

(load-primitive)
Returns primitiveid-number

Loads a primitive from disk

 (define mynewshape (load-primitive "octopus.obj"))

------------------------------------------------------------

(clear-geometry-cache)
Returns void

Clears cached geometry, so subsequent loads with come from the 
disk.

 (clear-geometry-cache)

------------------------------------------------------------

(save-primitive)
Returns void

Saves the current primitive to disk

 (with-primitive (build-sphere 10 10) 
     (save-primitive "mymesh.obj"))

------------------------------------------------------------

(build-pixels width-number height-number)
Returns primitiveid-number

Makes a new pixel primitive. A pixel primitive is used for making 
procedural textures, which can then be applied to other primitives. 
For this reason, pixel primitives probably wont be rendered much, 
but you can render them to preview the texture on a flat plane.

 (define mynewshape (build-pixels 100 100))
 (with-primitive mynewshape
     (pdata-map!
         (lambda (c)
             (rndvec))
         "c")
     (pixels-upload)) ; call pixels upload to see the results

------------------------------------------------------------

(pixels-upload)
Returns void

Uploads the texture data, you need to call this when you've finished 
writing to the pixelprim, and while it's grabbed.

 (define mynewshape (build-pixels 100 100))
 (with-primitive mynewshape
     (pdata-map!
         (lambda (c)
             (rndvec))
         "c")
     (pixels-upload)) ; call pixels upload to see the results

------------------------------------------------------------

(pixels->texture pixelprimitiveid-number)
Returns textureid-number

Returns a texture you can use exactly like a normal loaded one.

 (define mypixels (build-pixels 100 100))
 (with-primitive mypixels
     (pdata-map!
         (lambda (c)
             (rndvec))
         "c")
     (pixels-upload)) 

 (with-state
     (texture (pixels->texture mypixels))
     (build-torus 1 2 10 10))

------------------------------------------------------------

(pixels-width)
Returns width-number

Returns the width of the current pixel primitive.

 (define mynewshape (build-pixels 100 100))
 (with-primitive mynewshape
     (display (vector (pixels-width) (pixels-height)))(newline))

------------------------------------------------------------

(pixels-height)
Returns width-number

Returns the height of the current pixel primitive.

 (define mynewshape (build-pixels 100 100))
 (with-primitive mynewshape
     (display (vector (pixels-width) (pixels-height)))(newline))

------------------------------------------------------------

(build-blobby numinfluences subdivisionsvec boundingvec)
Returns primitiveid-number

Blobby primitives are a higher level implicit surface representation 
in fluxus which is defined using influences in 3 dimesional space. 
These infuences are then summed together, and a particular value 
is "meshed" (using the marching cubes algorithm) to form a smooth 
surface. The influences can be animated, and the smooth surface 
moves and deforms to adapt, giving the primitive it's blobby name. 
build-blobby returns a new blobby primitive. Numinfluences is 
the number of "blobs". Subdivisions allows you to control the 
resolution of the surface in each dimension, while boundingvec 
sets the bounding area of the primitive in local object space. 
The mesh will not be calculated outside of this area. Influence 
positions and colours need to be set using pdata-set.

 (clear)
 (define b (build-blobby 5 (vector 30 30 30) (vector 1 1 1)))
 
 (with-primitive b
     (shinyness 100)
     (specular (vector 1 1 1))
     (hint-vertcols)
     (pdata-set "p" 0 (vector 0.75 0.25 0.5))
     (pdata-set "c" 0 (vector 0.01 0 0))
     (pdata-set "s" 0 0.01)
     (pdata-set "p" 1 (vector 0.25 0.75 0.5))
     (pdata-set "c" 1 (vector 0 0.01 0))
     (pdata-set "s" 1 0.01)
     (pdata-set "p" 2 (vector 0.75 0.75 0.5))
     (pdata-set "c" 2 (vector 0 0 0.01))
     (pdata-set "s" 2 0.01)
     (pdata-set "p" 3 (vector 0.25 0.25 0.5))
     (pdata-set "c" 3 (vector 0.01 0.01 0))
     (pdata-set "s" 3 0.01)
     (pdata-set "p" 4 (vector 0.5 0.5 0.5))
     (pdata-set "c" 4 (vector 0.01 0.01 0.01))
     (pdata-set "s" 4 0.025))

------------------------------------------------------------

(blobby->poly blobbyprimitiveid-number)
Returns polyprimid-number

Converts the mesh of a blobby primitive into a triangle list polygon 
primitive. This is useful as the polygon primitive will be much 
much faster to render, but can't deform in the blobby way. Doesn't 
convert vertex colours over yet unfortunately.

 (clear)
 (define b (build-blobby 5 (vector 30 30 30) (vector 1 1 1)))
 
 (with-primitive b
     (shinyness 100)
     (specular (vector 1 1 1))
     (hint-vertcols)
     (pdata-set "p" 0 (vector 0.75 0.25 0.5))
     (pdata-set "c" 0 (vector 0.01 0 0))
     (pdata-set "s" 0 0.01)
     (pdata-set "p" 1 (vector 0.25 0.75 0.5))
     (pdata-set "c" 1 (vector 0 0.01 0))
     (pdata-set "s" 1 0.01)
     (pdata-set "p" 2 (vector 0.75 0.75 0.5))
     (pdata-set "c" 2 (vector 0 0 0.01))
     (pdata-set "s" 2 0.01)
     (pdata-set "p" 3 (vector 0.25 0.25 0.5))
     (pdata-set "c" 3 (vector 0.01 0.01 0))
     (pdata-set "s" 3 0.01)
     (pdata-set "p" 4 (vector 0.5 0.5 0.5))
     (pdata-set "c" 4 (vector 0.01 0.01 0.01))
     (pdata-set "s" 4 0.025))
 
 (define p (with-state
     (translate (vector 1 0 0))
     (blobby->poly b)))

------------------------------------------------------------

(draw-instance primitiveid-number)
Returns void

Copies a retained mode primitive and draws it in the current state 
as an immediate mode primitive.

 (define mynewshape (build-cube))
 (colour (vector 1 0 0))
 (draw-instance mynewshape) ; draws a copy of mynewshape

------------------------------------------------------------

(draw-cube)
Returns void

Draws a cube in the current state in immediate mode primitive.

 (define (render)
     (draw-cube))
 (every-frame (render))

------------------------------------------------------------

(draw-plane)
Returns void

Draws a plane in the current state in immediate mode primitive.

 (define (render)
     (draw-plane))
 (every-frame (render))

------------------------------------------------------------

(draw-sphere)
Returns void

Draws a sphere in the current state in immediate mode primitive.

 (define (render)
     (draw-sphere))
 (every-frame (render))

------------------------------------------------------------

(draw-cylinder)
Returns void

Draws a cylinder in the current state in immediate mode primitive.

 (define (render)
     (draw-cylinder))
 (every-frame (render))

------------------------------------------------------------

(draw-torus)
Returns void

Draws a torus in the current state in immediate mode primitive.

 (define (render)
     (draw-torus))
 (every-frame (render))

------------------------------------------------------------

(destroy primitiveid-number)
Returns void

Deletes a built primitive from the renderer. primitive.

 (define mynewshape (build-sphere 10 10))
 (destroy mynewshape)

------------------------------------------------------------

(poly-indices)
Returns void

Gets the vertex indices from this primitive primitive.


------------------------------------------------------------

(poly-type-enum)
Returns void

Returns the enum value representing the type of the current polygon 
primitive. This is needed as I can't get my scheme scripts to 
recognise symbols returned from here. Use (poly-type) instead 
of this directly. primitive.


------------------------------------------------------------

(poly-indexed?)
Returns void

Returns true if the current polygon primitive is in indexed mode. 
primitive.

 (define p (build-polygons 3 'triangle-strip))
 (with-primitive p
     (poly-convert-to-indexed)
     (display (poly-indexed?))(newline))

------------------------------------------------------------

(poly-set-index index-list)
Returns void

Switches the primitive to indexed mode, and uses the list as the 
index values for this primitive. primitive.

 (clear)
 ; lets build our own cube primitive...
 (define p (build-polygons 8 'quad-list))
 
 (with-primitive p
     ; setup the vertex data
     (pdata-set "p" 0 (vector -1 -1 -1))
     (pdata-set "p" 1 (vector  1 -1 -1))
     (pdata-set "p" 2 (vector  1 -1  1))
     (pdata-set "p" 3 (vector -1 -1  1))
     (pdata-set "p" 4 (vector -1  1 -1))
     (pdata-set "p" 5 (vector  1  1 -1))
     (pdata-set "p" 6 (vector  1  1  1))
     (pdata-set "p" 7 (vector -1  1  1))
     (pdata-set "c" 0 (vector  0  0  0))
     (pdata-set "c" 1 (vector  0  0  1))
     (pdata-set "c" 2 (vector  0  1  0))
     (pdata-set "c" 3 (vector  0  1  1))
     (pdata-set "c" 4 (vector  1  0  0))
     (pdata-set "c" 5 (vector  1  0  1))
     (pdata-set "c" 6 (vector  1  1  0))
     (pdata-set "c" 7 (vector  1  1  1))
     
     (hint-wire)
     (hint-unlit)
     (hint-vertcols)
     
     ; connect the verts together into faces
     (poly-set-index (list 7 6 5 4  5 6 2 1 
             4 5 1 0  1 2 3 0
             3 7 4 0  6 7 3 2)))

------------------------------------------------------------

(poly-convert-to-indexed)
Returns void

Converts the currently grabbed polygon primitive from raw vertex 
arrays to indexed arrays. This removes duplicate vertices from 
the polygon, making the pdata arrays shorter, which speeds up 
processing time.

 (define mynewshape (build-sphere 10 10))
 (grab mynewshape)
 (poly-convert-to-indexed)
 (ungrab)

------------------------------------------------------------

(build-copy src-primitive-number)
Returns primitiveid-number

Returns a copy of a primitive

 (define mynewshape (build-sphere 10 10))
 (define myothernewshape (build-copy mynewshape))

------------------------------------------------------------

(make-pfunc name-string)
Returns pfuncid-number

Makes a new primitive function. pfuncs range from general purpose 
to complex and specialised operations which you can run on primitives. 
All pfuncs share the same interface for controlling and setting 
them up - pfunc-set! All pfunc types and arguments are as follows: 
arithmetic For applying general arithmetic to any pdata array 
operator string : one of add sub mul div src string : pdata array 
name other string : pdata array name (optional) constant float 
: constant value (optional) dst string : pdata array name genskinweights 
Generates skinweights - adds float pdata called "s1" -> "sn" where 
n is the number of nodes in the skeleton - 1 skeleton-root primid-number 
: the root of the bindpose skeleton for skinning sharpness float 
: a control of how sharp the creasing will be when skinned skinweights->vertcols 
A utility for visualising skinweights for debugging. no arguments 
skinning Skins a primitive - deforms it to follow a skeleton's 
movements. Primitives we want to run this on have to contain extra 
pdata - copies of the starting vert positions called "pref" and 
the same for normals, if normals are being skinned, called "nref". 
skeleton-root primid-number : the root primitive of the animating 
skeleton bindpose-root primid-number : the root primitive of the 
bindpose skeleton skin-normals number : whether to skin the normals 
as well as the positions

 (define mypfunc (make-pfunc 'arithmetic))

------------------------------------------------------------

(pfunc-set! pfuncid-number argument-list)
Returns void

Sets arguments on a primitive function. See docs for make-pfunc 
for all the arguments.

 (define mypfunc (make-pfunc 'arithmetic))
 (pfunc-set! mypfunc (list 'operator "add"
                           'src "p"
                           'const 0.4
                           'dst "p"))

------------------------------------------------------------

(pfunc-run id-number)
Returns void

Runs a primitive function on the currently grabbed primitive.

 (define mypfunc (make-pfunc 'arithmetic))

------------------------------------------------------------

(line-intersect start-vec end-vec)
Returns void

Returns a list of pdata values at each intersection point of the 
specified line.

 (clear)
 (define s (with-state
         (build-torus 1 2 10 10)))
 
 (define l (with-state
         (hint-none)
         (hint-unlit)
         (hint-wire)
         (build-line 2)))
 
 (define (check a b)
     (with-primitive s
         (for-each
             (lambda (intersection)                    
                 (with-state ; draw a sphere at the intersection point
                     (translate (cdr (assoc "p" intersection)))
                     (colour (vector 0 1 0))
                     (scale (vector 0.3 0.3 0.3))
                     (draw-sphere)))
         (line-intersect a b))))
 
 (every-frame
     (with-primitive l
         (pdata-set "p" 0 (vector 0 -5 0))
         (pdata-set "p" 1 (vector (* 5 (sin (time))) 5 0))
         (check (pdata-ref "p" 0) (pdata-ref "p" 1))))

============================================================

Section: "util-functions"

Handy functions to make your life easier...

------------------------------------------------------------

(time)
Returns time-number

Returns the number of seconds (+ fraction) since midnight January 
1st 1970. This is the simpest animation source for your scripts.

 (define (animate)
     (rotate (vector (sin (time)) 0 0))
     (draw-cube))
 (every-frame (animate))    

------------------------------------------------------------

(delta)
Returns time-number

Time in seconds since the last frame. Used to make animation frame 
rate independant.

 (define (animate)
     (rotate (vector (* (delta) 10) 0 0))
     (draw-cube))
 (every-frame (animate))    

------------------------------------------------------------

(flxrnd)
Returns random-number

Returns a random number between 0 and 1.

 (define (animate)
     (colour (vector (flxrnd) (flxrnd) (flxrnd)))
     (draw-cube))
 (every-frame (animate))

------------------------------------------------------------

(flxseed seed-number)
Returns void

Seeds the random number generator so we can get the same sequence.

 (define (animate)
     (colour (vector (flxrnd) (flxrnd) (flxrnd)))
     (draw-cube))
 (flxseed 10) 
 (every-frame (animate)) ; the same sequence of colours will be generated

------------------------------------------------------------

(set-searchpathss paths-list)
Returns void

Sets a list of search path strings to use for looking for fluxus 
related files, such as textures, shaders etc. Paths will be searched 
in order each time, and need trailing slashes.

 (set-searchpaths (append (get-searchpaths) (list "/path/to/my/textures/" "/path/to/my/other/textures/")))

------------------------------------------------------------

(get-searchpaths paths-list)
Returns void

Gets the list of search path strings to use for looking for fluxus 
related files, such as textures, shaders etc. Paths will be searched 
in order each time.

 (display (get-searchpaths))(newline)

------------------------------------------------------------

(fullpath filename-string)
Returns fullpath-string

Searches the search paths for the specified file and returns the 
first location it finds.

 (fullpath "myfile")

------------------------------------------------------------

(framedump filename)
Returns void

Saves out the current OpenGL front buffer to disk. Reads the filename 
extension to decide on the format used for saving, "tif", "jpg" 
or "ppm" are supported. This is the low level form of the frame 
dumping, use start-framedump and end-framedump instead.

 (framedump "picture.jpg")

============================================================

Section: "midi"

MIDI stands for Musical Instrument Digital Interface, and it enables 
electronic musical instruments, computers, and other equipment 
to communicate, control, and synchronize with each other. Fluxus 
can receive MIDI control change and note messages.

 (display (midi-info))(newline)

 (midi-init 1)

 (define (midi-test)
     (with-state
         (scale (vector (+ 1 (midi-ccn 0 1))
                        (+ 1 (midi-ccn 0 2))
                        (+ 1 (midi-ccn 0 3))))
         (draw-cube)))

 (every-frame (midi-test))

------------------------------------------------------------

(midi-info)
Returns a list of (midi-port-number . midi-port-name-string) pairs

Returns information about the available MIDI input ports.

 (midi-info)

------------------------------------------------------------

(midi-init port-number)
Returns void

Opens the specified MIDI input port.

 (midi-init 1)

------------------------------------------------------------

(midi-cc channel-number controller-number)
Returns controller-value-number

Returns the controller value.

 (midi-cc 0 1)

------------------------------------------------------------

(midi-ccn channel-number controller-number)
Returns controller-value-number

Returns the controller value normalised to the (0, 1) interval.

 (midi-ccn 0 1)

------------------------------------------------------------

(midi-note)
Returns #(on-off-symbol channel note velocity) or #f

Returns the next event from the MIDI note event queue or #f if 
the queue is empty.

 (midi-note)

------------------------------------------------------------

(midi-peek)
Returns msg-string

Returns the name, and event type, and parameter bytes of the last 
MIDI event as a string for debugging purposes.

 (display (midi-peek))(newline)

============================================================

Section: "scheme-utils"

High level fluxus commands written in Scheme.

------------------------------------------------------------

(pixels-circle pos radius colour)
Returns void

Draws a circle into a pixels primitive

 
 (with-primitive (build-pixels 100 100)
     (pixels-circle (vector 50 50 0) 30 (vector 1 0 0 1))
     (pixels-upload))

------------------------------------------------------------

(pixels-blend-circle pos radius colour)
Returns void

Draws a blended circle into a pixels primitive


 (with-primitive (build-pixels 100 100)
     (pixels-blend-circle (vector 50 50 0) 30 (vector 1 0 0 1))
     (pixels-upload))

------------------------------------------------------------

(pixels-dodge pos radius strength)
Returns void

Lightens a circular area of a pixels primitive


 (with-primitive (build-pixels 100 100)
     (pixels-dodge (vector 50 50 0) 30 (vector 1 0 0 1))
     (pixels-upload))

------------------------------------------------------------

(pixels-burn pos radius strength)
Returns void

Darkens a circular area of a pixels primitive


 (with-primitive (build-pixels 100 100)
     (pixels-burn (vector 50 50 0) 30 (vector 1 0 0 1))
     (pixels-upload))

------------------------------------------------------------

(pixels-clear col)
Returns void

Sets all of the pixels to the supplied colour


 (with-primitive (build-pixels 100 100)
     (pixels-clear (vector 1 0 0))
     (pixels-upload))

------------------------------------------------------------

(with-state expression ...)
Returns result of last expression

Encapsulates local state changes, and removes the need for push 
and pop.

 ; state hierachy, by nesting with-state:
 (with-state
    (hint-vertcols)
    (colour (vector 0 0 1))
    (with-state
        (translate (vector 1 0 0))
        (build-sphere 10 10))
     (build-torus 1 2 30 30))

 ; making primitives:
 (define my-torus (with-state
    (hint-vertcols)
    (colour (vector 0 0 1))
    (build-torus 1 2 30 30)))

------------------------------------------------------------

(with-primitive primitive expression ...)
Returns result of last expression

Encapsulates primitive state changes, and removes the need for 
grab and ungrab.

 
 (define my-torus (with-state
    (colour (vector 0 0 1))
    (build-torus 1 2 30 30)))

 ; change the torus colour: 
 (with-primitive my-torus
    (colour (vector 0 1 0)))

------------------------------------------------------------

(pdata-map! procedure read/write-pdata-name read-pdata-name ...)
Returns void

A high level control structure for simplifying passing over pdata 
arrays for primitive deformation. Should be easier and less error 
prone than looping manually. Writes to the first pdata array.

 (clear)
 (define my-torus (build-torus 1 2 30 30))
 
 (with-primitive my-torus
   (pdata-map!
      (lambda (position)
          (vadd position (vector (flxrnd) 0 0))) ; jitter the vertex in x
      "p")) ; read/write the position pdata array
 
 (with-primitive my-torus
   (pdata-map!
      (lambda (position normal)
          (vadd position normal)) ; add the normal to the position (expand the object)
      "p" "n")) ; read/write the position pdata array, read the normals array

------------------------------------------------------------

(pdata-index-map! procedure read/write-pdata-name read-pdata-name ...)
Returns void

A high level control structure for simplifying passing over pdata 
arrays for primitive deformation. Same as pdata-map! except pdata-index-map! 
supplies the index of the current pdata element as the first argument 
to 'procedure'.

 (clear)
 (define my-torus (build-torus 1 2 30 30))
 
 (with-primitive my-torus
   (pdata-index-map!
      (lambda (index position)
          (vadd position (vector (gh index) 0 0))) ; jitter the vertex in x
      "p")) ; read/write the position pdata array

------------------------------------------------------------

(pdata-fold procedure start-value read-pdata-name ...)
Returns result of folding procedure over pdata array

A high level control structure for doing calculations on pdata 
arrays. Runs the procedure over each pdata element accumulating 
the result. Should be easier and less error prone than looping 
manually.

 
 (define my-torus (build-torus 1 2 30 30))
 
 ; find the centre of the primitive by averaging 
 ; the points position's together
 (let ((centre 
        (with-primitive my-torus
                        (vdiv (pdata-fold
                               vadd
                               (vector 0 0 0)
                               "p") (pdata-size)))))
   
   (display centre)(newline))

------------------------------------------------------------

(pdata-index-fold procedure start-value read-pdata-name ...)
Returns result of folding procedure over pdata array

Same as pdata-fold except it passes the index of the current pdata 
element as the first parameter of 'procedure'.

 
 (define my-torus (build-torus 1 2 30 30))
 
 ; can't think of a good example for this yet...
 (let ((something 
        (with-primitive my-torus
                        (vdiv (pdata-index-fold
                               (lambda (index position ret)
                                   (vadd ret (vmul position index)))
                               (vector 0 0 0)
                               "p") (pdata-size)))))
   
   (display something)(newline))

------------------------------------------------------------

(collada-import filename-string)
Returns void

Loads a collada scene file and returns a scene description list. 
Files need to contain triangulated model data - this is usually 
an option on the export. Note: this is slow for heavy models

 ;(collada-import "test.dae")

------------------------------------------------------------

(rndf)
Returns number

Returns a random number in the range 0->1

 (display (rndf))(newline)

------------------------------------------------------------

(crndf)
Returns number

Returns a random number in the range -1->1 (centred on zero)

 (display (crndf))(newline)

------------------------------------------------------------

(rndvec)
Returns vector

Returns a random 3 element vector with each element in the range 
0->1. If you visualise a lot of these as points, they will fill 
the unit cube (see the example).

 (clear)
 (hint-none)
 (hint-points)
 (point-width 4)
 (define p (build-particles 1000))
 
 (show-axis 1)
 
 (with-primitive p
     (pdata-map! 
         (lambda (p)
             (vector 1 1 1))
         "c")
     (pdata-map! 
         (lambda (p)
             (rndvec))
         "p"))

------------------------------------------------------------

(crndvec)
Returns vector

Returns a random 3 element vector with each element in the range 
-1->1. If you visualise a lot of these as points, they will fill 
a cube centred on the origin (see the example).

 (clear)
 (hint-none)
 (hint-points)
 (point-width 4)
 (define p (build-particles 1000))
 
 (show-axis 1)
 
 (with-primitive p
     (pdata-map! 
         (lambda (p)
             (vector 1 1 1))
         "c")
     (pdata-map! 
         (lambda (p)
             (crndvec))
         "p"))

------------------------------------------------------------

(srndvec)
Returns vector

Returns a random 3 element vector. If you visualise a lot of these 
as points, they will fill a sphere centred on the origin (see 
the example).

 (clear)
 (hint-none)
 (hint-points)
 (point-width 4)
 (define p (build-particles 1000))
 
 (show-axis 1)
 
 (with-primitive p
     (pdata-map! 
         (lambda (p)
             (vector 1 1 1))
         "c")
     (pdata-map! 
         (lambda (p)
             (srndvec))
         "p"))

------------------------------------------------------------

(hsrndvec)
Returns vector

Returns a random 3 element vector. If you visualise a lot of these 
as points, they will cover the surface of a sphere centred on 
the origin (see the example). The name stands for "hollow sphere".

 (clear)
 (hint-none)
 (hint-points)
 (point-width 4)
 (define p (build-particles 1000))
 
 (show-axis 1)
 
 (with-primitive p
     (pdata-map! 
         (lambda (p)
             (vector 1 1 1))
         "c")
     (pdata-map! 
         (lambda (p)
             (hsrndvec))
         "p"))

------------------------------------------------------------

(grndf)
Returns number

Returns a gaussian random number in the range -1->1 (centred on 
zero)

 (display (grndf))(newline)

------------------------------------------------------------

(grndvec)
Returns vector

Returns a gaussian random 3 element vector. If you visualise a 
lot of these as points, you will see a normal distribution centred 
on the origin. (see the example).

 (clear)
 (hint-none)
 (hint-points)
 (point-width 4)
 (define p (build-particles 1000))
 
 (show-axis 1)
 
 (with-primitive p
     (pdata-map! 
         (lambda (p)
             (vector 1 1 1))
         "c")
     (pdata-map! 
         (lambda (p)
             (grndvec))
         "p"))

------------------------------------------------------------

(rndbary)
Returns vector

Returns a vector representing a uniformly distributed triangular 
barycentric coordinate (wip - doesn't seem to be very uniform 
to me...)

 (rndbary)

------------------------------------------------------------

(rndbary normal)
Returns vector

Returns a vector representing a random point on a hemisphere, 
defined by normal.

 (clear)
 (hint-none)
 (hint-points)
 (point-width 4)
 (define p (build-particles 1000))
 
 (show-axis 1)
 
 (with-primitive p
     (pdata-map! 
         (lambda (p)
             (vector 1 1 1))
         "c")
     (pdata-map! 
         (lambda (p)
             (rndhemi (vector 0 1 0)))
         "p"))

------------------------------------------------------------

(hrndbary normal)
Returns vector

Returns a vector representing a random point on a hollow hemisphere, 
defined by normal.

 (clear)
 (hint-none)
 (hint-points)
 (point-width 4)
 (define p (build-particles 1000))
 
 (show-axis 1)
 
 (with-primitive p
     (pdata-map! 
         (lambda (p)
             (vector 1 1 1))
         "c")
     (pdata-map! 
         (lambda (p)
             (hrndhemi (vector 0 1 0)))
         "p"))

------------------------------------------------------------

(pdata-for-each-tri-sample proc samples-per-triangle)
Returns void

Calls proc with the triangle indices and a random barycentric 
coord.

 

------------------------------------------------------------

(pdata-for-each-tri-sample proc samples-per-triangle)
Returns void

Calls proc with the triangle indices and a random barycentric 
coord.

 

------------------------------------------------------------

(occlusion-texture-bake tex prim samples-per-face rays-per-sample ray-length debug)
Returns void

Bakes ambient occlusion textures. See ambient-occlusion.scm for 
more info.

 

------------------------------------------------------------

(vmix a b t)
Returns void

Linearly interpolates the two vectors together by t

 
 ; mix red and blue together
 (colour (vmix (vector 1 0 0) (vector 0 0 1) 0.5))

------------------------------------------------------------

(vclamp a)
Returns void

Clamp the vector so the elements are all between 0 and 1

 
 ; make a valid colour from any old vector
 (colour (vclamp (vector 2 400 -123)))

------------------------------------------------------------

(vsquash a)
Returns void

Clamp the vector so the elements are all between 0 and 1

 
 ; make a valid colour from any old vector
 (colour (vclamp (vector 2 400 -123)))

------------------------------------------------------------

(poly-type)
Returns void

Returns a symbol representing the type of the current polygon 
primitive. primitive.

 (define p (build-polygons 3 'triangle-strip))
 (with-primitive p
     (display (poly-type))(newline))

------------------------------------------------------------

(pdata-for-each-face proc pdatanames)
Returns list of pdata values

Calls proc with the indices for each face in a polygon primitive

 

------------------------------------------------------------

(pdata-for-each-triangle proc)
Returns list of pdata values

Calls proc with the pdata for each triangle in a face - assumes 
all faces are convex.

 

------------------------------------------------------------

(pdata-for-each-tri-sample proc samples-per-triangle)
Returns void

Calls proc with the triangle indices and a random barycentric 
coord.

 

============================================================

Section: "scratchpad"

Functions available as part of the fluxus scratchpad.

------------------------------------------------------------

(reset-camera)
Returns void

Resets the camera transform, useful if it becomes trashed, or 
you get lost somewhere in space. Also turns off camera locking 
to objects with (lock-camera)

 ; ruin the camera transform
 (set-camera-transform (vector 123 41832 28 0.2 128 0.001 123 41832 28 0.2 128 0.001 0.2 100 13 1931)) 
 ; set it back to the starting position/orientation
 (reset-camera) 

------------------------------------------------------------

(set-camera-transform transform-matrix)
Returns void

Overrides and locks the camera transform with your own. To unlock 
again call reset-camera

 (set-camera-transform (mtranslate (vector 0 0 -10)))

------------------------------------------------------------

(get-camera-transform)
Returns transform-matrix

Returns the current camera transform. To unlock again call reset-camera

 (define tx (get-camera-transform))

------------------------------------------------------------

(set-help-locale! locale-string)
Returns void

Sets the language for the documentation

 (set-help-locale! "pt") ; switch to portuguese
 (set-help-locale! "en") ; and back to english

------------------------------------------------------------

(help function-string)
Returns void

Displays help information on a fluxus function. For running in 
the repl mainly.

 (help "pop") 

------------------------------------------------------------

(key-pressed key-string)
Returns boolean

Returns true if the specified key is currently pressed down.

 (when (key-pressed "q") (display "q pressed!"))

------------------------------------------------------------

(keys-down)
Returns keys-list

Returns a list of keys pressed down

 (display (keys-down))(newline)

------------------------------------------------------------

(key-special-pressed key-number)
Returns boolean

Returns true if the specified special key is currently pressed 
down. Special keys are ones which do not map to ascii values. 
The easiest way of finding what they are is to print out the result 
of key-special-pressed while holding down the key you are after.


 (when (key-special-pressed 100) (display "left cursor pressed"))
 (when (key-special-pressed 102) (display "right cursor pressed"))
 (when (key-special-pressed 101) (display "up cursor pressed"))
 (when (key-special-pressed 103) (display "down cursor pressed"))

------------------------------------------------------------

(keys-special-down)
Returns keys-list

Returns a list of special keys pressed down

 (display (keys-special-down))

------------------------------------------------------------

(mouse-x)
Returns coord-number

Returns the x position of the mouse

 (display (mouse-x))

------------------------------------------------------------

(mouse-y)
Returns coord-number

Returns the y position of the mouse

 (display (mouse-y))

------------------------------------------------------------

(mouse-button)
Returns boolean

Returns true if the specifed mouse button is pressed

 (display (mouse-button 1))

------------------------------------------------------------

(mouse-over)
Returns primitiveid-number

Returns the object the mouse is currently over.

 (grab (mouse-over))
 (colour (vector 1 0 0)) ; paints objects the mouse is over red
 (ungrab)

------------------------------------------------------------

(every-frame callback-function)
Returns void

Sets a function to be called every time the render is about to 
draw a new frame.

 (define (myfunc)
     (colour (rndvec))
     (draw-torus))

 (every-frame (myfunc)) 

------------------------------------------------------------

(clear)
Returns void

Clears out the renderer of all objects and lights. Clears the 
physics system and resets the every-frame callback. Generally 
a Good Thing to put this at the beginning of scripts to make sure 
everything is cleared out each time you execute.

 (clear) ; without this we would accumulate a new cube every time F5 was pressed
 (build-cube) 

------------------------------------------------------------

(start-framedump name-string type-string)
Returns void

Starts saving frames to disk. Type can be one of "tif", "jpg" 
or "ppm". Filenames are built with the frame number added, padded 
to 5 zeros.

 (start-framedump "frame" "jpg") 

------------------------------------------------------------

(end-framedump)
Returns void

Stops saving frames to disk.

 (end-framedump) 

------------------------------------------------------------

(set-physics-debug boolean)
Returns void

Call with #t to turn on debug rendering for the physics.

 (set-physics-debug #t) 

------------------------------------------------------------

(override-frame-callback callback-function)
Returns void

Allows you to override the frame callback, to control the rendering 
loop of fluxus in a more detailed way.

 (override-frame-callback myfunc) 
 (override-frame-callback default-fluxus-frame-callback) ; set it back again...

------------------------------------------------------------

(set-auto-indent-tab size-number)
Returns void

Sets the tabs size for the prettification auto indent on ctrl-p. 
Defaults to 2.

 (set-auto-indent-tab 2)

------------------------------------------------------------

(set-camera-update #t/#f)
Returns void

Turns off camera update - allowing you to use (set-camera) - otherwise 
it gets written over by the mouse camera update. The reason for 
needing this is that (set-camera-transform) doesn't work with 
multiple cameras - need to fix.

 (set-camera-update #f)
 (set-camera-update #t)

============================================================

Section: "high-level-scratchpad-docs"

Some useful high level documentation lives here, this won't make 
much sense if you are reading this in a different place from the 
help system in the fluxus scratchpad app, but it might be useful 
anyway...

------------------------------------------------------------

(tophelp)


 Fluxus documentation
 --------------------
 "act of a flowing; a continuous moving on or passing by, as of a 
 flowing stream; a continuous succession of changes"

 Fluxus is a realtime rendering engine for livecoding in Scheme. 
 For more detailed docs, see: fluxus/docs/fluxus-documentation.txt

 The fluxus scratchpad has two modes of operation, the console
 (you are using this now) which allows you to enter commands and
 see the results immediately. The other mode is the editor which 
 is more like a normal text editor - there are 9 workspaces,
 (which allow you to edit more than one script at once) switch to 
 them using ctrl-1 to ctrl-9 and switch back to the console with 
 ctrl-0.

 To copy/paste examples, hit the right cursor until you move behind
 the prompt, navigate to the example, use shift to select it,
 press ctrl-c to copy, then ctrl-0 and ctrl-v to paste into a 
 text buffer.

 More help topics:
 (help "keys") for keyboard commands for controlling fluxus 
 (help "console") for more help on the console 
 (help "editor") for more help on the livecoding editor
 (help "camera") for help on the camera controls 
 (help "language") for more info on the fluxus commands
 (help "misc") for miscellaneous fluxus info 
 (help "toplap") for the toplap manefesto
 (help "authors") who made this?

------------------------------------------------------------

(keys)


 Fluxus keys
 -----------

 ctrl-f : Fullscreen mode.
 ctrl-w : Windowed mode.
 ctrl-h : Hide/show the text.
 ctrl-l : Load a new script (navigate with cursors and return).
 ctrl-s : Save current script.
 ctrl-d : Save as - current script (opens a filename dialog).
 ctrl-p : Auto format the whitespace in your scheme script to be more pretty
 ctrl-1 to 9 : Switch to selected workspace.
 ctrl-0 : Switch to the REPL.
 F3 : Resets the camera if you get lost.
 F5 : (or ctrl-e) Executethe selected text, or all if none is selected.
 F6 : Completely resets the interpreter, then executes the selected text, 
      or all if none is selected.
 F9 : Randomise the text colour (aka the panic button)
 F10 : Decreases the text opacity
 F11 : Increases the text opacity

------------------------------------------------------------

(console)


 Fluxus console (or REPL)
 ------------------------

 If you press ctrl and 0, instead of getting another script 
 workspace, you will be presented with a Read EvaluatePrint
 Loop interpreter, or repl for short. This is really just an 
 interactive interpreter similar to the commandline, where 
 you can enter scheme code for immediate evaluation. This code 
 is evaluated in the same interpreter as the other scripts, so
 you can use the repl to debug or inspect global variables and 
 functions they define. This window is also where error 
 reporting is printed, along with the terminal window you 
 started fluxus from.

------------------------------------------------------------

(editor)


 Fluxus editor 
 -------------

 When using the fluxus scratchpad, the idea is that you only 
 need the one window to build scripts, or play live. f5 is the 
 key that runs the script when you are ready.  Selecting some 
 text (using shift) and pressing f5 will execute the selected 
 text only. This is handy for reevaluating functions without 
 running the whole script each time.

 Workspaces
 ----------

 The script editor allows you to edit 9 scripts simultaneously 
 by using workspaces. To switch workspaces, use ctrl+number 
 key. Only one can be run at once though, hitting f5 will 
 execute the currently active workspace script. 
 
 Auto focus
 ----------

 The editor includes an auto scaling/centering feature which is
 enabled by default. To disable it - add the line:
 (set! fluxus-scratchpad-do-autofocus 0)
 to your .fluxus.scm file - or create a new file called that in 
 your home directory, containing that line.

------------------------------------------------------------

(camera)


 Fluxus camera control
 ---------------------

 The camera is controlled by moving the mouse and pressing 
 mouse buttons.

 Left mouse button: Rotate
 Middle mouse button: Move
 Right mouse button: Zoom

------------------------------------------------------------

(misc)


 Fluxus init script
 ------------------
 Fluxus looks for a script in your home directory called
 .fluxus.scm which it will run if it is found. This is useful
 for putting init commands (like connecting to jack or setting
 the help text language etc)

 Frame rate throttling
 ---------------------
 By default fluxus throttles the framerate to around 40fps.
 to disable this (and run at 100% cpu), use desiredfps with
 some arbitrary large number:
 (desiredfps 100000000)
 To display the fps use (show-fps 1)

 Command line options
 ---------------------
 The easiest way to load a script into fluxus is to specify it on 
 the command line, eg:
 $ fluxus myscript.scm
 Will launch fluxus and load the script into the editor.
 $ fluxus -x myscript.scm
 Will launch fluxus, load, hide and execute the script.
 Use -h to print all commandline options.

 Fluxus also contains a keypress and mouse event recorder for 
 recording livecoding sessions:
 $ fluxus -r filename : record to keypresses file
 $ fluxus -p filename : playback from file
 $ fluxus -p filename -d time : seconds per frame time override for
                                playback (for use with frame-dump)


------------------------------------------------------------

(authors)



 Authors
 -------
 Alex Norman 
 Artem Baguinski
 Claude Heiland-Allen
 Dan Bethell
 Dave Griffiths 
 Gabor Papp
 Glauber Alex Dias Prado
 Nik Gaffney
 James Tittle

 "Computers are useless. They can only give you answers". 
     Pablo Picasso (1881 - 1973).


------------------------------------------------------------

(language)


 Language Docs
 -------------
 
 Fluxus is comprised of a set of functions which
 extend Scheme for use in realtime computer graphics.
 
 Scheme itself is out of the scope of this documentation,
 but fluxus is a good way of learning it. I reccommend 
 "The Little Schemer" by by Daniel P. Friedman and Matthias 
 Felleisen.
 
 The functions are grouped into sections to make things
 a bit easier to find.

 (help "sections") for a list of all sections
 (help "sectionname") to find out more about a section
 (help "functionname") to find out more about a function

 The idea is that you can find a function you are interested 
 in by doing something like this:

 (help "sections")
    ... list of sections ...
 (help "maths")
    ... description and list of maths functions ...
 (help "vmul")
    ... details about the function with example ...



------------------------------------------------------------

(toplap)


 TOPLAP MANEFESTO
 We demand:
  * Give us access to the performer's mind, to the whole human 
    instrument.
  * Obscurantism is dangerous. Show us your screens.
  * Programs are instruments that can change themselves
  * The program is to be transcended - Artificial language is the way.
  * Code should be seen as well as heard, underlying algorithms viewed 
    as well as their visual outcome.
  * Live coding is not about tools. Algorithms are thoughts. 
    Chainsaws are tools. That's why algorithms are sometimes 
    harder to notice than chainsaws.
 
 We recognise continuums of interaction and profundity, but prefer: 
  * Insight into algorithms
  * The skillful extemporisation of algorithm as an 
    expressive/impressive display of mental dexterity
  * No backup (minidisc, DVD, safety net computer)
 
 We acknowledge that:
  * It is not necessary for a lay audience to understand the 
    code to appreciate it, much as it is not necessary to know 
    how to play guitar in order to appreciate watching a guitar 
    performance.
  * Live coding may be accompanied by an impressive display of 
    manual dexterity and the glorification of the typing interface.
  * Performance involves continuums of interaction, covering 
    perhaps the scope of controls with respect to the parameter 
    space of the artwork, or gestural content, particularly 
    directness of expressive detail. Whilst the traditional 
    haptic rate timing deviations of expressivity in 
    instrumental music are not approximated in code, why repeat 
    the past? No doubt the writing of code and expression of 
    thought will develop its own nuances and customs.
 
 Performances and events closely meeting these manifesto 
 conditions may apply for TOPLAP approval and seal. 

============================================================

Section: "frisbee"

Frisbee is an experimental high level game engine written for 
FrTime, a functional reactive programming language available as 
part of PLT Scheme. It's completely separate to the main fluxus 
commands, and represents a different way of creating games or 
other behavoural systems.

------------------------------------------------------------

(vec3 x y z)
Returns result-vector

Creates a new vector usable inside frisbee - use this rather than 
(vector)

 (vec3 1 2 3)

------------------------------------------------------------

(vec3-x v)
Returns result-number

Returns the x component of the frisbee vector

 (vec3-x (vec3 1 2 3))

------------------------------------------------------------

(vec3-y v)
Returns result-number

Returns the y component of the frisbee vector

 (vec3-y (vec3 1 2 3))

------------------------------------------------------------

(vec3-z v)
Returns result-number

Returns the z component of the frisbee vector

 (vec3-z (vec3 1 2 3))

------------------------------------------------------------

(vec3-integral v)
Returns result-vector

Returns the integral of the frisbee vector in respect to time

 (vec3-integral (vec3 0 0.01 0))

------------------------------------------------------------

(scene collide-b)
Returns void

Sets the frisbee scene up. The list can contain primitive structures, 
or more lists.

 (scene (list (cube)))

------------------------------------------------------------

(scene scene-list)
Returns void

Sets the frisbee scene up. The list can contain primitive structures, 
or more lists.

 (scene (list (cube)))

============================================================

Section: "testing-functions"

A set of higher level control structures for manipulating objects 
and state in fluxus in a cleaner and safer manner.

------------------------------------------------------------

(self-test do-logging)
Returns void

Runs all of the function reference scripts in a separate thread 
so you can watch it in action. Just checks for syntactic errors 
in the scheme, changes in bound C++ function signatures and crashes. 
Graphical code is difficult to test for correctness further (that's 
my excuse). If do-logging is true it outputs a log text file to 
the current directory for debugging.

 (self-test #t)

------------------------------------------------------------

(test-example path-to-examples)
Returns void

Runs all of the example scripts in a separate thread so you can 
watch it in action.

 (test-example path-to-examples)

