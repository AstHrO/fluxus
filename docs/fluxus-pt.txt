Fluxus Documentation 0.15
============================================================

Section: "scratchpad-docs"

O scratchpad é o editor fluxus e a janela gl.

------------------------------------------------------------

(tophelp)


 Fluxus docs
 -----------
 "act of a flowing; a continuous moving on or passing by, as of a 
 flowing stream; a continuous succession of changes"

 "ato de fluir; um movimento contínuo ou um passar, como a corrente
 do rio; uma sucessão contínua de mudanças"

 Fluxus é uma máquina de renderização em tempo real para
 livecoding em Scheme.
 Você é encorajado a viajar por estes textos enquanto performar
 códigos ao vivo...
 
 O scratchpad de Fluxus têm dois modos de operação, o console
 (você está usando ele agora) que permite que você entre comandos
 e veja o resultado imediatamente. O outro modo é o editor que se
 parece mais com um editor de texto normal -  você tem 9 áreas de
 trabalho( que permite que você edite mais de um script de uma
 vez) vá para eles usando ctrl-1 até ctrl-9 e venha de volta para
 o console com ctrl-0.                                   

 Mais tópicos de ajuda:
 (help "keys") para comandos do teclado que controlam o fluxus.
 (help "console") para mais ajuda sobre o console
 (help "editor") para mais ajuda no editor de livecoding
 (help "camera") para ajuda nos controles da câmera.
 (help "linguagem") informação sobre os comandos no fluxus.
 (help "misc") para informações miscelâneas sobre o fluxus.
 (help "toplap") para o manifesto toplap.
 (help "autores") quem fez isso?

------------------------------------------------------------

(keys)


 Teclas do Fluxus
 ----------------
 
 ctrl-f : modo Tela cheia.
 ctrl-w : modo Janela.
 ctrl-h : esconder/mostrar o editor.
 ctrl-l : Carregar um novo script (navegue com os cursores e enter)
 ctrl-s : Salve o script atual.
 ctrl-d : Salvar como - o script atual (abre um caixa com nome)
 ctrl-1 to 9 : Vai para a área de trabalho selecionada.
 ctrl-0 : Vai para o REPL. F3 : Reinicia a câmera.
 F5 : Executao texto selecionado, ou tudo se não tem nada selecionado.
 F9 : Randomisa a cor do texto (aka botão panico)

------------------------------------------------------------

(console)


 Console do Fluxus (ou REPL) ---------------------------

 Se você pressionar ctrl e 0, ao invés de abrir outra área de
 trabalho para scripts você vai ser apresentado a um interpretador
 de Leitura EvaluaçãoImpressão e Loop, ou repl por
 diminutivo. Isto realmente é um interpretador interativo similar
 a uma linha de comando, onde você pode entrar código scheme para
 evaluação imediata. Estecódigo é evaluado no mesmo interpretador
 que os outros scripts, então você pode usar o repl para debug ou
 inspecionar variáveis globais e funções que elas definem. Esta janela é também onde todo os erros são impressos, junto com a
 janela de terminal que você iniciou o fluxus.

------------------------------------------------------------

(editor)


 EditorFluxus
 -------------

 Quando usar o scratchpad do fluxus, a idéia é que você só precise
 da única tela para construir os scripts, ou tocar ao vivo, F5 é a
 chave que roda o script quando vc estiver pronto. Selecionando
 texto (usando shift) e pressionando F5 vai executar somente o
 texto selecionado. Isto é uma mão na roda para re-evaluar funções
 sem rodar o script inteiro toda vez.

 Áreas de trabalho
 -----------------

 O editor de script permite que voce edite até 9 scripts
 simultaneamente usando diferentes áreas de trabalho. Para trocas
 de área, use ctrl+tecla de número. Somente um script pode rodar
 de uma vez no entanto, apertando F5 vai executar o script da área
 de trabalho ativa atualmente.

 Auto foco
 ---------
 
 O editor inclui uma propriedade de auto escalagem/centralização que
 é ligada por padrão. Para desligar - adicione a linha:
 (set! fluxus-scratchpad-do-autofocus 0)
 para o seu arquivo .fluxus.scm - ou crie um novo arquivo chamado
 assim no seu diretório home, contendo essa linha.

------------------------------------------------------------

(camera)
Returns void



 Fluxus camera control
 ---------------------
 
 A câmera é controlada ao mover o mouse e pressionar os botões ao
 mesmo tempo.

 Botão esquerdo do mouse: Rotaciona
 Botão do meio do mouse: Movimenta
 Botão direito do mouse: Afasta/Aproxima(zoom)

------------------------------------------------------------

(misc)


 Script init do fluxus
 ---------------------
 Fluxus procura por um script no seu diretório casa ($HOME)chamado
 .fluxus.scm o qual vai ser executado se encontrado. Isto é útil
 para colocar comandos de inicialização (como conectar ao jack ou
 ajustar a linguagem para o texto de ajuda e etc)

 Aceleração da taxa de quadros
 -----------------------------
 Por padrão fluxus mantém a taxa de quadros em volta de 40 fps. para
 desligar (e rodar em 100% de cpu), use desiredfps com algum número
 arbitrariamente grande:
 (desiredfps 1000000000)
 Para mostrar a fps use (show-fps 1)

 Opções de linha de comando
 --------------------------
 O jeito mais fácil de carregar um script no fluxus é específicar o
 mesmo na linha de comando, eg:
 $ fluxus -x myscript.scm
 Vai lançar o fluxus, carregar, esconder e executar o script.

 Fluxus também possui um gravador de teclas apertadas e cliques do
 mouse para gravar sessões de códificação ao vivo (livecoding):
 $ fluxus -r nome-do-arquivo : gravar em arquivo as teclas apertadas
 $ fluxus -p nome-do-arquivo : tocar a partir do arquivo
 $ fluxus -p nome-do-arquivo -d tempo : segundos por quadro
 substituidos para tocar (pra usar com frame-dump)


------------------------------------------------------------

(authors)



 Autores
 -------
 Alex Norman 
 Artem Baguinski
 Claude Heiland-Allen
 Dan Bethell
 Dave Griffiths 
 Gabor Papp
 Glauber Alex Dias Prado
 Nik Gaffney
 James Tittle

 "Computadores são inúteis. Elessó podem te dar respostas". 
     Pablo Picasso (1881 - 1973).


------------------------------------------------------------

(linguagem)


 Docs da Linguagem
 -----------------
 
 Fluxus é composto de uma série de funções que extendem Scheme pra
 uso em computação gráfica em tempo real.

 Scheme em si está fora do escopo desta documentação, mas fluxus é
 uma boa forma de aprender ele. Eurecomendo "The Little Schemer"
 por Daniel P. Friedman e Matthias Felleisen.

 As funções estão agrupadas em seções para fazer coisas um pouco
 mais fáceis de encontrar.

 (help "sections")
    ... lista de seções ...
 (help "maths")
    ... descrição e lista das funções matemáticas ...
 (help "vmul")
    ... detalhes sobre a função com exemplos ...



------------------------------------------------------------

(toplap)


 MANEFESTOTOPLAP
 Nós queremos:
  * Nos dê acesso a mente do performante, a todo o instrumento humano.
  * Obscurantismo é perigoso. Nos mostre suas telas.
  * O Programa é pra ser transcendentalizado - Linguagem Artificial é
 o caminho.
  * Programas são instrumentos que se alteram eles mesmo.
  * Código deve ser visto tanto quanto ouvido, algoritmos e sua
 estrutura mostrados como seus resultados visuais.
  * Codificação ao vivo(livecoding) não é sobre ferramentas.
  * Algoritmos são pensamentos. Serras-elétrica são ferramentas.
  * É por isso que algoritmos são mais difíceis de notar que
  moto-serras.

 Nós reconhecemos continuos de interação e profundidade, mas
 preferimos:
  * Introspecção nos algoritmos.
  * A habilidosa extemporização de algoritmos como uma amostra
  expressiva/impressiva da destreza mental.
  * Sem estoque (minidisc, DVD, computador seguro na net)

 Nos sabemos que:
  * Não é necessário para a audiência entender código para
  apreciá-lo, da mesma forma em que não é necessário saber tocar uma
  guitarra para gostar de assistir a uma perfomance de guitarra.
  * Códificação ao vivo pode ser acompanhado de uma impressionante
  mostra de destreza manual e a glorificação da interface de
  datilografia.
  * Perfomances envolvem continuos de interação, cobrindo talvez o
  escopo do controle a respeito dos parametros espaciais do trabalho
  artistico, ou conteudo gestual, particularmente direção de detalhe
  expressivo. Enquantoo tradicional taxa de tempo táctil variante
  de expressividade na música tradicional não são aproximadas no
  código, porque repetir o passado? Sem dúvida a escrita de código e
  expressão do pensamento daí derivado vai desenvolver suas próprias
  nuances e particularidades.

 Perfomancs e eventos próximamente alcançando os critérios desse
 manifesto podem aplicar pela aprovação e selo TOPLAP.

============================================================

Section: "osc"

OSC significa Open Sound Control, e é um protocolo amplamente 
usado para passar dados entre aplicações multimidia. Fluxus pode 
enviar e/ou receber mensagens.

 Um exemplo de uso de osc para comunicar entre pd e fluxus.
 Um script fluxus para mover um cubo baseado em mensagens osc
 entrando.
 -- osc.scm

 (define value 0)

 (define (test)
     (push)
     (if (osc-msg "/zzz")
         (set! value (osc 0)))
     (translate (vector 1 0 value))
     (draw-cube)
     (pop))
 
 (osc-source "6543")
 (every-frame (test))
 
 --- EOF
 Um patch PD para enviar mensagens de controle ao fluxus:
 --- zzz.pd
 #N canvas 618 417 286 266 10;
 #X obj 58 161 sendOSC;
 #X msg 73 135 connect localhost 6543;
 #X msg 58 82 send /zzz \$1;
 #X floatatom 58 29 5 0 0 0 - - -;
 #X obj 58 54 / 100;
 #X obj 73 110 loadbang;
 #X connect 1 0 0 0;
 #X connect 2 0 0 0;
 #X connect 3 0 4 0;
 #X connect 4 0 2 0;
 #X connect 5 0 1 0;

------------------------------------------------------------

(osc-source string-porta)
Returns void

Inicia o servidor osc, ou muda a porta. Bug conhecido: parece 
falhar se você usa de volta pra uma mesma porta já usada anteriormente.

 (osc-source "4444")	 ; listen to port 4444 for osc messages

------------------------------------------------------------

(osc-msg string-nome)
Returns void

Retorna verdadeiro se a mensagem foi recebida desde o último quadro, 
e ajusta ela como a mensagem atual para chamadas subsequente ao 
(osc) para ler argumentos.

 (cond 
     ((osc-msg "/hello")              ; if a the /hello message is recieved
         (display (osc 1))(newline)))	; print out the first argument

------------------------------------------------------------

(osc número-argumento)
Returns void

Retorna o argumento da mensagem osc atual.

 (cond 
     ((osc-msg "/hello")              ; if a the /hello message is recieved
         (display (osc 1))(newline)))	; print out the first argument

------------------------------------------------------------

(osc-destination string-porta)
Returns void

Específica o destino para mensagens osc que estejam saindo. O 
nome da porta precisa ser específicado com todo o url e deve ser 
algo do tipo "osc.udp://localhost:4444"

 (osc-destination "osc.udp:localhost:4444")
 (osc-send "/hello" "s" (list "boo!"))  ; send a message to this destination

------------------------------------------------------------

(osc-peek)
Returns msg-string

Esta útil função retorna o nome, formato da string e número/string 
dos argumentos da última mensagem enviada como uma string - para 
debugar sua rede osc.

 (display (osc-peek))(newline) 

------------------------------------------------------------

(osc-send string-nome string-formato lista-argumento)
Returns void

Envia uma mensagem osc com o argumento da lista como dado osc. 
Somente suporta floats, ints e strings como dados. O formato-string 
deve ser composto de "i", "f" e "s", e deve bater com os tipos 
dados na lista. Isto poderia ser removido provavelmente, usando 
os tipos diretamente, mas fazendo isto desta forma permite que 
você diga o tipo da mensagem osc explicitamente.

 (osc-destination "osc.udp:localhost:4444")
 (osc-send "/hello" "sif" (list "boo!" 3 42.3))  ; send a message to this destination

============================================================

Section: "funcoes-uteis"

Fun��es pr�ticas para fazer a sua vida mais f�cil.

------------------------------------------------------------

(time)
Returns numero do tempo(transcorrido, passado)

Retorna o numero de segundos (+ fracao) desde meia noite do dia 
1 de janeiro de 1970. Essa e a forma mais simples de animacao 
para seus scripts

 (define (animate)
     (rotate (vector (sin (time)) 0 0))
     (draw-cube))
 (every-frame (animate))    

------------------------------------------------------------

(delta)
Returns numero do tempo(transcorrido, passado)

Tempo em segundos desde o ultimo frame. Usado pra fazer animacoes 
com taxa de frames independendente(constante).

 (define (animate)
     (rotate (vector (* (delta) 10) 0 0))
     (draw-cube))
 (every-frame (animate))    

------------------------------------------------------------

(flxrnd)
Returns n��mero rand��mico

Retorna um n��mero rand��mico entre 0 e 1.

 (define (animate)
     (colour (vector (flxrnd) (flxrnd) (flxrnd)))
     (draw-cube))
 (every-frame (animate))

------------------------------------------------------------

(flxseed n��mero da semente)
Returns void

Alimenta o gerador de n��mero rand��mico de forma que n��s consigamos 
a mesma sequ��ncia.

 (define (animate)
     (colour (vector (flxrnd) (flxrnd) (flxrnd)))
     (draw-cube))
 (flxseed 10) 
 (every-frame (animate)) ; a mesma sequ��ncia de cores ser�� gerada

------------------------------------------------------------

(set-searchpaths lista de diret��rios)
Returns void

Arranja um lista de diret��rios de busca para procurar por arquivos 
relacionado ao fluxus, como texturas, shaders etc. Os diret��rios 
ser��o procurados em ordem a cada vez.

 (set-searchpaths (list "/path/to/my/textures/" "/path/to/my/other/textures/"))

------------------------------------------------------------

(get-searchpaths lista de diret��rios)
Returns void

Arranja um lista de diret��rios de busca para procurar por arquivos 
relacionado ao fluxus, como texturas, shaders etc. Os diret��rios 
ser��o procurados em ordem a cada vez.

 (get-searchpaths (list "/path/to/my/textures" "/path/to/my/other/textures"))

------------------------------------------------------------

(fullpath string do nome do arquivo)
Returns fullpath-string

Busca os diret��rios de procura para o arquivo especificado e 
retorna a primeira localiza����o que encontra.

 (fullpath "myfile")

------------------------------------------------------------

(framedump nome-do-arquivo)
Returns void

Salva o buffer OpenGL da frente no disco. L�� a extens��o do arquivo 
pra decidir qual qual formato ser�� usado pra salvar, "tif", "jpg" 
ou "ppm" s��o suportados. Esta �� a forma de frame dumping de 
baixo nivel, use start-framedump e end-framedump ao inv��s.

 (framedump "picture.jpg")

============================================================

Section: "primitivas"

Primitivas são objetos que você pode renderizar. Não há muito 
mais coisas numa cena do fluxus, exceto luzes, uma camera e muitas 
primitivas.

------------------------------------------------------------

(build-cube)
Returns número-de-id-da-primitiva

Um simples cubo, mapeamento de textura por face.

 (define mynewcube (build-cube))

------------------------------------------------------------

(build-polygons número-de-vértices tipo-de-número)
Returns número-de-id-primitiva

Cónstroi uma primitiva de polígono cru com tamanho de vértices 
(tudo é inicialmente tido como zero). Tipo é um número que referencia 
a forma as quais os vértices são interpretados para construir 
os poligonos, e podem ser os seguintes: 0=TRISTRIP, 1=QUADS, 2=TRILIST, 
3=TRIFAN, 4=POLYGON.

 (define mynewshape (build-polygons 100 'triangle-strip))

------------------------------------------------------------

(build-sphere número-de-cortes-horizontais número-de-cortes-verticais)
Returns número-id-primitiva

Uma esfera com a resolução especificada, a textura mapeada no 
estilo normal "world map".

 (define mynewshape (build-sphere 10 10))

------------------------------------------------------------

(build-torus número-raio-interior número-raio-exterior número-cortes número-fatias)
Returns número-id-primitiva

Um torus com a resolução especificada, controle o tamanho e a 
grossura da "rosquinha" com o raio inferior e exterior.

 (define mynewshape (build-torus 0.5 1 12 12))

------------------------------------------------------------

(build-plane)
Returns número-id-primitiva

Um único plano quadrado, mapeado de 0->1 em ambas as dimensões.

 (define mynewshape (build-plane))

------------------------------------------------------------

(build-seg-plane número-de-vértices-x número-de-vértices-y)
Returns número-id-primitiva

Um plano poligonal tesselado, mapeado de 0->1 em ambas dimensões.

 (define mynewshape (build-plane))

------------------------------------------------------------

(build-cylinder h-segmentos r-segmentos)
Returns número-id-primitiva

Um cilindro coberto, textura mapeada em volta, e mal mapeada em 
volta do fim.

 (define mynewshape (build-cylinder 10 10))

------------------------------------------------------------

(build-ribbon numpoints-número)
Returns número-id-primitiva

Cónstroi uma linha consistindo de numpoints pontos. A geometria 
aponta para a câmera constantemente e a textura é mapeada de forma 
que se alonga na linha do início ao fim. Você usa as funções pdata 
para editar as posições e largura das linhas. Se usado iluminado, 
as normais são falseadas para aproximar uma seção circular cruzada. 
Adicionalmente, se renderização sólida for limpa com (hint-none) 
e (hint-wire) ativado, uma rápida linha constante vai ser desenhada 
- largura específicada pelo comando (line-width).

 (define mynewshape (build-ribbon 10))

------------------------------------------------------------

(build-text string-texto)
Returns número-id-primitiva

Constrói uma sequencia de planos, mapeados de forma que uma textura 
de fonte possa ser usada para visualização. Pode vir a ser útil 
para coisas mais abstratas. A fonte é assumida como não proporcional 
- tem um exemplo de fonte acompanhando o fluxus. Ok, so this isn't 
a very good font texture :)

 (texture (texture-load "font.png"))
 (define mynewshape (build-text "hello"))

------------------------------------------------------------

(build-nurbs-sphere h-segmentos r-segmentos)
Returns número-id-primitiva

Constrói uma esfera nurbs tesselada, mapead da mesma forma que 
a esfera poligonal.

 (define mynewshape (build-nurbs-sphere 10 10))

------------------------------------------------------------

(build-nurbs-plane h-segmento r-segmento)
Returns número-id-primitiva

Constrói um plano nurbs tesselado, mapeado na direção uv.

 (define mynewshape (build-nurbs-plane 10 10))

------------------------------------------------------------

(build-particles número-contagem)
Returns número-id-primitiva

Cónstroi uma primitiva de partículas contendo num pontos, tudo 
inicialmente aplicado à origem. Você usa as funções pdata para 
editar as posições, cores e tamanhos. Partículas vêm em dois tipos, 
sprites apontando pra câmera, que são o padrão, podem ser texturizadas 
e escaladas individualmente; e pontuais (quando hint-points está 
aplicado), que não podem ser texturizadas mas são muito mais rápidas 
de renderizar, já que elas são pontos gl suportados pelo hardware. 
Por defeito essas partículas pontuais são quadradas, ligue hint-anti-alias 
para faze-las circulares.

 (define mynewshape (build-particles 100))

------------------------------------------------------------

(build-locator)
Returns número-id-primitiva

Um locator é uma primitiva vazia, útil para parentesco (quando 
você não quer ter o objeto pai visivel). Essa primitiva só pode 
ser visualizada com (hint-origin) para mostrar sua origem de transformação 
local.

 (define mynewshape (build-locator))

------------------------------------------------------------

(load-primitive)
Returns número-id-primitiva



 (define mynewshape (load-primitive "octopus.obj"))

------------------------------------------------------------

(clear-geometry-cache)
Returns número-id-primitiva



 (clear-geometry-cache)

------------------------------------------------------------

(save-primitive)
Returns número-id-primitiva



 (with-primitive (build-sphere 10 10) 
     (save-primitive "mymesh.obj"))

------------------------------------------------------------

(build-pixels número-largura número-altura)
Returns número-id-primitiva

Faz uma nova primitiva pixel. Uma primitiva pixel é usada pra 
fazer texturas procedurais, que podem então ser aplicadas em outras 
primitivas. Por essa razão, primitivas pixel não vão ser renderizadas 
muito, mas você pode renderizar elas para visualizar a texturas 
em um plano.

 (define mynewshape (build-pixels 100 100))
 (with-primitive mynewshape
     (pdata-map!
         (lambda (c)
             (rndvec))
         "c")
     (pixels-upload)) ; call pixels upload to see the results

------------------------------------------------------------

(pixels-upload)
Returns void

Traz os dados da textura, você precisa chamar isto quando você 
finalizou escrever ao pixelprim, e enquanto ele está "grabbed".

 (define mynewshape (build-pixels 100 100))
 (with-primitive mynewshape
     (pdata-map!
         (lambda (c)
             (rndvec))
         "c")
     (pixels-upload)) ; call pixels upload to see the results

------------------------------------------------------------

(pixels->texture número-id-pixelprim)
Returns número-id-textura

Retorna uma textura que você pode usar exatamente igual uma que 
foi carregada normalmente.

 (define mypixels (build-pixels 100 100))
 (with-primitive mypixels
     (pdata-map!
         (lambda (c)
             (rndvec))
         "c")
     (pixels-upload)) 

 (with-state
     (texture (pixels->texture mypixels))
     (build-torus 1 2 10 10))

------------------------------------------------------------

(build-blobby número-influencias vecsubdvision vecfronteira)
Returns número-id-primitiva

Primitivas blobby no fluxus são uma representação de superfície 
implicita de alto nível que é definida usando influências no espaço 
em 3 dimensões. Estas influências são então somadas, e um valor 
particular é "malheado" (usando o algorítmo dos cubos marchando) 
para formar uma superfície macia. Estas influências podem ser 
animadas, e a superfície macia mexe e deforma para adaptar, dando 
a primitiva seu nome blobby. build-blobby retorna uma nova primitiva 
blobby. número-influências é o número de "blobs", Subdivisão permite 
a você controlar a resolução da superfície em cada dimensão, enquanto 
vecfronteira ajusta a área fronteriça da primitiva em espaço de 
objeto local. A malha não vai ser calculada fora desta área limite. 
Influências de cores e posições precisam ser ajustadas usando 
pdata-set.

 (clear)
 (define b (build-blobby 5 (vector 30 30 30) (vector 1 1 1)))
 
 (with-primitive b
     (shinyness 100)
     (specular (vector 1 1 1))
     (hint-vertcols)
     (pdata-set "p" 0 (vector 0.75 0.25 0.5))
     (pdata-set "c" 0 (vector 0.01 0 0))
     (pdata-set "s" 0 0.01)
     (pdata-set "p" 1 (vector 0.25 0.75 0.5))
     (pdata-set "c" 1 (vector 0 0.01 0))
     (pdata-set "s" 1 0.01)
     (pdata-set "p" 2 (vector 0.75 0.75 0.5))
     (pdata-set "c" 2 (vector 0 0 0.01))
     (pdata-set "s" 2 0.01)
     (pdata-set "p" 3 (vector 0.25 0.25 0.5))
     (pdata-set "c" 3 (vector 0.01 0.01 0))
     (pdata-set "s" 3 0.01)
     (pdata-set "p" 4 (vector 0.5 0.5 0.5))
     (pdata-set "c" 4 (vector 0.01 0.01 0.01))
     (pdata-set "s" 4 0.025))

------------------------------------------------------------

(blobby->poly número-id-blobbyprimitiva)
Returns número-id-primitivapoly

Converte a malha de uma primitiva blobby em uma primitiva poligonal 
de lista de triângulos.

 (clear)
 (define b (build-blobby 5 (vector 30 30 30) (vector 1 1 1)))
 
 (with-primitive b
     (shinyness 100)
     (specular (vector 1 1 1))
     (hint-vertcols)
     (pdata-set "p" 0 (vector 0.75 0.25 0.5))
     (pdata-set "c" 0 (vector 0.01 0 0))
     (pdata-set "s" 0 0.01)
     (pdata-set "p" 1 (vector 0.25 0.75 0.5))
     (pdata-set "c" 1 (vector 0 0.01 0))
     (pdata-set "s" 1 0.01)
     (pdata-set "p" 2 (vector 0.75 0.75 0.5))
     (pdata-set "c" 2 (vector 0 0 0.01))
     (pdata-set "s" 2 0.01)
     (pdata-set "p" 3 (vector 0.25 0.25 0.5))
     (pdata-set "c" 3 (vector 0.01 0.01 0))
     (pdata-set "s" 3 0.01)
     (pdata-set "p" 4 (vector 0.5 0.5 0.5))
     (pdata-set "c" 4 (vector 0.01 0.01 0.01))
     (pdata-set "s" 4 0.025))
 
 (define p (with-state
     (translate (vector 1 0 0))
     (blobby->poly b)))

------------------------------------------------------------

(draw-instance número-id-primitiva)
Returns void

Copia um modo retido da primitiva e desenha ela no estado corrente 
como um no modo imediato.

 (define mynewshape (build-cube))
 (colour (vector 1 0 0))
 (draw-instance mynewshape) ; draws a copy of mynewshape

------------------------------------------------------------

(draw-cube)
Returns void

Desenha um cubo no estado imediato corrente.

 (define (render)
     (draw-cube))
 (every-frame (render))

------------------------------------------------------------

(draw-plane)
Returns void

Desenha um plano no estado corrente em modo imediato

 (define (render)
     (draw-plane))
 (every-frame (render))

------------------------------------------------------------

(draw-sphere)
Returns void

Desenha uma esfera no estado corrente em modo imediato.

 (define (render)
     (draw-sphere))
 (every-frame (render))

------------------------------------------------------------

(draw-cylinder)
Returns void

Desenha um cilindro no estado corrente em modo imediato.

 (define (render)
     (draw-cylinder))
 (every-frame (render))

------------------------------------------------------------

(draw-torus)
Returns void

Desenha um torus no estado imediato corrente.

 (define (render)
     (draw-torus))
 (every-frame (render))

------------------------------------------------------------

(destroy número-id-primitive)
Returns void

Deleta uma primitiva construída do renderizador.

 (define mynewshape (build-sphere 10 10))
 (destroy mynewshape)

------------------------------------------------------------

(poly-set-index lista-indexada)
Returns void

Troca a primitiva por modo indexado,e usa a lista como valores 
de index para essa primitiva.

 (clear)
 ; lets build our own cube primitive...
 (define p (build-polygons 8 'quad-list))
 
 (with-primitive p
     ; setup the vertex data
     (pdata-set "p" 0 (vector -1 -1 -1))
     (pdata-set "p" 1 (vector  1 -1 -1))
     (pdata-set "p" 2 (vector  1 -1  1))
     (pdata-set "p" 3 (vector -1 -1  1))
     (pdata-set "p" 4 (vector -1  1 -1))
     (pdata-set "p" 5 (vector  1  1 -1))
     (pdata-set "p" 6 (vector  1  1  1))
     (pdata-set "p" 7 (vector -1  1  1))
     (pdata-set "c" 0 (vector  0  0  0))
     (pdata-set "c" 1 (vector  0  0  1))
     (pdata-set "c" 2 (vector  0  1  0))
     (pdata-set "c" 3 (vector  0  1  1))
     (pdata-set "c" 4 (vector  1  0  0))
     (pdata-set "c" 5 (vector  1  0  1))
     (pdata-set "c" 6 (vector  1  1  0))
     (pdata-set "c" 7 (vector  1  1  1))
     
     (hint-wire)
     (hint-unlit)
     (hint-vertcols)
     
     ; connect the verts together into faces
     (poly-set-index (list 7 6 5 4  5 6 2 1 
             4 5 1 0  1 2 3 0
             3 7 4 0  6 7 3 2)))

------------------------------------------------------------

(poly-convert-to-indexed)
Returns void

Converte o atual poligono primitivo que está "grabbed" de arrays 
de vértices crus para arrays indexadas. Isto remove vértices duplicados 
do polígono, fazendo a array de pdata menor, o que aumenta a velocidade 
do processo.

 (define mynewshape (build-sphere 10 10))
 (grab mynewshape)
 (poly-convert-to-indexed)
 (ungrab)

------------------------------------------------------------

(build-copy número-primitiva-fonte)
Returns número-id-primitiva

Retorna uma cópia da primitiva

 (define mynewshape (build-sphere 10 10))
 (define myothernewshape (build-copy mynewshape))

------------------------------------------------------------

(make-pfunc string-nome)
Returns número-pfuncid

Faz uma nova primitiva funcional. Pfuncs variam de propósito geral 
até operações complexas e especializadas que você pode rodar em 
primitivas. Todas as pfuncs dividem a mesma interface para controlar 
e ajustar - pfunc-set! Todos os tipos e argumentos pfunc são como 
os seguintes: arithmetic Para aplicar aritmética geral para qualquer 
array pdata. operator string : um dos add sub mul div src string 
: nome pdata array other string : nome pdata array (opcional) 
constant float : valor constante (opcional) dst string : nome 
pdata array genskinweights Gera pesos de skinning - adiciona float 
pdata chamada "s1" -> "sn" aonde n é o número de nós no esqueleto 
- 1 skeleton-root primid-number : a raiz da posebind do esqueleto 
para skinning sharpness float : um controle de quão afiado o vinco 
vai ser quando "skineado". skinweights->vertcols Uma utilidade 
para visualizar pesos de skin para debugar. sem argumentos. skinning 
Skin uma primitiva - deforma ela para seguir os movimentos de 
um esqueleto. Primitivas que a gente quer usar isto deve conter 
extra pdata - cópias das posições iniciais das posições dos vértices 
chamadas "pref" e o mesmo para normais, se as normais estão sendo 
skineadas , chamada "nref". skeleton-root primid-number : a primitiva 
raiz do esqueleto animado bindpose-root primid-number : a raiz 
primitiva da pose bind do esqueleto skin-normals number : se devemos 
usar skin nas normais como nas posições

 (define mypfunc (make-pfunc 'arithmetic))

------------------------------------------------------------

(pfunc-set! número-id-pfunc lista-argumento)
Returns void

Ajusta argumentos na função primitiva. Veja a documentação de 
make-pfunc para todos os argumentos.

 (define mypfunc (make-pfunc 'arithmetic))
 (pfunc-set! mypfunc (list 'operator "add"
                           'src "p"
                           'const 0.4
                           'dst "p"))

------------------------------------------------------------

(pfunc-run número-id)
Returns void

Roda uma função primitiva na primitiva atualmente pega.

 (define mypfunc (make-pfunc 'arithmetic))

------------------------------------------------------------

(line-intersect número-id)
Returns void

Roda uma função primitiva na primitiva atualmente pega.

 (clear)
 (define s (with-state
         (build-torus 1 2 10 10)))
 
 (define l (with-state
         (hint-none)
         (hint-unlit)
         (hint-wire)
         (build-line 2)))
 
 (define (check a b)
     (with-primitive s
         (for-each
             (lambda (intersection)                    
                 (with-state ; draw a sphere at the intersection point
                     (translate (cdr (assoc "p" intersection)))
                     (colour (vector 0 1 0))
                     (scale (vector 0.3 0.3 0.3))
                     (draw-sphere)))
         (line-intersect a b))))
 
 (every-frame
     (with-primitive l
         (pdata-set "p" 0 (vector 0 -5 0))
         (pdata-set "p" 1 (vector (* 5 (sin (time))) 5 0))
         (check (pdata-ref "p" 0) (pdata-ref "p" 1))))

============================================================

Section: "dados-primitivos"

Dados primitivos (pdata para diminuir) é o nome fluxus' para dados 
que formam primitivas. Em primitivas poligonais isto significa 
informação dos vértices, em primitivas de partículas isto corresponde 
a informação da partícula, em primitivas NURBS são os vértices 
de controle. Acesso a pdata dá a você a habilidade de usar primitivas 
que de outra forma não seria tão interessante, e deformar e fazer 
outras primitivas resultando em modelos muito mais detalhados 
e animações. Você pode também adicionar sua própria pdata, que 
é tratado exatamente como os tipos já existentes. Dados primitivos 
são nomeados por strings de tipo, os nomes de qual depende a ordem 
da primitiva. Todos os comandos Pdata operam na primitiva atualmente 
pega [grabbed].

 ; uma função para deformar os pontos de um objeto
 (define (deform n)
     (pdata-set! "p" n (vadd  (pdata-ref "p" n)                ; o ponto original, mais
         (vmul (vector (flxrnd) (flxrnd) (flxrnd)) 0.1)))     ; um pequeno vetor randomico
     (if (zero? n)
         0
         (deform (- n 1))))
     
 (hint-unlit) ; ajustar algumas opções de render
 (hint-wire)  ; para fazer as coisas mais fáceis de ver
 (line-width 4)
 (define myobj (build-sphere 10 10)) ; fazer uma esfera
 (grab myobj)
 (deform (pdata-size)) ; deformá-la
 (ungrab)

------------------------------------------------------------

(pdata-ref string-tipo número-index)
Returns vetor-valor/cor/matriz/número

Retorna o elemento pdata correspondente.

 (pdata-ref "p" 1)

------------------------------------------------------------

(pdata-set! string-tipo número-index vetor-valor/cor/matriz/número)
Returns void

Escreve ao elemento pdata correspondente.

 (pdata-set! "p" 1 (vector 0 100 0))

------------------------------------------------------------

(pdata-add string-tipo nome-string)
Returns void

Adiciona um novo usuario de disposição ao pdata. Tipo é um dos 
sequintes "v":vector, "c":colour, "f":float ou "m":matrix.

 (pdata-add "v" "mydata")
 (pdata-set "mydata" 0 (vector 1 2 3))

------------------------------------------------------------

(pdata-op string-nomefunc string-nomepdata operador)
Returns void

Esta é uma função experimental que permite a você fazer operações 
na pdata muito rapidamente, para constar adicionar elemento por 
elemento de uma array de pdata para outra. Você pode implementar 
isto em scheme como um loop sobre cada elemento, mas isto é devagar 
já que o interpretador está fazendo todo o trabalho. É muito mais 
rápido se você puder usar um pdata-op já que a mesma operação 
vai ser apenas uma chamada à scheme.

 (clear)
 (define t (build-torus 1 4 10 10))
 
 (with-primitive t
     (pdata-op "+" "p" (vector 1 0 0))  ; add a vector to all the pdata vectors
     (pdata-op "+" "p" "n")  ; add two pdata vectors element for element
     (pdata-op "*" "n" (vector -1 -1 -1)) ;  multiply a vector to all the pdata vectors
     (pdata-op "*" "n" "p")  ; multiply two pdata vectors element for element
     (let ((pos (pdata-op "closest" "p" (vector 100 0 0)))) ;  returns position of the closest vertex to this point
         (with-state ; draw a sphere there
             (translate pos)
             (scale (vector 0.1 0.1 0.1))
             (build-sphere 5 5)))
     ; can't think of a good example for these...
     ;(pdata-op "sin" "mydata" "myotherdata")  ; sine of one float pdata to another
     ;(pdata-op "cos" "mydata" "myotherdata")  ; cosine of one float pdata to another
     )
 
 ; most common example of pdata op is for particles
 (define p (with-state
     (hint-points)
     (point-width 10)
     (build-particles 100)))
 
 (with-primitive p
     (pdata-add "vel" "v") ; add a velocity vector
     (pdata-map!
         (lambda (vel)
             (srndvec)) ; set random velocities
         "vel")
     (pdata-map!
         (lambda (c)
             (rndvec)) ; set random colours
         "c"))
 
 (every-frame (with-primitive p
     (pdata-op "+" "p" "vel")))

------------------------------------------------------------

(pdata-copy string-pdata-de string-pdata-para)
Returns void

Copia o conteúdo de uma array pdata para outra. As arrays tem 
que ser do mesmo tipo.

 (pdata-copy "p" "mydata") ; copia as posições de vértices para uma array do usuário

------------------------------------------------------------

(pdata-size)
Returns número-contador

Retorna o tamanho das arrays pdata (elas precisam ser todas a 
mesma). Isto é principal para iterar através das arrays.

 (define (mashup n)
     (pdata-set "p" n (vector (flxrnd) (flxrnd) (flxrnd))) ; randomise the vertex position
     (if (zero? n)
         0
         (mashup (- n 1)))) ; loops till n is 0

 (define shape (build-sphere 10 10))
 (grab shape)
 (mashup (pdata-size)) ; randomise verts on currently grabbed primitive
 (ungrab)

------------------------------------------------------------

(finalise)
Returns void

Não faz nada mais, precisa ser removido :)


------------------------------------------------------------

(recalc-normals número-macioounão)
Returns void

Para primitivas poligonais apenas. Olha a posição dos vértices 
e cálcula as normais da luz pra você automaticamente. Chame com 
"1" para normais macias, "0" para normais facetadas.

 (define shape (build-sphere 10 10)) ; build a sphere (which is smooth by default)
 (grab shape)
 (recalc-normals 0) ; make the sphere faceted
 (ungrab)

============================================================

Section: "estado-local"

As funções de estado local controlam a renderização ou do estado 
corrente - ou do estado da primitiva correntemente pega(grabbed). 
Em Fluxus estado significa significa a forma que as coisas são 
mostradas, tanto ligando/desligando opções de render, mudando 
o estilo de diferentes opções, ou alterando a transformação corrente.

------------------------------------------------------------

(push)
Returns void

Empurra uma cópia do estado corrente de desenho para o topo da 
pilha. O estado de desenho contém informação sobre coisas como 
cor corrente, transformação e dicas(hints).

 (colour (vector 1 0 0)) ; aplica cor corrente pra vermelho
 (push)                  ; copia e empurra estado de desenho
 (colour (vector 0 1 0)) ; aplica cor corrente pra verde
 (draw-cube)			   ; desenha um cubo verde
 (pop)				   ; esquece estado de desenho antigo
 ; cor corrente é vermelha de novo.

------------------------------------------------------------

(pop)
Returns void

Destrói o estado de desenho corrente, e aplica para o estado corrente 
o antigo anteriormente empurrado na pilha. O estado de desenho 
contém informação sobre coisas como cor corrente, transformação 
e dicas(hints).

 (colour (vector 1 0 0)) ; aplica cor corrente pra vermelho
 (push)                  ; copia e empurra estado de desenho
 (colour (vector 0 1 0)) ; aplica cor corrente pra verde
 (draw-cube)             ; desenha um cubo verde
 (pop)                   ; esquece estado de desenho antigo
 ; cor corrente é vermelha de novo.

------------------------------------------------------------

(grab id-do-objeto)
Returns void

Pega o objeto especificado. Uma vez que o objeto foi pego seu 
estado pode ser modificado usando os mesmos comandos usados pra 
ajustar o estado de desenho atual. (ungrab) precisa ser usado 
para retornar ao estado de desenho normal. "grabbing" também pode 
ser "pilhado", neste caso (ungrab) pula para a próxima primitiva 
pega.

 (colour (vector 1 0 0))      ; aplica a cor atual para vermelho
 (define mycube (build-cube)) ; faz um cubo vermelho
 (grab mycube)  				       
 (colour (vector 0 1 0)) ; aplica a cor do cubo como verde 
 (ungrab)				   ; retorna ao estado normal

------------------------------------------------------------

(ungrab)
Returns void

Solta o objeto pego atualmente, e ou retorna ao estado de desenho 
normal, ou tira a ultima primitiva pega do topo da pilha.

 (colour (vector 1 0 0))      ; aplica a cor atual para vermelho
 (define mycube (build-cube)) ; faz um cubo vermelho
 (grab mycube)  				       
 (colour (vector 0 1 0)) ; aplica a cor verde ao cubo 
 (ungrab)				   ; retorna ao estado normal

------------------------------------------------------------

(apply-transform id-do-objeto)
Returns void

Aplica a transformação corrente às posições dos vértices do objeto 
dado e ajusta sua tranformação para identidade.

 (rotate (vector 45 0 0))     
 (define mycube (build-cube)) ; faz um cubo com uma rotação
 (apply mycube)  	      ; aplica a rotação aos pontos do cubo

------------------------------------------------------------

(opacity valor)
Returns void

Ajusta a opacidade do estado de desenho atual, ou da primitiva 
pega atualmente.

 (opacity 0.5)
 (define mycube (build-cube)) ; faz um cubo semi-transparente.

------------------------------------------------------------

(shinyness valor)
Returns void

Ajusta o brilho do estado atual de desenho, ou da primitiva atualmente 
pega. Esse valor ajusta a densidade do brilho especular.

 (shinyness 100)     
 (specular (vector 1 1 1)) ; ajusta a cor especular
 (define mysphere (build-sphere 10 10)) ; makes a shiny cube 

------------------------------------------------------------

(colour vetor-cor)
Returns void

Ajusta a cor do estado de desenho atual, ou a primitiva atualmente 
pega.

 (colour (vector 1 0.5 0.1)) ; mmm laranja...
 (define mycube (build-cube)) ; faz um cubo laranja

------------------------------------------------------------

(wire-colour vetor-cor)
Returns void

Ajusta a cor do "wire frame" do estado de desenho atual, ou a 
primitiva atualmente pega. Visível com (hint-wire) na maioria 
das primitivas.

 (wire-colour (vector 1 1 0)) ; ajusta a cor do fio como amarelo
 (hint-wire)
 (define mycube (build-cube)) ; faz um cubo com wireframe amarelo

------------------------------------------------------------

(specular vetor-cor)
Returns void

Ajusta a cor especular do estado de desenho corrente, ou o objeto 
atualmente pego.

 (specular (vector 0 0 1)) ; ajusta azul como a cor especular
 (define mysphere (build-sphere 10 10)) ; faz uma esfera azul brilhante.

------------------------------------------------------------

(ambient vetor-cor)
Returns void

Ajusta a cor ambiente do estado de desenho corrente, ou a primitiva 
atualmente pega.

 (ambient (vector 0 0 1)) ; ajusta a cor ambiente como azul
 (define mysphere (build-sphere 10 10)) ; faz uma chata esfera azul

------------------------------------------------------------

(opacity valor)
Returns void

Ajusta a cor emissiva do estado de desenho atual, ou da primitiva 
atualmente pega.

 (emissive (vector 0 0 1)) ; ajusta a cor emissiva para azul
 (define mysphere (build-sphere 10 10)) ; faz uma esfera azul brilhante

------------------------------------------------------------

(identity)
Returns void

Ajusta a transformação do estado de desenho para identidade, no 
estado de pilha, ou a primitiva atualmente pega.

 (define mycube (with-state
     (scale (vector 2 2 2)) ; ajusta o tamanho atual pro dobro em cada dimensão
     (build-cube))) ; faz um cubo aumentado
 
 (with-primitive mycube
     (identity)) ; apaga a transformação e coloca o cubo de volta ao seu
                 ; estado original

------------------------------------------------------------

(concat matrix)
Returns void

Concatena (multiplica) uma matriz para o estado de desenho atual 
ou primitiva pega.

 (define mymatrix (mrotate (vector 0 45 0))) ; faz uma matriz
 (concat mymatrix) ; concat ela no estado atual
 (build-cube) ; faz um cubo com esta rotação

------------------------------------------------------------

(translate vetor)
Returns void

Aplica uma translação ao estado de desenho atual ou primitiva 
pega

 (translate (vector 0 1.4 0)) ; translada a transformação atual pra
                              ; cima um pouco
 (build-cube) ; constrói um cubo com esta transformação

------------------------------------------------------------

(rotate vetor-ou-quaternion)
Returns void

Aplica uma rotação ao estado de desenho atual ou primitiva pega.

 (rotate (vector 0 45 0)) ; vira 45 graus no eixo Y 
 (build-cube) ; constrói um cubo com esta transformação

------------------------------------------------------------

(scale vetor)
Returns void

Aplica uma escalagem ao estado de desenho atual ou primitiva pega.

 (scale (vector 0.5 0.5 0.5)) ; escala a tranformação atual para
                              ; metade do tamanho
 (build-cube) ; constrói um cubo com esta transformação

------------------------------------------------------------

(get-transform)
Returns vetor-matriz

Retorna uma matriz representando o estado de tranformação corrente 
ou para a primitiva pega.

 (translate (vector 1 0 0))
 (display (get-transform))(newline) ; imprime a transformação corrente
 (define shape (build-sphere 10 10))
 (grab shape)
 (translate (vector 0 1 0))
 (display (get-transform))(newline) ; imprime a transformação da forma
 (ungrab)

------------------------------------------------------------

(parent id-primitiva)
Returns void

Parenteia a primitiva correntemente pega à primitiva pai dada. 
A primitiva corrente vai ser agora movida junto com o pai por 
adquirir todas as suas transformações.

 (define parent-prim (build-cube)) ; make a parent cube
 (translate (vector 2 0 0)) ; move a bit in x
 (parent parent-prim) ; set parent-prim as the current parent
 (define child-prim (build-cube)) ; make a child cube
 (grab parent-prim) 
 (rotate (vector 0 45 0)) ; the child will now be moved by this transform in addition to its own
 (ungrab)

------------------------------------------------------------

(line-width valor)
Returns void

Ajusta a largura da linha (em espaço de tela) do estado de desenho 
corrente, ou da primitiva correntemente pega, Afeta wireframe 
e afins.

 (line-width 5)
 (hint-wire)
 (build-sphere 10 10) ; faz uma esfera com um denso wireframe

------------------------------------------------------------

(point-width value)
Returns void

Ajusta o tamanho do ponto (em espaço na tela) do estado de desenho 
corrente, ou da primitiva pega. Afeta a renderização de pontos 
e particulas no hardware.

 (point-width 5)
 (hint-points)
 (build-sphere 10 10) ; faz uma esfera com pontos grossos

------------------------------------------------------------

(blend-mode src dst)
Returns void

Ajusta o modo de mistura do estado de desenho corrente, ou da 
primitiva pega. Esse é o modo que o alpha é composto no superficie 
renderizada.

 ; list out all the possible blendmodes
 
 (define src-blend (vector 'zero 'one 'dst-color 'one-minus-dst-color 'src-alpha
                     'one-minus-src-alpha 'dst-alpha 'one-minus-dst-alpha
                     'src-alpha-saturate))
 
 (define dst-blend (vector 'zero 'one 'dst-color 'one-minus-dst-color 'src-alpha
                     'one-minus-src-alpha 'dst-alpha 'one-minus-dst-alpha))
 
 ; picks a random element
 (define (pick-rnd-item l)
     (vector-ref l (random (vector-length l))))
 
 ; make lots of random spheres
 (define (rnd-sphere n)
     (push)
     (hint-depth-sort)
     (opacity 0.5)
     (colour (vector (flxrnd) (flxrnd) (flxrnd)))
 
     ; set a random blendmode
     (blend-mode (pick-rnd-item src-blend) (pick-rnd-item dst-blend))
 
     (translate (vector (flxrnd) (flxrnd) (flxrnd)))
     (scale (vector 0.1 0.1 0.1))
     (build-sphere 10 10)
     (pop)
     (if (zero? n)
         0
         (rnd-sphere (- n 1))))
 
 (clear)
 (clear-colour (vector 0.5 0.5 0.5))
 (rnd-sphere 100)

------------------------------------------------------------

(hint-solid)
Returns void

Ajusta as dicas pra renderizar como solid no estado de desenho 
corrente, ou a primitiva pega. Dicas de render mudam a forma como 
as primitivas são renderizadas, mas podem ter efeitos diferentes 
- ou nenhum efeito em certas primitivas portanto o nome dicas.

 (hint-solid) ; esse é o estilo de render original então não deve
              ; muito estimulante
 (build-cube) ; faz um cubo renderizado sólido 

------------------------------------------------------------

(hint-wire)
Returns void

Ajusta o render para wireframe no modo de estado corrente, ou 
da primitiva pega. Dicas de render mudam a forma como as primitivas 
são renderizadas, mas podem ter efeitos diferentes - ou nenhum 
efeito em certas primitivas portanto o nome dicas.

 (hint-wire)
 (build-cube) ; faz um cubo em wireframe 

------------------------------------------------------------

(hint-normal)
Returns void

Ajusta as dicas de render para fazer aparecer normais no estado 
de desenho corrente, ou da primitiva pega. Dicas de render mudam 
a forma como as primitivas são renderizadas, mas podem ter efeitos 
diferentes - ou nenhum efeito em certas primitivas portanto o 
nome dicas.

 (hint-normal)
 (build-cube) ; mostra as normais do cubo

------------------------------------------------------------

(hint-points)
Returns void

Ajusta as dicas para aparecer pontos no estado de desenho corrente, 
ou da primitiva pega. Dicas de render mudam a forma como as primitivas 
são renderizadas, mas podem ter efeitos diferentes - ou nenhum 
efeito em certas primitivas portanto o nome dicas.

 (hint-points)
 (build-cube) ; mostra os pontos dos vertices deste cubo

------------------------------------------------------------

(hint-anti-alias)
Returns void

Ajusta as dicas de render para anti-alias no estado de desenho 
atual, ou da primitiva pega. Dicas de render mudam a forma como 
as primitivas são renderizadas, mas podem ter efeitos diferentes 
- ou nenhum efeito em certas primitivas portanto o nome dicas.

 (hint-anti-alias)
 (build-cube) ; mostra um cubo macio

------------------------------------------------------------

(hint-unlit)
Returns void

Ajusta as dicas de render para luzes desligadas no estado de desenho 
corrente, ou da primitiva pega. Dicas de render mudam a forma 
como as primitivas são renderizadas, mas podem ter efeitos diferentes 
- ou nenhum efeito em certas primitivas portanto o nome dicas.

 (hint-unlit)
 (build-cube) ; mostra um cubo sem iluminação

------------------------------------------------------------

(hint-vertcols)
Returns void

Ajusta as dicas de render pra usar cores de vértices no estado 
de desenho corrente, ou da primitiva pega. Dicas de render mudam 
a forma como as primitivas são renderizadas, mas podem ter efeitos 
diferentes - ou nenhum efeito em certas primitivas portanto o 
nome dicas. Cores de vértices modificam o estado atual de (colour).

 (clear)
 (hint-vertcols)
 (define mycube (build-cube)) ; make a cube with vertcols enabled
 
 (with-primitive mycube
     (pdata-map! 
         (lambda (c)
             (rndvec)) ; randomise the vertcols
         "c")) 

------------------------------------------------------------

(hint-box)
Returns void

Ajusta as dicas de render para mostrar a caixa envolvente no estado 
de desenho corrente, ou a primitiva pega. Dicas de render mudam 
a forma como as primitivas são renderizadas, mas podem ter efeitos 
diferentes - ou nenhum efeito em certas primitivas portanto o 
nome dicas.

 (hint-box)
 (build-sphere 10 10) ; faz uma esfera com a bounding box

------------------------------------------------------------

(hint-multitex)
Returns void

Ajusta as dicas de render para usar multiplas texturas no estado 
de desenho corrente. Dicas de render mudam a forma como as primitivas 
são renderizadas, mas podem ter efeitos diferentes - ou nenhum 
efeito em certas primitivas portanto o nome dicas.

 (hint-multitex)
 (multitexture 0 (load-texture "tex1.png"))
 (multitexture 1 (load-texture "tex2.png"))
 (build-sphere 10 10) ; faz uma esfera com texturas sobrepostas

------------------------------------------------------------

(hint-none)
Returns void

Limpa as dicas de render no estado de desenho corrente, ou da 
primitiva pega. Isso permite que você se livre do estilo sólido 
default, mas também significa que voce pode ligar e desligar dicas 
sem usar push ou pop

 (hint-none)
 (hint-wire)
 (build-cube) ; faz um cubo vísivel apenas em wireframe

------------------------------------------------------------

(hint-origin)
Returns void

Ajusta as dicas de render para mostrar a origem espacial do objeto 
no estado de desenho corrente, ou da primitiva pega. Dicas de 
render mudam a forma como as primitivas são renderizadas, mas 
podem ter efeitos diferentes - ou nenhum efeito em certas primitivas 
portanto o nome dicas.

 (hint-origin)
 (build-sphere 10 10) ; make a sphere with the origin displayed

------------------------------------------------------------

(hint-cast-shadow)
Returns void

(nota: não implementado ainda) Ajusta as dicas de render para 
fazer sombra para o estado de desenho atual, ou a primitiva pega. 
Dicas de render podem mudar a forma que as primitivas são renderizadas, 
mas pode ter efeitos diferentes- ou nenhum efeito em certas primitivas, 
portanto o nome dica.

 (hint-origin)
 (build-sphere 10 10) ; make a sphere with the origin displayed

------------------------------------------------------------

(hint-depth-sort)
Returns void

Ajusta as dicas de render para separar em profundidade o estado 
corrente, ou a primitiva pega. Dicas de render mudam a forma como 
as primitivas são renderizadas, mas podem ter efeitos diferentes 
- ou nenhum efeito em certas primitivas portanto o nome dicas.

 (hint-depth-sort)
 (build-sphere 10 10) 

------------------------------------------------------------

(hint-ignore-depth)
Returns void

Ajusta as dicas de render para ignorar tested de profundidade 
no estado corrente de desenho, ou da primitiva pega. Dicas de 
render mudam a forma como as primitivas são renderizadas, mas 
podem ter efeitos diferentes - ou nenhum efeito em certas primitivas 
portanto o nome dicas. Essa capacidade é util para renderizar 
objetos transparentes, já que ela significa que objetos vão aparecer 
atrás de outros já renderizados.

 (clear)
 (with-state
     (hint-ignore-depth)
     (opacity 0.6)
     (with-state
         (colour (vector 1 0 0))
         (build-cube))
     (with-state
         (colour (vector 0 1 0))
         (translate (vector 1 0 0))
         (build-cube)))

------------------------------------------------------------

(hint-lazy-parent)
Returns void

Ajusta as dicas de render para prevenir esta primitiva de passar 
suas transformações a um filho. Dicas de render mudam a forma 
como as primitivas são renderizadas, mas podem ter efeitos diferentes 
- ou nenhum efeito em certas primitivas portanto o nome dicas.


------------------------------------------------------------

(hint-cull-ccw)
Returns void

Ajusta as dicas de render para prevenir esta primitiva de passar 
suas transformações a um filho. Dicas de render mudam a forma 
como as primitivas são renderizadas, mas podem ter efeitos diferentes 
- ou nenhum efeito em certas primitivas portanto o nome dicas.


------------------------------------------------------------

(texture número-id-textura)
Returns void

Ajusta a textura do estado corrente, ou da primitiva pega. Ids 
de textura podem ser geradas pela função load-texture.

 (texture (load-texture "mytexture.png"))
 (build-sphere 10 10) ; faz uma textura com mytexture.png

------------------------------------------------------------

(multitexture número-textureunit número-id-primitiva)
Returns void

Ajusta a textura do estado corrente de desenho, ou da primitiva 
pega da mesma forma que a função textura, mas permite que você 
especifique a unidade de textura (0-7) para aplicar-lá.Multitextura 
permite você aplicar diferentes texturas e coordenadas ao mesmo 
objeto de uma vez. Unidade de textura 0 é o padrão (que usa a 
pdata "t" para suas coordenadas) unidade de textura n olha pela 
pdata "tn" - ie multitexture 1 olha por "t1". Você precisa adicionar 
estas você mesmo usando (pdata-add) ou (pdata-copy). Multitexturas 
é útil quando a textura contém alpha, já que elas podem ser sobrepostas, 
por exemplo adesivos colocados em texturas de fundo. Nota: Fluxus 
precisa ser compilado usando scons MULTITEXTURE=1 para ativar 
essa capacidade.

 (define obj (build-sphere 10 10)) ; make a sphere 
 (grab obj)
 (multitexture 0 (load-texture "mytextureA.png")) 
 (multitexture 1 (load-texture "mytextureB.png"))
 (pdata-add "t1" "v")   ; make some texture coords for texture B
 (pdata-copy "t" "t1")  ; copy them from the default texture coords
 (ungrab)

------------------------------------------------------------

(print-scene-graph)
Returns void

Mostra o scene graph corrente, útil para debug.

 (print-scene-graph) ; exciting...

------------------------------------------------------------

(hide número-escondido)
Returns void

Ajusta o estado escondido para a primitiva pega (tbm afeta todas 
as primitivas filhas). Primitivas escondidas podem ser tratadas 
normalmente em todas as formas - elas apenas não serão renderizadas.

 (define obj (build-cube))
 (grab obj)
 (hide 1) ; hide this cube
 (ungrab)

------------------------------------------------------------

(selectable número-selecionável)
Returns void

Ajusta se a primitiva pega pode ser selecionada ou não.

 (define obj (build-cube))
 (grab obj)
 (selectable 0) ; agora ela nao vai ser "vista", quando chamar select
 (ungrab)

------------------------------------------------------------

(backfacecull número-ajuste)
Returns void

Liga ou desliga o corte de face-traseira. Backface culling acelera 
a renderização removendo faces não orientadas em direção da câmera. 
É ligado por padrão, mas isto não é desejado sempre, eg para poligonos 
com dupla face.

 (backfacecull 0)

------------------------------------------------------------

(shader vertexprograma-string fragmentprogram-string)
Returns void

Abre, compila e ajusta o pard de GLSL hardware shader para o estado 
de desenho atual, ou a primitiva pega. Requer OpenGL 2. Os dados 
uniformes do shader podem ser controlados via shader-set! e todas 
as pdatas são enviadas como um atributo por vértice ao shader.

 ; you need to have built fluxus with GLSL=1
 (clear)
 (fluxus-init) ; this is important to add when using shaders 
               ; at the moment, it will be moved somewhere
               ; to run automatically...
 
 (define s (with-state
     ; assign the shaders to the surface
     (shader "simple.vert.glsl" "simple.frag.glsl")
     (build-sphere 20 20)))
     
 (with-primitive s
     ; add and set the pdata - this is then picked up in the vertex shader 
     ; as an input attribute called "testcol"
     (pdata-add "testcol" "v")
     ; set the testcol pdata with a random colour for every vertex
     (pdata-map! 
         (lambda (c) 
             (rndvec)) 
         "testcol"))
     
 (define (animate)
     (with-primitive s
         ; animate the deformamount uniform input parameter 
         (shader-set! (list "deformamount" (cos (time))))))
 
 (every-frame (animate))

------------------------------------------------------------

(clear-shader-cache)
Returns número-id-primitiva



 (clear-shader-cache)

------------------------------------------------------------

(shader-set! lista-argumentos)
Returns void

Ajusta os parâmetros do shader uniforme para o shader GLSL. A 
lista contém valores pares simbolos-strings, que relacionam os 
parâmetros de shader correspondentes nomes e valores

 ; you need to have built fluxus with GLSL=1
 (clear)
 (fluxus-init) ; this is important to add when using shaders 
               ; at the moment, it will be moved somewhere
               ; to run automatically...
 
 (define s (with-state
     ; assign the shaders to the surface
     (shader "simple.vert.glsl" "simple.frag.glsl")
     (build-sphere 20 20)))
     
 (with-primitive s
     ; add and set the pdata - this is then picked up in the vertex shader 
     ; as an input attribute called "testcol"
     (pdata-add "testcol" "v")
     ; set the testcol pdata with a random colour for every vertex
     (pdata-map! 
         (lambda (c) 
             (rndvec)) 
         "testcol"))
     
 (define (animate)
     (with-primitive s
         ; animate the deformamount uniform input parameter 
         (shader-set! (list "deformamount" (cos (time))))))
 
 (every-frame (animate))

============================================================

Section: "estado-global"

Estado global é realmente qualquer coisa que controla o renderizador 
globalmente, então ele afeta todas as primitivas ou controla o 
renderizador diretamente - p.e. controle de câmera ou efeitos 
de tela cheia como "embaçamento".

------------------------------------------------------------

(clear-engine)
Returns void

Limpa o renderizador, e o sistema de física. Este comando não 
deve ser chamado diretamente, use clear ao invés, já que limpa 
algumas outras coisas também, e chama clear-engine ele mesmo.

 (clear-engine) ; woo hoo!

------------------------------------------------------------

(blur número-quantidade)
Returns void

Ajusta a opção de blur na tela inteira. Menos é mais, mas se você 
ajustar isto muito baixo vai fazer com que a edição na tela fique 
impossível de ler, então salve seus scripts primeiro :).

 (blur 0.1) ; para belos rastros

------------------------------------------------------------

(fog cor-nuvem-vetor número-quantidade número-ínicio númeor-final)
Returns void

Ajusta os paramêtros da neblina pra dar uma indicação de profundidade 
visual (perspectiva aérea no jargão de pintores). Isto pode obscurecer 
a edição na tela, então mantenha a quantidade baixa.

 (clear-colour (vector 0 0 1)) ; fica legal se o fundo de tela bate.
 (fog (vector 0 0 1) 0.01 1 100) ; neblina azul

------------------------------------------------------------

(show-axis número-mostrar)
Returns void

Mostra os eixos de origem do espaço usado;

 (show-axis 1)

------------------------------------------------------------

(show-fps número-mostrar)
Returns void

Mostra uma contaem de fps na parte inferior esquerda da tela.

 (show-fps 1)

------------------------------------------------------------

(lock-camera número-id-primitiva)
Returns void

Trava a transformação da camera em cima da transformação do objeto 
específicado. É como parentear a câmera ao objeto. Esta é a forma 
mais fácil de dirigir a câmera proceduralmente. Use um número 
id de 0 para destravar a câmera.

 (clear)
 (define obj (build-cube)) ; make a cube for the camera to lock to
 
 (with-state ; make a background cube so we can tell what's happening
     (hint-wire)
     (hint-unlit)
     (texture (load-texture "test.png"))
     (colour (vector 0.5 0.5 0.5))
     (scale (vector -20 -10 -10))
     (build-cube))
 
 (lock-camera obj) ; lock the camera to our first cube
 (camera-lag 0.1)  ; set the lag amount, this will smooth out the cube jittery movement
 
 (define (animate)
     (with-primitive obj
         (identity)
         (translate (vector (fmod (time) 5) 0 0)))) ; make a jittery movement
 
 (every-frame (animate))

------------------------------------------------------------

(camera-lag número-quantidade)
Returns void

O travamento da câmera tem um atraso construído junto o que significa 
que o movimento vai ser macio em relativo a primitiva ao qual 
ela está travada.

 (clear)
 (define obj (build-cube)) ; make a cube for the camera to lock to
 
 (with-state ; make a background cube so we can tell what's happening
     (hint-wire)
     (hint-unlit)
     (texture (load-texture "test.png"))
     (colour (vector 0.5 0.5 0.5))
     (scale (vector -20 -10 -10))
     (build-cube))
 
 (lock-camera obj) ; lock the camera to our first cube
 (camera-lag 0.1)  ; set the lag amount, this will smooth out the cube jittery movement
 
 (define (animate)
     (with-primitive obj
         (identity)
         (translate (vector (fmod (time) 5) 0 0)))) ; make a jittery movement
 
 (every-frame (animate))

------------------------------------------------------------

(load-texture pngnomedoarquivo-string)
Returns void

Carrega uma imagem do disco, converte esta a uma textura e retorna 
o número id. O carregamento da textura se dá no cache de memória, 
então repetidamente chamar esta função não vai causar que carregue 
de novo. Use force-load-texture se você está mudando a textura 
enquanto o script estiver rodando. O png pode ser RGB ou RGBA 
para usar transparência alpha.

 (texture (load-texture "mytexture.png"))
 (build-cube) ; o cubo vai ser mapeado com a textura da imagem

------------------------------------------------------------

(clear-texture-cache)
Returns void

Clears the texture cache, meaning changed textures on disk are 
reloaded.

 (clear-texture-cache)

------------------------------------------------------------

(frustum número-topo número-baixo número-esquerda número-direita)
Returns void

Ajusta o frustum da camera, e portanto o quociente de aspecto 
do frame.

 (frustum -1 1 -0.75 0.75) ; definições padrão

------------------------------------------------------------

(clip número-frente número-trás)
Returns void

Ajusta os planos de clipagem da frente e de trás para o frustum 
da câmera, portanto o ângulo de visão. Mude a distância da frente 
do clip para alterar a perspectiva de telephoto para fisheye.

 (clip 1 10000) ; default settings

------------------------------------------------------------

(ortho)
Returns void

Ajusta a projeção ortográfica - p.e. sem perspectiva.

 (ortho)

------------------------------------------------------------

(persp)
Returns void

Ajusta a projeção como perspectiva (o padrão) depois que ortho 
foi acionada.

 (persp)

------------------------------------------------------------

(set-ortho-zoom número-quantidade)
Returns void

Ajusta o nível de zoom para a projeção ortográfica.

 (set-ortho-zoom 2)

------------------------------------------------------------

(clear-colour vetor-cor)
Returns void

Ajusta a cor que vai limpar o renderizador, isto forma a cor do 
fundo da cena.

 (clear-colour (vector 1 0 0)) ; RED!!!

------------------------------------------------------------

(clear-frame número-ajuste)
Returns void

ajusta a limpeza do frame, desligado ou ligado.

 (clear-frame 0)
 (clear-frame 1)  

------------------------------------------------------------

(clear-zbuffer número-ajuste)
Returns void

Ajusta a limpeza do zbuffer, desligado ou ligado.

 (clear-zbuffer 0)
 (clear-zbuffer 1)

------------------------------------------------------------

(clear-accum número-ajuste)
Returns void

Ajusta a limpeza do buffer de acumulação, ligado ou desligado

 (clear-accum 1)

------------------------------------------------------------

(get-camera)
Returns vetor-matriz

Pega a transformação da camera. Esta é a função de baixo nível, 
use get-camera-transform ao invés.

 (get-camera)

------------------------------------------------------------

(get-locked-matrix)
Returns vetor-matriz

Pega a matriz de tranformação da câmera travada. Leva em consideração 
o atraso.

 (get-locked-matrix)

------------------------------------------------------------

(set-camera)
Returns void

Ajusta a matriz de transformação da câmera. Esta é a interface 
de baixo nível usada por set-camera-transform, a qual você devia 
usar geralmente ao invés.

 (set-camera (mtranslate (vector 0 0 -10))) 

------------------------------------------------------------

(get-projection-transform)
Returns matriz-de-projeção

Pega a matriz de projeção atual.

 (get-projection-transform)

------------------------------------------------------------

(get-screen-size)
Returns vetor-tamanho

Retorna um vetor contendo a atual largura e altura da janela

 (get-screen-size)

------------------------------------------------------------

(set-screen-size vetor-tamanho)
Returns void

Ajusta a altura e largura da janela.

 (set-screen-size (vector 10 10)) ; small window time :) 
 (set-screen-size (vector 720 576)) ; and back again!

------------------------------------------------------------

(select número-janelaposX número-janelaposY número-tamanho-pixel)
Returns número-id-primitiva

Olha na região específicada e retorna a id da primitiva mais próxima 
à renderização da câmera lá, ou 0 se não existente.

 (display (select 10 10 2))(newline)

------------------------------------------------------------

(desiredfps número-fps)
Returns void

Desacelera o renderizador de forma a não pegar 100% de cpu. Isto 
dá um limite acima na taxa de fps, o que não completamente bate 
o número dado, mas nós estamos trabalhando nisto...

 (desiredfps 100000) ; faz fluxus renderizar tão rápido quanto pode
                     ; e levar 100% de cpu.

------------------------------------------------------------

(draw-buffer nome-buffer)
Returns void

Seleciona qual buffer para desenhar, se em modo estéreo você iria 
fazer 'back-right e 'back-left

 (draw-buffer 'back)

------------------------------------------------------------

(read-buffer nome-buffer)
Returns void

Seleciona qual buffer para ler.

 (read-buffer 'back)

------------------------------------------------------------

(set-stereo-mode modo)
Returns bool

seleciona qual modo estéreo a usar, atualmente somente 'cristal-eyes 
e 'no-stereo são suportados o retorno indica se a operação foi 
bem sucedida ou não 'crystal-eyes vai retornar falso se você não 
tem uma janela estéreo.

 (set-stereo-mode 'crystal-eyes)

------------------------------------------------------------

(set-colour-mask vetor)
Returns void

Ajusta a máscara de cor dando a esta um quatérnio de booleanos 
que correspondem aos canais vermelho, verde, azul e alpha respectivamente 
depois desta operação você vai ver apenas aquelas cores que você 
ajustar como verdadeiras (isto é útil apenas para estéreo com 
óculos azul-vermelhos)

 (set-colour-mask #(#t #f #f #t))

------------------------------------------------------------

(shadow-light número-ajuste)
Returns void

Ajusta a luz para usar na geração de sombras, ajuste para 0 para 
desativar renderização de sombras.

 (shadow-light 1)

------------------------------------------------------------

(shadow-length número-ajuste)
Returns void

Ajusta o alcance do volume da renderização da sombra.

 (shadow-length 10)

------------------------------------------------------------

(shadow-debug número-ajuste)
Returns void

Liga debug na renderização do volume da sombra.

 (shadow-debug 1)

------------------------------------------------------------

(accum simbolo-modo número-valor)
Returns void

Controla o buffer de acumulação (somente chama glAccum embaixo 
do tapete). Símbolos possíveis são: accum load return add mult

 (accum 'add 1)

------------------------------------------------------------

(print-info)
Returns void



 (print-info) 

============================================================

Section: "audio"

Esta parte do fluxus é responsável por capturar o som entrando, 
e processar ele em dados harmonicos, usando fft (Fast Fourier 
Transform). As harmonicas são bandas de frequência em que o som 
é dividido, dando alguma indicação da qualidade do som. É o mesmo 
que você ve num equalisador gráfico - de fato, um dos scripts 
de exemplo (bars.scm) age como tal, e pode ser usado para testar 
se o áudio está funcionando.

 (start-audio "alsa_pcm:capture_1" 1024 44100)
 (define (animate)
		(colour (vector (gh 1) (gh 2) (gh 3))) ; make a colour from the harmonics, and set it to be the current colour 
		(draw-cube)) ; draw a cube with this colour
 (every-frame (animate))

------------------------------------------------------------

(start-audio string-porta-do-jack número-tamanho-buffer número-taxa-amostragem)
Returns void

Inicia o áudio com as configurações específicadas, você precisa 
chamar isto primeiro, ou colocar isto em $HOME/.fluxus.scm para 
chamar automaticamente na inícialização. Tenha a porta do jack 
como uma string vazia ("") e ele não vai tentar conectar em nada 
para você. Que pode então usar qjackctrl ou equivalente para fazer 
a conexão manualmente. Fluxus lè uma única fonte mono.

 (start-audio "alsa_pcm:capture_1" 1024 44100)
 EndSectionDoc
Scheme_Object *start_audio(int argc, Scheme_Object **argv)
{
	MZ_GC_DECL_REG(1);
	MZ_GC_VAR_IN_REG(0,argv); 
	MZ_GC_REG();
	
	if (!SCHEME_CHAR_STRINGP(argv[0]))scheme_wrong_type("start-audio", "string", 0, argc, argv);
	if (!SCHEME_NUMBERP(argv[1]))scheme_wrong_type("start-audio", "number", 1, argc, argv);
	if (!SCHEME_NUMBERP(argv[2]))scheme_wrong_type("start-audio", "number", 2, argc, argv);
	
	if (Audio==NULL)
	{
		char *name = scheme_utf8_encode_to_buffer(SCHEME_CHAR_STR_VAL(argv[0]),SCHEME_CHAR_STRLEN_VAL(argv[0]),NULL,0);		Audio = new AudioCollector(name,(unsigned int)scheme_real_to_double(argv[1]),(int)scheme_real_to_double(argv[2]));
	}
	
	MZ_GC_UNREG();
	return scheme_void;
}

 StartFunctionDoc-en
 gh harmonic-number
 Returns: harmonic-real
 Description:
 Fluxus converts incoming audio into harmonic frequencies, which can then be plugged into your 
 animations using this command. There are 16 harmonic bands availible, the harmonic-value argument 
 will be wrapped around if greater or less than 16, so you can use this command without worrying 
 about out of range errors.
 Example: (define (animate)
		(colour (vector (gh 1) (gh 2) (gh 3))) ; make a colour from the harmonics, and set it to be the current colour 
		(draw-cube)) ; draw a cube with this colour
 (every-frame (animate))

------------------------------------------------------------

(gh número-harmonico)
Returns void

Fluxus converte áudio entrando em frequências harmônicas, que 
pode então ser ligada em suas animações através desse comando. 
Existem 16 bandas harmônicas disponiveis, o argumento do valor-harmônico 
vai ser arredondado se maior ou menor que 16, então você pode 
usar esse comando sem se preocupar sobre erros fora do alcance.

 (define (animate)
		(colour (vector (gh 1) (gh 2) (gh 3))) ; make a colour from the harmonics, and set it to be the current colour 
		(draw-cube)) ; draw a cube with this colour
 (every-frame (animate))
 EndSectionDoc
Scheme_Object *get_harmonic(int argc, Scheme_Object **argv)
{
	MZ_GC_DECL_REG(1);
	MZ_GC_VAR_IN_REG(0,argv); 
	MZ_GC_REG();
	if (!SCHEME_NUMBERP(argv[0]))scheme_wrong_type("gh", "number", 0, argc, argv);
	if (Audio!=NULL)
	{	
		MZ_GC_UNREG();
    	return scheme_make_double(Audio->GetHarmonic((int)scheme_real_to_double(argv[0])));
	}
	MZ_GC_UNREG();
	return scheme_make_double(0);
}

 StartFunctionDoc-en
 gain gain-number
 Returns: void
 Description:
 Sets the gain level for the fft sound, it's 1 by default.
 Example: (gain 100) ; too quiet?!

------------------------------------------------------------

(gain número-gain)
Returns void

Ajusta o nível de amplificação para o som fft, é 1 por padrão.

 (gain 100) ; muito quieto?!
 EndSectionDoc
Scheme_Object *gain(int argc, Scheme_Object **argv)
{
	MZ_GC_DECL_REG(1);
	MZ_GC_VAR_IN_REG(0,argv); 
	MZ_GC_REG();
	if (!SCHEME_NUMBERP(argv[0]))scheme_wrong_type("gain", "number", 0, argc, argv);
	if (Audio!=NULL)
	{	
		Audio->SetGain(scheme_real_to_double(argv[0]));
	}
	MZ_GC_UNREG();
    return scheme_void;
}

 StartFunctionDoc-en
 process wavfile-string
 Returns: void
 Description:
 This command temporarally disables the realtime reading of the input audio stream and reads a 
 wav file instead. For use with the framedump command to process audio offline to make music 
 videos. The advantage of this is that it locks the framerate so the right amount of audio gets
 read for each frame - making syncing of the frames and audio files possible.
 Example: (process "somemusic.wav") ; read a precorded audio file

------------------------------------------------------------

(process wavfile-string)
Returns void

Este comando desativa temporariamente a leitura em tempo real 
da entrada da pista de áudio e lê um arquivo wav ao invés. Para 
usar com o comando framedump para processar audio offline para 
fazer videos musicais. A vantagem disto é que ele trava a taxa 
de quadros então a quantidade certa de áudio é lida para cada 
quadro - fazendo com que a sincrônia entre quadros e audio seja 
possível.

 (process "somemusic.wav") ; read a precorded audio file
 EndSectionDoc
Scheme_Object *process(int argc, Scheme_Object **argv)
{
	MZ_GC_DECL_REG(1);
	MZ_GC_VAR_IN_REG(0,argv); 
	MZ_GC_REG();
	if (!SCHEME_CHAR_STRINGP(argv[0]))scheme_wrong_type("process", "string", 0, argc, argv);
	char *wavname=scheme_utf8_encode_to_buffer(SCHEME_CHAR_STR_VAL(argv[0]),SCHEME_CHAR_STRLEN_VAL(argv[0]),NULL,0);	if (Audio!=NULL)
	{	
		Audio->Process(wavname);
	}
	MZ_GC_UNREG();
    return scheme_void;
}

 StartFunctionDoc-en
 smoothing-bias value-number
 Returns: void
 Description:
 A kind of weighted average for the harmonic bands which smooth them out over time. 
 This setting defaults to 1.5. The best value really depends on the quality of the music, 
 and the buffer sizes, and ranges from 0 -> 2. It's more obvious if you give it a try 
 with the bars.scm script
 Example: (smoothing-bias 0) ; no smoothing

------------------------------------------------------------

(smoothing-bias número-valor)
Returns void

Uma espécie de média balanceada para as bandas harmônicas que 
as acalmam com o tempo. Esta opção é por padrão definida como 
1.5. O melhor valor realmente depende da qualidade da música, 
e do tamanho do buffer, e varia de 0 -> 2. Fica mais óbvio se 
você tentar com o script bars.scm

 (smoothing-bias 0) ; no smoothing
 EndSectionDoc
Scheme_Object *smoothing_bias(int argc, Scheme_Object **argv)
{
	MZ_GC_DECL_REG(1);
	MZ_GC_VAR_IN_REG(0,argv); 
	MZ_GC_REG();
	if (!SCHEME_NUMBERP(argv[0]))scheme_wrong_type("smoothing-bias", "number", 0, argc, argv);
	if (Audio!=NULL)
	{	
		Audio->SetSmoothingBias(scheme_real_to_double(argv[0]));
	}
	MZ_GC_UNREG();
    return scheme_void;
}

 StartFunctionDoc-en
 update-audio
 Returns: void
 Description:
 Updates the audio subsytem. This function is called for you (per frame) in fluxus-canvas.ss.
 Example: (smoothing-bias 0) ; no smoothing

------------------------------------------------------------

(update-audio)
Returns void

Atualiza o subsistema de áudio. Esta função é chamada para você 
(por frame) no fluxus-canvas.ss


 EndSectionDoc
Scheme_Object *update_audio(int argc, Scheme_Object **argv)
{
	if (Audio!=NULL)
	{	
		Audio->GetFFT();
	}
    return scheme_void;
}

/

Scheme_Object *scheme_reload(Scheme_Env*env)
{
	Scheme_Env*menv=NULL;
	MZ_GC_DECL_REG(2);	MZ_GC_VAR_IN_REG(0,env);
	MZ_GC_VAR_IN_REG(1,menv);
	MZ_GC_REG();	 add all the modules from this extension
	menv=scheme_primitive_module(scheme_intern_symbol("fluxus-audio"), env);

	scheme_add_global("start-audio", scheme_make_prim_w_arity(start_audio, "start-audio", 3, 3), menv);
	scheme_add_global("gh", scheme_make_prim_w_arity(get_harmonic, "gh", 1, 1), menv);
	scheme_add_global("gain", scheme_make_prim_w_arity(gain, "gain", 1, 1), menv);
	scheme_add_global("process", scheme_make_prim_w_arity(process, "process", 1, 1), menv);
	scheme_add_global("smoothing-bias", scheme_make_prim_w_arity(smoothing_bias, "smoothing-bias", 1, 1), menv);
	scheme_add_global("update-audio", scheme_make_prim_w_arity(update_audio, "update-audio", 0, 0), menv);

	scheme_finish_primitive_module(menv);	
 	MZ_GC_UNREG();
	
	return scheme_void;
}

Scheme_Object *scheme_initialize(Scheme_Env*env)
{
	return scheme_reload(env);
}

Scheme_Object *scheme_module_name()
{
	return scheme_intern_symbol("fluxus-audio");

============================================================

Section: "luzes"

Sem luzes você não seria capaz de ver nada. Por sorte fluxus te 
dá uma de graça por padrão, uma luz pontual difusa e branca fixa 
à camêra. Para iluminações mais interessantes, você vai precisar 
destas funções. Usando as funções fixas de pipeline gráfico padrão, 
falando simplisticamente, OpenGL multiplica estes valores pela 
superficie do material (ajustado com comandos do estado local 
[local state] como ambient e diffuse) e o valor cor da textura 
dando a cor final.

------------------------------------------------------------

(make-light simbolo-tipo simbolo-travado-camera[cameralocked])
Returns lightid-number

Faz uma luz nova. O tipo pode ser um destes: point, directional 
ou spot. Se a string de cameralocked não estiver livre então esta 
vai ser fixa à câmera, e mexer ao redor quando você mover a câmera.

 ; turn off the main light
 (light-diffuse 0 (vector 0 0 0))
 (light-specular 0 (vector 0 0 0))
 (light-ambient 0 (vector 0 0 0))
 
 (define mylight (make-light 'point 'free))
 (light-position mylight (vector 5 2 0))
 (light-diffuse mylight (rndvec))
 (light-ambient mylight (vmul (rndvec) 0.1))
 (light-specular mylight (vmul (rndvec) 10))
 
 (with-state
     (ambient (vector 1 1 1))
     (colour (vector 1 1 1))
     (specular (vector 0.5 0.5 0.5))
     (shinyness 20)
     (build-torus 1 2 20 20)) 

------------------------------------------------------------

(light-ambient número-id-luz colour)
Returns void

Ajusta a contribuição do ambiente para a luz especificada.

 ; turn off the main light
 (light-diffuse 0 (vector 0 0 0))
 (light-specular 0 (vector 0 0 0))
 (light-ambient 0 (vector 0 0 0))
 
 (define mylight (make-light 'point 'free))
 (light-position mylight (vector 5 2 0))
 (light-diffuse mylight (rndvec))
 (light-ambient mylight (vmul (rndvec) 0.1))
 (light-specular mylight (vmul (rndvec) 10))
 
 (with-state
     (ambient (vector 1 1 1))
     (colour (vector 1 1 1))
     (specular (vector 0.5 0.5 0.5))
     (shinyness 20)
     (build-torus 1 2 20 20)) 

------------------------------------------------------------

(light-diffuse número-id-luz colour)
Returns void

Ajusta a contribuição difusa para a luz especificada.

 ; turn off the main light
 (light-diffuse 0 (vector 0 0 0))
 (light-specular 0 (vector 0 0 0))
 (light-ambient 0 (vector 0 0 0))
 
 (define mylight (make-light 'point 'free))
 (light-position mylight (vector 5 2 0))
 (light-diffuse mylight (rndvec))
 (light-ambient mylight (vmul (rndvec) 0.1))
 (light-specular mylight (vmul (rndvec) 10))
 
 (with-state
     (ambient (vector 1 1 1))
     (colour (vector 1 1 1))
     (specular (vector 0.5 0.5 0.5))
     (shinyness 20)
     (build-torus 1 2 20 20)) 

------------------------------------------------------------

(light-specular número-id-luz colour)
Returns void

Ajusta a contribuição especular para a luz específicada.

 ; turn off the main light
 (light-diffuse 0 (vector 0 0 0))
 (light-specular 0 (vector 0 0 0))
 (light-ambient 0 (vector 0 0 0))
 
 (define mylight (make-light 'point 'free))
 (light-position mylight (vector 5 2 0))
 (light-diffuse mylight (rndvec))
 (light-ambient mylight (vmul (rndvec) 0.1))
 (light-specular mylight (vmul (rndvec) 10))
 
 (with-state
     (ambient (vector 1 1 1))
     (colour (vector 1 1 1))
     (specular (vector 0.5 0.5 0.5))
     (shinyness 20)
     (build-torus 1 2 20 20)) 

------------------------------------------------------------

(light-position número-id-luz vetor-posição)
Returns void

Ajusta a posição da luz especificada. Em espaço global se livre, 
em espaço da câmera se fixa.

 ; turn off the main light
 (light-diffuse 0 (vector 0 0 0))
 (light-specular 0 (vector 0 0 0))
 (light-ambient 0 (vector 0 0 0))
 
 (define mylight (make-light 'point 'free))
 (light-position mylight (vector 5 2 0))
 (light-diffuse mylight (rndvec))
 (light-ambient mylight (vmul (rndvec) 0.1))
 (light-specular mylight (vmul (rndvec) 10))
 
 (with-state
     (ambient (vector 1 1 1))
     (colour (vector 1 1 1))
     (specular (vector 0.5 0.5 0.5))
     (shinyness 20)
     (build-torus 1 2 20 20)) 

------------------------------------------------------------

(light-spot-angle número-id-luz número-ângulo)
Returns void

Ajusta o ângulo do cone da luz spot especificada. Se não é uma 
luz spot este comando não tem nenhum efeito.

 ; turn down the main light
 (light-diffuse 0 (vector 0.1 0.1 0.1))
 (light-specular 0 (vector 0 0 0))
 (light-ambient 0 (vector 0 0 0))
 
 (define mylight (make-light 'spot 'free))
 (light-position mylight (vector (+ 4 (crndf)) (crndf) 2))
 (light-diffuse mylight (rndvec))
 (light-ambient mylight (vmul (rndvec) 0.1))
 (light-specular mylight (vmul (rndvec) 10))
 (light-spot-angle mylight (+ 5 (random 40)))
 (light-spot-exponent mylight 500)
 (light-attenuation mylight 'constant 1) 
 (light-direction mylight (vector -1 0 -1))
 
 (with-state
     (ambient (vector 1 1 1))
     (colour (vector 1 1 1))
     (specular (vector 0.5 0.5 0.5))
     (shinyness 20)
     (build-torus 1 2 20 20)
     (scale (vector 10 10 10))
     (translate (vector -0.5 -0.5 0))
     (build-seg-plane 20 20)) 

------------------------------------------------------------

(light-spot-exponent número-id-luz número-exponente)
Returns void

Ajusta a exponencial da luz spot (dispersão do cone) específicada. 
Não funciona com outra lâmpada senão a spot.

 ; turn down the main light
 (light-diffuse 0 (vector 0.1 0.1 0.1))
 (light-specular 0 (vector 0 0 0))
 (light-ambient 0 (vector 0 0 0))
 
 (define mylight (make-light 'spot 'free))
 (light-position mylight (vector (+ 4 (crndf)) (crndf) 2))
 (light-diffuse mylight (rndvec))
 (light-ambient mylight (vmul (rndvec) 0.1))
 (light-specular mylight (vmul (rndvec) 10))
 (light-spot-angle mylight (+ 5 (random 40)))
 (light-spot-exponent mylight 500)
 (light-attenuation mylight 'constant 1) 
 (light-direction mylight (vector -1 0 -1))
 
 (with-state
     (ambient (vector 1 1 1))
     (colour (vector 1 1 1))
     (specular (vector 0.5 0.5 0.5))
     (shinyness 20)
     (build-torus 1 2 20 20)
     (scale (vector 10 10 10))
     (translate (vector -0.5 -0.5 0))
     (build-seg-plane 20 20)) 

------------------------------------------------------------

(light-attenuation número-id-luz símbolo-tipo número-atenuação)
Returns void

Ajusta a atenuação da luz (decaimento com distância) da luz especificada. 
O símbolo-tipo, pode ser um dos: constant, linear ou quadratic.

 ; turn down the main light
 (light-diffuse 0 (vector 0.1 0.1 0.1))
 (light-specular 0 (vector 0 0 0))
 (light-ambient 0 (vector 0 0 0))
 
 (define mylight (make-light 'spot 'free))
 (light-position mylight (vector (+ 4 (crndf)) (crndf) 2))
 (light-diffuse mylight (rndvec))
 (light-ambient mylight (vmul (rndvec) 0.1))
 (light-specular mylight (vmul (rndvec) 10))
 (light-spot-angle mylight (+ 5 (random 40)))
 (light-spot-exponent mylight 500)
 (light-attenuation mylight 'constant 1) 
 (light-direction mylight (vector -1 0 -1))
 
 (with-state
     (ambient (vector 1 1 1))
     (colour (vector 1 1 1))
     (specular (vector 0.5 0.5 0.5))
     (shinyness 20)
     (build-torus 1 2 20 20)
     (scale (vector 10 10 10))
     (translate (vector -0.5 -0.5 0))
     (build-seg-plane 20 20)) 

------------------------------------------------------------

(light-direction número-id-luz vetor-direção)
Returns void

Ajusta a direção da luz direcional. Se não é uma luz direcional, 
este comando não tem efeito.

 ; turn down the main light
 (light-diffuse 0 (vector 0.1 0.1 0.1))
 (light-specular 0 (vector 0 0 0))
 (light-ambient 0 (vector 0 0 0))
 
 (define mylight (make-light 'spot 'free))
 (light-position mylight (vector (+ 4 (crndf)) (crndf) 2))
 (light-diffuse mylight (rndvec))
 (light-ambient mylight (vmul (rndvec) 0.1))
 (light-specular mylight (vmul (rndvec) 10))
 (light-spot-angle mylight (+ 5 (random 40)))
 (light-spot-exponent mylight 500)
 (light-attenuation mylight 'constant 1) 
 (light-direction mylight (vector -1 0 -1))
 
 (with-state
     (ambient (vector 1 1 1))
     (colour (vector 1 1 1))
     (specular (vector 0.5 0.5 0.5))
     (shinyness 20)
     (build-torus 1 2 20 20)
     (scale (vector 10 10 10))
     (translate (vector -0.5 -0.5 0))
     (build-seg-plane 20 20)) 

============================================================

Section: "matematica"

Estas funções sao optimizadas para gráficos em 3d, e a colisão 
entre ciência da computação e matemática é aparente aqui, então 
vetores representando "vectors" são nesse contexto tidos como 
3 elementos em tamanho, quaternions são vetores de tamanho 4, 
e matrizes são vetores de 16 elementos.

------------------------------------------------------------

(vmul vetor número)
Returns vetor resultante

Multiplica um vetor por um número.

 (vmul (vector 1 2 3) 2)

------------------------------------------------------------

(vadd vetor vetor)
Returns vetor resultante

Adiciona dois vetores, um ao outro.

 (vadd (vector 1 2 3) (vector 1 2 3))

------------------------------------------------------------

(vsub vetor vetor)
Returns vetor resultante

Subtrai um vetor de outro.

 (vsub (vector 1 2 3) (vector 1 2 3))

------------------------------------------------------------

(vdiv vetor número)
Returns vetor resultante

Divide um vetor por um número

 (vdiv (vector 1 2 3) 2)

------------------------------------------------------------

(vtransform vetor matriz)
Returns vetor resultante

Multiplica (transforma) um vetor por uma matriz.

 (vtransform (vector 0 1 0) (mrotate (vector 90 0 0)))

------------------------------------------------------------

(vtransform-rot vetor matriz)
Returns vetor resultante

Multiplica (transforma) um vetor por uma matriz, mas deixa de 
fora a parte de translação. Para ser usado em operações involvendo 
normais.

 (vtransform-rot (vector 0 1 0) (mrotate (vector 90 0 0)))

------------------------------------------------------------

(vnormalise vetor)
Returns vetor resultante

Retorna a forma normalisada do vetor (length=1)

 (vtransform-rot (vector 0 1 0) (mrotate (vector 90 0 0)))

------------------------------------------------------------

(vdot vetor vetor)
Returns número resultante

Retorna o produto multiplicado de dois vetores.

 (vdot (vector 0 1 0) (vector 1 0 0))

------------------------------------------------------------

(vmag vetor)
Returns número resultante

Retorna a magnitude, ou alcance do vetor

 (vmag (vector 0 1 1))

------------------------------------------------------------

(vdist vetor vetor)
Returns número resultante

Tratando os vetores como pontos, retorna a distancia entre eles.

 (vdist (vector 100 100 0) (vector 0 0 100))

------------------------------------------------------------

(vcross vetor vetor)
Returns vetor resultante

Retorna o produto cruzado entre dois vetores, resultando em um 
vetor que é perpendicular aos cruzados.

 (vcross (vector 100 100 0) (vector 0 0 100)) 

------------------------------------------------------------

(mmul vetor-matriz vetor-matriz)
Returns vetor-matriz

Multiplica duas matrizes.

 (mmul (mtranslate (vector 1 0 0)) (mrotate (vector 0 90 0)))

------------------------------------------------------------

(madd vetor-matriz vetor-matriz)
Returns vetor-matriz

Adiciona duas matrizes.

 (madd (mtranslate (vector 1 0 0)) (mrotate (vector 0 90 0)))

------------------------------------------------------------

(msub vetor-matriz vetor-matriz)
Returns vetor-matriz

Subtrai uma matriz de outra.

 (msub (mtranslate (vector 1 0 0)) (mrotate (vector 0 90 0)))

------------------------------------------------------------

(mdiv vetor-matriz vetor-matriz)
Returns vetor-matriz

Divide uma matriz por outra.

 (mdiv (mtranslate (vector 1 0 0)) (mrotate (vector 0 90 0)))

------------------------------------------------------------

(mident)
Returns vetor-matriz

Retorna a matriz identidade

 (mident)

------------------------------------------------------------

(mtranslate vetor)
Returns vetor-matriz

Retorna uma matriz representando a tranformação(translação) especificada.

 (mtranslate (vector 100 0 0))

------------------------------------------------------------

(mrotate vetor)
Returns vetor-matriz

Retorna uma matriz representando a rotação especificada. Aceita 
um vetor de angulos euler, ou um quatérnio.

 (mrotate (vector 0 45 0))

------------------------------------------------------------

(mscale vetor)
Returns vetor-matriz

Retorna uma matriz representando a escalagem especificada.

 (mscale (vector 0.5 2 0.5))

------------------------------------------------------------

(mtranspose vetor-matriz)
Returns vetor matriz

Retorna a transposta do vetor de entrada

 (mtranspose (mident))

------------------------------------------------------------

(minverse vetor-matriz)
Returns vetor-matriz

Retorna o inverso do vetor de entrada.

 (minverse (mscale (vector 0.5 2 0.5)))

------------------------------------------------------------

(maim vetor-mira vetor-acima)
Returns vetor-matriz

Retorna uma matriz representando uma rotação de mira de forma 
que o eixo X aponta pra baixo da direção de mira, e o eixo y aponta 
pra cima do vetor de cima. Provavelmente sofre do Gimbal Lock.

 (maim (vector 0 0 1) (vector 0 1 0))

------------------------------------------------------------

(qaxisangle vetor-eixo angulo)
Returns vetor-quaternion

Retorna o quatérnio representando o ângulo de rotação sobre o 
eixo especificado.

 (qaxisangle (vector 0 1 0) 45)

------------------------------------------------------------

(qmul vetor-quatérnio vetor-quatérnio)
Returns vetor-quatérnio

Multiplica um quatérnio por outro.

 (qmul (qaxisangle (vector 0 1 0) 45) (qaxisangle (vector 0 0 1) 180))

------------------------------------------------------------

(qnormalise vetor-quatérnio)
Returns vetor-quatérnio

Normalisa um quatérnio

 (qnormalise (qaxisangle (vector 0 19 0) 45))

------------------------------------------------------------

(qtomatrix vetor-quatérnio)
Returns vetor-matriz

Converte um quatérnio em uma matriz de rotação

 (qtomatrix (qaxisangle (vector 0 1 0) 45))

------------------------------------------------------------

(qconjugate vetor-quatérnio)
Returns vetor-quatérnio

Conjuga um quatérnio

 (qconjugate (qaxisangle (vector 0 1 0) 45))

============================================================

Section: "fisica"

O sistema de física em fluxus é baseado na biblioteca ODE, que 
permite a você adicionar propriedades físicas a objetos e colocá-los 
em movimento. Já que ODE foi projetada para simulações em corpos 
rígidos, estruturas são descritas em termos de objetos, dobras 
e forças. Uma explicação muito mais compreensiva destes conceitos 
pode ser encontrada na documentação de ODE, que você provavelmente 
baixou se teve que compilar fluxus, ou pode ser encontrado em 
@url{http://ode.org/ode-docs.html} Para ajudar com a depuração 
de dobras, tente chamar (render-physics) em cada frame, o que 
vai renderizar locators mostrando a você posições e eixos de dobras 
que possuem informação posicional.

------------------------------------------------------------

(collisions on/off-número)
Returns void

Habilita ou desabilita detecção de colisão. Padrão é desligado.

 (collisions 1)

------------------------------------------------------------

(ground-plane vetor-plano número-offset)
Returns void

Cria um plano passivo infinito pra usar como 'chão'.

 (ground-plane (vector 0 1 0) 0)

------------------------------------------------------------

(active-box número-id-primitiva)
Returns void

Permite que o objeto seja afetado pelo sistema físico, usando 
uma caixa como um volume limite. Como um objeto ativo, ele vai 
ser transformado por ODE. Nota: rotações só funcionam corretamente 
se você específicar suas escalagens primeiro, depois rotacionar 
(translação não importa) basicamente, ode não pode lidar com tranformações 
cortadas.

 (define mycube (build-cube))
 (active-box mycube)

------------------------------------------------------------

(active-cylinder número-id-primitiva)
Returns void

Permite que o objeto seja afetado pelo sistema físico, usando 
um cilindro como um volume limite. Como um objeto ativo, ele vai 
ser transformado por ODE. Nota: rotações só funcionam corretamente 
se você específicar suas escalagens primeiro, depois rotacionar 
(translação não importa) basicamente, ode não pode lidar com tranformações 
cortadas.

 (define mycube (build-cube))
 (active-cylinder mycube)

------------------------------------------------------------

(active-sphere número-id-primitiva)
Returns void

Permite que o objeto seja afetado pelo sistema físico, usando 
uma esfera como um volume limite. Como um objeto ativo, ele vai 
ser transformado por ODE. Nota: rotações só funcionam corretamente 
se você específicar suas escalagens primeiro, depois rotacionar 
(translação não importa) basicamente, ode não pode lidar com tranformações 
cortadas.

 (define mycube (build-cube))
 (active-sphere mycube)

------------------------------------------------------------

(passive-box número-id-primitiva)
Returns void

Permite que o objeto seja resolvido pelo sistema de física, usando 
uma caixa como o limite. Como um objeto passivo, objetos ativos 
vão colidir com ele, mas este não vai ser transformado. Nota: 
rotações só funcionam corretamente se você especificar suas transformaçoes 
de escala primeiro, depois rotacionar (translação não importa) 
basicamente, ode não pode lidar com transformações cortadas.

 (define mycube (build-cube))
 (passive-box mycube)

------------------------------------------------------------

(passive-cylinder número-id-primitiva)
Returns void

Permite que o objeto seja resolvido pelo sistema de física, usando 
um cilindro como o limite. Como um objeto passivo, objetos ativos 
vão colidir com ele, mas este não vai ser transformado. Nota: 
rotações só funcionam corretamente se você especificar suas transformaçoes 
de escala primeiro, depois rotacionar (translação não importa) 
basicamente, ode não pode lidar com transformações cortadas.

 (define mycube (build-cube))
 (passive-cylinder mycube)

------------------------------------------------------------

(passive-sphere número-id-primitiva)
Returns void

Permite que o objeto seja resolvido pelo sistema de física, usando 
uma esfera como o limite. Como um objeto passivo, objetos ativos 
vão colidir com ele, mas este não vai ser transformado. Nota: 
rotações só funcionam corretamente se você especificar suas transformaçoes 
de escala primeiro, depois rotacionar (translação não importa) 
basicamente, ode não pode lidar com transformações cortadas.

 (define mycube (build-cube))
 (passive-sphere mycube)

------------------------------------------------------------

(surface-params slip1-número slip2-número softerp-número softcfm-número)
Returns void

Ajusta alguns parâmetros globais de superfície que afetam o atrito 
e reflexão. Veja seção 7.3.7 dos docs de ODE para uma explicação 
desses parâmetros.

 (surface-params 0.1 0.1 0.1 0.1)

------------------------------------------------------------

(build-balljoint número-id-primitiva número-id-primitiva vetor-eixo)
Returns void

Cria um balljoint para conectar dois objetos (veja os docs de 
ode para uma descrição detalhada das diferenças entre os tipos 
de dobras). ODE considera as juntas(joints) serem uma restrição 
imposta entre dois objetos. Quando criando uma junção, é importante 
ter as duas primitivas sendo juntas na posição desejada antes 
de criar uma junção. Junções podem ser criadas, modificadas e 
indexadas de uma maneira similar a outras primitivas.

 (clear)
 (ground-plane (vector 0 1 0) -1)
 (collisions 1)
 
 (define shape1 (with-state 
         (translate (vector -1 0 0))
         (build-cube)))
 (active-box shape1)
 
 (define shape2 (with-state 
         (translate (vector 1 0 0))
         (build-cube)))
 (active-box shape2)
 
 (build-balljoint shape1 shape2 (vector 0 0 0)) 
 (kick shape1 (vector 0 2 0))
 
 (set-physics-debug #t)

------------------------------------------------------------

(build-fixedjoint número-id-primitiva)
Returns void

Cria uma junção para conectar um objeto ao ambiente global. Isto 
trava o objeto no lugar.

 (clear)
 (define shape1 (with-state 
         (translate (vector 0 1 0))
         (build-cube)))
 (active-box shape1)
 
 (build-fixedjoint shape1) ; not very exciting... 

------------------------------------------------------------

(build-hingejoint numero-id-primitiva1 número-id-primitiva2 vetor-ancora vetor eixo)
Returns void

Cria uma junção circular para conectar dois objetos ( veja os 
docs de ODE para uma descrição detalhada entre tipos de junções). 
ODE considera as juntas(joints) serem uma restrição imposta entre 
dois objetos. Quando criando uma junção, é importante ter as duas 
primitivas sendo juntas na posição desejada antes de criar uma 
junção. Junções podem ser criadas, modificadas e indexadas de 
uma maneira similar a outras primitivas.

 (clear)
 (ground-plane (vector 0 1 0) -1)
 (collisions 1)
 
 (define shape1 (with-state 
         (translate (vector -1 0 0))
         (build-cube)))
 (active-box shape1)
 
 (define shape2 (with-state 
         (translate (vector 1 0 0))
         (build-cube)))
 (active-box shape2)
 
 (build-hingejoint shape1 shape2 (vector 0 0 0) (vector 0 0 1)) 
 (kick shape1 (vector 0 2 0))
 
 (set-physics-debug #t)

------------------------------------------------------------

(build-sliderjoint número-id-primitiva1 número-id-primitiva2 vetor-eixo)
Returns hingeid-number

Cria uma junção deslizante entre dois objetos (veja a documentação 
de ODE para uma descrição detalhada das diferenças entre os tipos 
de conexões). ODE considera as juntas(joints) serem uma restrição 
imposta entre dois objetos. Quando criando uma junção, é importante 
ter as duas primitivas sendo juntas na posição desejada antes 
de criar uma junção. Junções podem ser criadas, modificadas e 
indexadas de uma maneira similar a outras primitivas.

 (clear)
 (ground-plane (vector 0 1 0) -1)
 (collisions 1)
 
 (define shape1 (with-state 
         (translate (vector -1 0 0))
         (build-cube)))
 (active-box shape1)
 
 (define shape2 (with-state 
         (translate (vector 1 0 0))
         (build-cube)))
 (active-box shape2)
 
 (build-sliderjoint shape1 shape2 (vector 1 0 0)) 
 (kick shape1 (vector 0 2 0))
 
 (set-physics-debug #t)

------------------------------------------------------------

(build-hinge2joint número-id-primitiva1 número-id-primitiva2 vetor-ancora vetor-eixo1 vetor-eixo2)
Returns numero-id-dobradiça(hinge)

Cria uma dobradiça de junções para conectar dois objetos (veja 
a documentação de ODE para uma descrição detalhada das diferenças 
entre os tipos de conexões). ODE considera as juntas(joints) serem 
uma restrição imposta entre dois objetos. Quando criando uma junção, 
é importante ter as duas primitivas sendo juntas na posição desejada 
antes de criar uma junção. Junções podem ser criadas, modificadas 
e indexadas de uma maneira similar a outras primitivas.

 (clear)
 (ground-plane (vector 0 1 0) -1)
 (collisions 1)
 
 (define shape1 (with-state 
         (translate (vector -1 0 0))
         (build-cube)))
 (active-box shape1)
 
 (define shape2 (with-state 
         (translate (vector 1 0 0))
         (build-cube)))
 (active-box shape2)
 
 (build-hinge2joint shape1 shape2 (vector 0 0 0) (vector 1 0 0) (vector 0 1 0)) 
 (kick shape1 (vector 0 2 0))
 
 (set-physics-debug #t)

------------------------------------------------------------

(build-amotorjoint número-id-primitiva1 número-id-primitiva2 vetor-eixo)
Returns número-id-dobradiça(hinge)

Cria uma junção com mobilidade angular para conectar dois objetos 
(veja a documentação de ODE para uma descrição detalhada das diferenças 
entre os tipos de conexões). ODE considera as juntas(joints) serem 
uma restrição imposta entre dois objetos. Quando criando uma junção, 
é importante ter as duas primitivas sendo juntas na posição desejada 
antes de criar uma junção. Junções podem ser criadas, modificadas 
e indexadas de uma maneira similar a outras primitivas.

 (clear)
 (ground-plane (vector 0 1 0) -1)
 (collisions 1)
 
 (define shape1 (with-state 
         (translate (vector -1 0 0))
         (build-cube)))
 (active-box shape1)
 
 (define shape2 (with-state 
         (translate (vector 1 0 0))
         (build-cube)))
 (active-box shape2)
 
 (build-amotorjoint shape1 shape2 (vector 1 0 0)) 
 (kick shape1 (vector 0 2 0))
 
 (set-physics-debug #t)

------------------------------------------------------------

(joint-param número-id-junção param-string número-valor)
Returns número-id-dobradiça(hinge)

Ajusta o parâmetro da junção para uma junta onde param é um dos 
seguintes: "HiStop", "Vel", "FMax", "FudgeFactor", "Bounce, "CFM", 
"StopERP", "StopCFM", "SuspensionERP", "SuspensionCFM", "Vel2", 
"FMax2". Veja Seção 7.5.1 da documentação de ODE para uma explicação 
de cada um desses parâmetros, e a qual tipos de junções eles aplicam.

 (clear)
 (ground-plane (vector 0 1 0) -1)
 (collisions 1)
 
 (define shape1 (with-state 
         (translate (vector -1 0 0))
         (build-cube)))
 (active-box shape1)
 
 (define shape2 (with-state 
         (translate (vector 1 0 0))
         (build-cube)))
 (active-box shape2)
 
 (define j (build-hinge2joint shape1 shape2 (vector 0 0 0) (vector 1 0 0) (vector 1 0 0)))
 (joint-param j "Vel2" 0.1)
 (joint-param j "FMax2" 0.2)
 (joint-param j "LoStop" -0.75)
 (joint-param j "HiStop" 0.75)
 
 (set-physics-debug #t)

------------------------------------------------------------

(joint-angles jointid-number número-angulo número-vel)
Returns void

Ajusta um novo ângulo para este joint, com uma velocidade dada 
para chegar lá.

 (clear)
 (ground-plane (vector 0 1 0) -1)
 (collisions 1)
 
 (define shape1 (with-state 
         (translate (vector -1 0 0))
         (build-cube)))
 (active-box shape1)
 
 (define shape2 (with-state 
         (translate (vector 1 0 0))
         (build-cube)))
 (active-box shape2)
 
 (define j (build-hingejoint shape1 shape2 (vector 0 0 0) (vector 0 1 0)))
 (joint-param j "FMax" 20)
 (joint-param j "LoStop" -1)
 (joint-param j "HiStop" 1)
 
 (set-physics-debug #t)
 
 (define (animate)
     (joint-angle j 0.1 (* 5 (sin (time)))))

------------------------------------------------------------

(set-max-physical número-max)
Returns void

Ajusta o máximo número de objetos que o sistema de física pode 
lidar. Quando o máximo nível foi alcançado os objetos mais antigos 
são automaticamente destroidos.

 (clear)
 (set-max-physical 200)
 
 (every-frame
     (with-state
     (translate (vector 0 5 0))
         (scale (srndvec))
         (colour (rndvec))
         (let ((ob (build-cube)))    
             (active-box ob)
             (kick ob (vmul (srndvec) 3))
             (twist ob (vmul (srndvec) 2)))))

------------------------------------------------------------

(set-mass número-id-primitiva número-massa)
Returns void

Ajusta a massa de um objeto ativo no sistema de física

 (clear)
 (ground-plane (vector 0 1 0) 0)
 (collisions 1)
 (set-max-physical 20)
 
 ; not a great example, but these boxes will have 
 ; different mass, so behave a bit differently.
 
 (every-frame
     (when (> (rndf) 0.92)
         (with-state
             (translate (vector 0 5 0))
             (scale (vmul (rndvec) 5))
             (colour (rndvec))
             (let ((ob (build-cube)))    
                 (active-box ob)
                 (set-mass ob (* (rndf) 10))
                 (kick ob (vmul (srndvec) 3))
                 (twist ob (vmul (srndvec) 2))))))    

------------------------------------------------------------

(gravity vetor-gravidade)
Returns void

Ajusta a força e direção da gravidade.

 (clear)
 (ground-plane (vector 0 1 0) 0)
 (collisions 1)
 (set-max-physical 20)
 
 (every-frame
     (begin
         (gravity (vector 0 (sin (time)) 0)) ; change gravity! :)
         (when (> (rndf) 0.92)
             (with-state
                 (translate (vector 0 5 0))
                 (scale (rndvec))
                 (colour (rndvec))
                 (let ((ob (build-cube)))    
                     (active-box ob)
                     (kick ob (vmul (srndvec) 3))
                     (twist ob (vmul (srndvec) 2)))))))

------------------------------------------------------------

(kick número-id-primitiva vetor-chute)
Returns void

Aplica força de translação ao objeto.

 (clear)
 (collisions 1)
 (set-max-physical 20)
 (gravity (vector 0 0 0)) 
 
 (every-frame
     (when (> (rndf) 0.92)
         (with-state
             (scale (rndvec))
             (colour (rndvec))
             (let ((ob (build-cube)))    
                 (active-box ob)
                 (kick ob (vmul (srndvec) 3))
                 (twist ob (vmul (srndvec) 2))))))

------------------------------------------------------------

(twist número-id-primitiva vetor-giro)
Returns void

Aplica força rotacional ao objeto

 (clear)
 (collisions 1)
 (set-max-physical 20)
 (gravity (vector 0 0 0)) 
 
 (every-frame
     (when (> (rndf) 0.92)
         (with-state
             (scale (rndvec))
             (colour (rndvec))
             (let ((ob (build-cube)))    
                 (active-box ob)
                 (kick ob (vmul (srndvec) 3))
                 (twist ob (vmul (srndvec) 2))))))

------------------------------------------------------------

(has-collided número-id-primitiva)
Returns void

Retorna verdadeiro se a primitiva pega colidiu no ultimo frame.

 (clear)
 (ground-plane (vector 0 1 0) 0)
 (collisions 1)
 (set-max-physical 20)
 
 (define ob (with-state
     (translate (vector 0 5 0))
     (build-cube)))
 
 (active-box ob)
 
 (every-frame
     (when (has-collided ob)
         (with-primitive ob
             (colour (rndvec)))))

============================================================

Section: "tartaruga"

O construtor polygonal Turtle é um modo experimental de construir 
objetos poligonais usando uma tartaruga do estilo logo no espaço 
3d. Em que você pode dirigir a tartaruga ao redor colocando vértices 
e construindo formas proceduralmente. A tartaruga também pode 
ser usa para deformar objetos poligonais existentes, fixando ela 
a objetos que você já criou.

 (define (build n)
     (turtle-reset)
     (turtle-prim 4)
     (build-loop n n)
     (turtle-build))
 
 (define (build-loop n t)
     (turtle-turn (vector 0 (/ 360 t) 0))
     (turtle-move 1)
     (turtle-vert)
     (if (< n 1)
         0
         (build-loop (- n 1) t)))

------------------------------------------------------------

(turtle-prim número-tipo)
Returns void

Inicia a construção de uma nova primitiva poligonal com a tartaruga. 
O tipo especifica o tipo da face do poligono e é um dos seguintes: 
0: triangle strip, 1: quad list, 2: triangle list, 3: triangle 
fan, 4: general polygon

 (turtle-prim 0)

------------------------------------------------------------

(turtle-vert)
Returns void

Cria um novo vértice na posição atual, ou ajusta o vértice atual 
se o construtor tartaruga estiver fixado.

 (turtle-vert)

------------------------------------------------------------

(turtle-build)
Returns void

Constrói o objeto com a lista de vértices definida e dá isto ao 
renderizador. Não tem efeito se o construtor tartaruga estive 
fixado a uma primitiva.

 (define mynewshape (turtle-build))

------------------------------------------------------------

(turtle-move número-distância)
Returns void

Move a tartaruga pra frente na sua orientação atual.

 (turtle-move 1)

------------------------------------------------------------

(turtle-push)
Returns void

O construtor tartaruga tem sua própria pilha de transformações, 
Push lembra a posição atual e orientação.

 (turtle-push)

------------------------------------------------------------

(turtle-pop)
Returns void

O construtor tartaruga tem sua própria pilha de transformações. 
Pop esquece a posição atual e orientação, e vai de volta para 
o estado do último push.

 (turtle-pop)

------------------------------------------------------------

(turtle-turn vetor-rotação)
Returns void

Rotaciona a orientação da tartaruga com o ângulos euler fornecidos 
(rotações em x, y e z)

 (turtle-turn (vector 45 0 0))

------------------------------------------------------------

(turtle-reset)
Returns void

Reinicia a atual posição e rotação da tartaruga para a origem.

 (turtle-reset)

------------------------------------------------------------

(turtle-attach número-id-primitiva)
Returns void

Anexa a tartaruga a uma primitiva poligonal existente. Isso significa 
que você será capaz de deformar pontos de objetos existentes usando 
o construtor tartaruga.

 (define myshape (build-sphere 10 10))
 (turtle-attach myshape)

------------------------------------------------------------

(turtle-skip número-contador)
Returns void

Quando anexado, faz com que a tartaruga pule vértices. Este valor 
pode ser negativo, o que vai resultar na tartaruga escrevendo 
para vértices anteriores.

 (turtle-skip -1)

------------------------------------------------------------

(turtle-position)
Returns void

Quando anexado, retorna o índice atual da pdata que a tartaruga 
esta escrevendo para.

 (display (turtle-position))(newline)

------------------------------------------------------------

(turtle-seek número-posição)
Returns void

Quando anexado, ajusta o índice absoluto da pdata que a tartaruga 
está escrevendo para.

 (turtle-seek 0)

============================================================

Section: "renderer"

Estes comandos são os controladores de baixo nível do renderizador. 
Você não deveria usá-los a menos que esteja implementando um renderizador 
do fluxus fora da interface scratchpad.

------------------------------------------------------------

(make-renderer)
Returns número-render-id

Faz um novo renderizador de gráfico da cena [scenegraph]

 (make-renderer) 

------------------------------------------------------------

(renderer-grab número-id-renderizador)
Returns void

Faz este renderizador o atual contexto para comandos.

 (renderer-grab renderer) 

------------------------------------------------------------

(renderer-ungrab)
Returns void

Pop o contexto da pilha do renderizador.

 (renderer-grab renderer) 

------------------------------------------------------------

(fluxus-render)
Returns void

Limpa o buffer de fundo, e renderiza tudo.

 (fluxus-render)

------------------------------------------------------------

(tick-physics)
Returns void

Atualiza o sistema de física.

 (tick-physics) 

------------------------------------------------------------

(render-physics)
Returns void

Renderiza o sistema de física (para gráficos ajudantes).

 (render-physics)

------------------------------------------------------------

(reset-renderers)
Returns void

Deleta todos os renderizadores e faz um novo como padrão.

 (reset-renderers)

------------------------------------------------------------

(reshape número-largura número-altura)
Returns void

Chama reshapa no render atual.

 (reshape 100 100) 

------------------------------------------------------------

(fluxus-init)
Returns void

Inicia todo o sistema de renderização, só precisa ser chamado 
uma vez.

 (fluxus-init)

============================================================

Section: "blocos-de-construcao-fluxus"

Um novo e pouco testado ajuste de estruturas de controle de ordem 
maior para manipular objetos e estados e estado no fluxus de uma 
maneira mais limpa e segura.

------------------------------------------------------------

(with-state expressão ...)
Returns resultado da última expressão

Encapsula mudanças locais, e remove a necessidade por push e pop.

 ; state hierachy, by nesting with-state:
 (with-state
    (hint-vertcols)
    (colour (vector 0 0 1))
    (with-state
        (translate (vector 1 0 0))
        (build-sphere 10 10))
     (build-torus 1 2 30 30))

 ; making primitives:
 (define my-torus (with-state
    (hint-vertcols)
    (colour (vector 0 0 1))
    (build-torus 1 2 30 30)))

------------------------------------------------------------

(with-primitive primitiva expressão ...)
Returns resultado da última expressão

Encapsula mudanças de estado das primitivas

 

------------------------------------------------------------

(pdata-map! procedimento nome-pdata-leitura/escrita nome-pdata-leitura ...)
Returns void

Uma estrutura de controle de alto nível para simplificar a passagem 
sobre uma array de pdata para deformação de primitivas. Deve ser 
mais fácil e menos sujeito a erros do que fazer o loop manualmente. 
Escreve na primeira array pdata.

 (clear)
 (define my-torus (build-torus 1 2 30 30))
 
 (with-primitive my-torus
   (pdata-map!
      (lambda (position)
          (vadd position (vector (flxrnd) 0 0))) ; jitter the vertex in x
      "p")) ; read/write the position pdata array
 
 (with-primitive my-torus
   (pdata-map!
      (lambda (position normal)
          (vadd position normal)) ; add the normal to the position (expand the object)
      "p" "n")) ; read/write the position pdata array, read the normals array

------------------------------------------------------------

(pdata-index-map! procedimento nome-pdata-leitura/escrita nome-pdata-leitura ...)
Returns void

Uma estrutura de controle de alto nível para simplificar a passagem 
sobre uma array de pdata para deformação de primitivas. Mesmo 
que pdata-map! exceto que pdata-index-map! fornece o índice do 
elemento pdata atual como o primeiro argumento ao "procedimento".

 (clear)
 (define my-torus (build-torus 1 2 30 30))
 
 (with-primitive my-torus
   (pdata-index-map!
      (lambda (index position)
          (vadd position (vector (gh index) 0 0))) ; jitter the vertex in x
      "p")) ; read/write the position pdata array

------------------------------------------------------------

(pdata-fold procedimento valor-inicial nome-pdata-leitura ...)
Returns resultado do procedimento de dobragem sobre a array pdata

Uma estrutura de controle de alto nível para fazer cálculos em 
arrays pdata. Roda o procedimento sobre cada elemento pdata acumulando 
o resultado. Deve ser mais fácil e menos sujeito a erros que percorrer 
manualmente.

 (define my-torus (build-torus 1 2 30 30))
 
 ; find the centre of the primitive by averaging 
 ; the points position's together
 (let ((centre 
        (with-primitive my-torus
                        (vdiv (pdata-fold
                               vadd
                               (vector 0 0 0)
                               "p") (pdata-size)))))
   
   (display centre)(newline))  

------------------------------------------------------------

(pdata-index-fold procedimento valor-inicial nome-pdata-leitura ...)
Returns resultado do procedimento de dobragem sobre a array pdata

Igual a pdata-fold exceto que passa o índice do elemento pdata 
atual como o primeiro parâmetro de "procedimento".

 (define my-torus (build-torus 1 2 30 30))
 
 ; can't think of a good example for this yet...
 (let ((something 
        (with-primitive my-torus
                        (vdiv (pdata-index-fold
                               (lambda (index position ret)
                                   (vadd ret (vmul position index)))
                               (vector 0 0 0)
                               "p") (pdata-size)))))
   
   (display something)(newline))  

============================================================

Section: "scratchpad"

O scratchpad é o editor fluxus e a janela gl.

------------------------------------------------------------

(every-frame função-callback)
Returns void

Ajusta uma função pra ser chamada todo o tempo em que o render 
está para desenhar um novo quadro.

 (define (myfunc)
     (colour (rndvec))
     (draw-torus))

 (every-frame (myfunc)) 

------------------------------------------------------------

(clear)
Returns void

Limpa o renderizador de todos os objetos e luzes. Limpa o sistema 
de física e re-inicializa a chamada de volta em every-frame. Geralmente 
uma boa coisa a fazer é colocar isto no ínicio dos scripts pra 
ter certeza que tudo esta limpo cada vez que você chamar a execução.

 (clear) ; sem isso a gente ia acumular um novo cubo toda vez que F5 fosse pressionado
 (build-cube) 

------------------------------------------------------------

(start-framedump string-nome string-tipo)
Returns void

Inicia a gravação de quadros no disco. Tipo pode ser um dos: "tif", 
"jpg" ou "ppm". Nomes dos arquivos são construidos junto com o 
número do quadro adicionado, prefixado em 5 zeros.

 (start-framedump "frame" "jpg")

------------------------------------------------------------

(end-framedump)
Returns void

Para a gravação de quadros para o disco.

 (end-framedump)

------------------------------------------------------------

(set-physics-debug boolean)
Returns void

Call with #t to turn on debug rendering for the physics.

 (set-physics-debug #t)

------------------------------------------------------------

(override-frame-callback função-callback)
Returns void

Permite que você substitua a chamada de volta (callback) do quadro, 
para controlar o loop de renderização do fluxus de uma forma mais 
detalhada.

 (override-frame-callback myfunc)
 (override-frame-callback default-fluxus-frame-callback) ; set it back again...

