\input texinfo @c -*-texinfo-*- 

@setfilename fluxus.info
@settitle  Fluxus documentation v0.12
@afourpaper 

@node Top
@top Fluxus 0.12

@image{images/splash}

@menu
* Introduction:: 
* Quickstart::  For the impatient
* User Guide:: User guide to the fluxus application
* Scheme::  An intro into scheme programming
* Statemachine:: The Fluxus State Machine
* About Primitives:: Primitives are rendererable objects
* Deforming:: Deforming primitives 
* Shaders:: Hardware shading support 
* Turtle Builder:: Turtle builder 
* Making Movies:: Making Movies
* Fluxus scratchpad and modules::  What fluxus comprises, and how to use it with DrScheme
* Functions::  A complete function reference
@end menu

@node Introduction
@chapter Introduction

A graphical livecoding environment for Scheme. Builds for Linux or OSX, and released under the GPL licence.

Fluxus reads live audio or OSC network messages which can be used as a source of animation data for realtime performances or installations. Keyboard or mouse input can also be read for simple games development, and a physics engine is included for realtime simulations of rigid body dynamics.

The built in scheme code editor runs on top of the renderer, which means you can edit the scripts while they are running. As well as making livecoding possible, it's also gives you a very fast feedback way of experimenting or learning about graphics and animation.

Fluxus lends itself to procedural modelling and animation. There is an expermental procedural modelling tool, and full support for texturing, basic material properties and hardware shading.

Fluxus consists of an application, which embeds a Scheme interpreter, called the fluxus scratchpad, and a set of Scheme modules which extend an interpreter with graphics commands.

@node Quickstart
@chapter Quickstart

For a quick introduction to fluxus, try entering the following command once you have started the fluxus scratchpad and see the yellow cursor in the top left of the screen.

@lisp
(build-cube)
@end lisp

Now press f5 - the script will be executed, and a white cube should appear in the centre of the screen. Use the mouse and to move around the cube, pressing the buttons to get different movement controls.

To animate this cube, it will have to be called a little differently:

@lisp
(start-audio "jack-port-to-read-sound-from" 256 44100) ; buffersize and samplerate need to match jack's

(define (render)
    (colour (vector (gh 1) (gh 2) (gh 3)))
    (draw-cube))

(every-frame (render))
@end lisp

Briefly, the @code{(every-frame)} function takes a function which is called once per frame by fluxus's internal engine. In this case it calls a function that sets the current colour using harmonics from the incoming sound with the @code{(gh)} - get harmonic - function; and draws a cube. Note that this time we use @code{(draw-cube)} not @code{(build-cube)}. The difference will be explained below.

If everything goes as planned, and the audio is connected with some input - the cube will flash in a colourful manner along with the sound.


@node User Guide
@chapter User Guide

When using the fluxus scratchpad, the idea is that you only need the one window to build scripts, or play live. f5 is the key that runs the script when you are ready.  Selecting some text (using shift) and pressing f5 will execute the selected text only. This is handy for reevaluating functions without running the whole script each time.

@section Camera control

The camera is controlled by moving the mouse and pressing mouse buttons.

@itemize @bullet
@item Left mouse button: Rotate
@item Middle mouse button: Move
@item Right mouse button: Zoom
@end itemize

@section Workspaces

The script editor allows you to edit 9 scripts simultaneously by using workspaces. To switch workspaces, use ctrl+number key. Only one can be run at once though, hitting f5 will execute the currently active workspace script.  Scripts in different workspaces can be saved to different files, by using the @code{(save-name)} call in the different workspaces (see below).

@section The REPL

If you press ctrl and 0, instead of getting another script workspace, you will be presented with a Read Evaluate Print Loop interpreter, or repl for short. This is really just an interactive interpreter similar to the commandline, where you can enter scheme code for immediate evaluation. This code is evaluated in the same interpreter as the other scripts, so you can use the repl to debug or inspect global variables and functions they define. This window is also where error reporting is printed, along with the terminal window you started fluxus from.

@section Keyboard commands

@itemize @bullet
@item ctrl-f : Fullscreen mode.
@item ctrl-w : Windowed mode.
@item ctrl-h : Hide/show the editor.
@item ctrl-l : Load a new script (navigate with cursors and return).
@item ctrl-s : Save current script.
@item ctrl-d : Save as - current script (opens a filename dialog).
@item ctrl-1 to 9 : Switch to selected workspace.
@item ctrl-0 : Switch to the REPL.
@item F1 : Mouse moves the scene camera.
@item F2 : Mouse moves the editor camera.
@item F3 : Resets the scene camera.
@item F4 : Resets the editor camera.
@item F5 : Execute the selected text, or all if none is selected.
@item F9 : Randomise the text colour (aka the panic button)
@item F10 : Make text thinner (these two are for use with projectors to make the text easier to read)
@item F11 : Make text thicker
@item Escape : Editor panic button, resets the cursor if it gets stuck (let me know if you need to use this)
@end itemize

@node Scheme
@chapter Scheme

@section Introduction

Scheme is a programming language invented by Jerald J. Sussman and Guy L. Steel Jr. in 1975. Scheme is based on another language - Lisp which dates back to the fifties. It is a high level language, which means it is biased towards human, rather than machine understanding. The fluxus scratchpad embeds a Scheme interpreter (it can run Scheme programs) and the fluxus modules extend the Scheme language with commands for 3D computer graphics.

This document gives a basic introduction to Scheme programming, and computer graphics techniques - no prior experience with programming languages is assumed. We'll start by going through some language basics, which are easiest done in the fluxus scratchpad using the console mode - launch fluxus and press ctrl 0 to switch to console mode. 

@section Scheme as calculator

Languages like Scheme are composed of two things - operators (things which do things) and values which operators operate upon. Operators are always specified first in Scheme, so to add 1 and 2, we do the following:

@lisp
fluxus> (+ 1 2)
3
@end lisp

This looks pretty odd to begin with, and takes some getting used to, but it means the language has less rules and makes things easier later on. It also has some other benefits, in that to add 3 numbers we can simply do:

@lisp
fluxus> (+ 1 2 3)
6
@end lisp

It is common to "nest" the brackets inside one another, for example:

@lisp
fluxus> (+ 1 (* 2 3))
7
@end lisp

@section Naming values

If we want to specify values and give them names we can use the Scheme command "define":

@lisp
fluxus> (define size 2)
fluxus> size
2
fluxus> (* size 2)
4
@end lisp

Naming is arguably the most important part of programming, and is the simplest form of what is termed "abstraction" - which means to separate the details (e.g. the value 2) from the meaning - size. This is not important as far as the machine is concerned, but it makes all the difference to you and other people reading code you have written. In this example, we only have to specify the value of size once, after that all uses of it in the code can refer to it by name - making the code much easier to understand and maintain.

@section Naming procedures

Naming values is very useful, but we can also name operations (or collections of them) to make the code simpler for us:

@lisp
fluxus> (define (square x) (* x x))
fluxus> (square 10)
100
fluxus> (square 2)
4
@end lisp

Look at this definition carefully, there are several things to take into account. Firstly we can describe the procedure definition in English as:  To (define (square of x) (multiply x by itself)) 
The "x" is called an argument to the procedure, and like the size define above - it's name doesn't matter to the machine, so:

@lisp
fluxus> (define (square apple) (* apple apple))
@end lisp

Will perform exactly the same work. Again, it is important to name these arguments so they actually make some sort of sense, otherwise you end up very confused.
Now we are abstracting operations (or behaviour), rather than values, and this can be seen as adding to the vocabulary of the Scheme language with our own words, so we now have a square procedure, we can use it to make other procedures:

@lisp
fluxus> (define (sum-of-squares x y) 
		(+ (square x) (square y)))
fluxus> (sum-of-squares 10 2)
104
@end lisp

The newline and whitespace tab after the define above is just a text formatting convention, and means that you can visually separate the description and it's argument from the internals (or body) of the procedure. Scheme doesn't care about whitespace in it's code, again it's all about making it readable to us.


@node Statemachine
@chapter  The Fluxus State Machine

The state machine is the key to understanding how fluxus works, all it really means is that you can call functions which change the current context which has an effect on subsequent functions. This is a very efficient way of describing things, and is built on top of the OpenGl api, which works in a similar way.  For example, in a function called every frame:

@lisp
(colour (vector 1 0 0))
(draw-cube)
(colour (vector 0 1 0))
(draw-cube)
@end lisp

Will draw a red cube, then a green cube (in this case, you can think of the @code{(colour)} call as changing a pen colour before drawing something).  States can also be stacked, for example:

@lisp
(colour (vector 1 0 0))
(push)
	(colour (vector 0 1 0))
	(draw-cube)
(pop)
(draw-cube)
@end lisp

will draw a green, then a red cube. the @code{(push)} command stores the current state, and adds a copy to the top of the stack. @code{(pop)} retrieves the previous state and deletes the current one (so changes to the state between the push and the pop are lost)

@section The Scenegraph 

Both examples so far have used what is known as immediate mode, you have one state stack, the top of which is the current context, and everything is drawn once per frame. fluxus contains a structure known as a scenegraph for storing objects and their render states.

Time for another example:

@lisp
(colour (vector 1 0 0))
(build-cube)
(colour (vector 0 1 0))
(build-cube)
@end lisp

The only difference between this and the first example is the use of (build-cube) instead of (draw-cube). the build functions create a primitive object, copy the current renderstate and add the information into the scenegraph in a container called a scenenode.

The (build-*) functions return object ID's (just numbers really) which enable you to do things to the scene node after it's been created. you can now specify  objects like this:

@lisp
(define myob (build-cube))
@end lisp

The cube will now be persistant in the scene until destroyed with

@lisp
(destroy myob)
@end lisp

If you want to modify a objects renderstate after it's been loaded into the scenegraph, you can use the grab function to temporarially set the current context to that of the object. use ungrab to turn fluxus back into normal state stack mode. this allows you to animate objects stored in the scenegraph, for instance:

@lisp
(colour (vector 1 1 1))
(define obj1 (build-cube))
(push)
    (translate (vector 2 0 0))
    (define obj2 (build-cube))
(pop)
@end lisp

--->8---

; in a function called per frame

@lisp
(grab obj1)
(rotate (vector 0 1 0))
(ungrab)

(grab obj2)
(rotate (vector 0 0 1))
(ungrab)
@end lisp

Do not call push or pop while an object is grabbed, it will have no effect - fluxus will print out a warning in this case.

The scenegraph also enables you to parent objects to one another, using the renderstate's parent setting. this is only effective before an object is loaded into the scenegraph, setting it afterwards via a grabbed state will be ignored:

@lisp
(colour (vector 1 1 1))
(define a (build-cube))

(push)
    (parent a)
    (translate (vector 0 2 0))
    (define b (build-cube))
(pop)

(push)
    (parent b)
    (translate (vector 0 2 0))
    (define c (build-cube))
(pop)
@end lisp

Creates three cubes, all attached to each other in a chain. transforms for object a will be passed down to b and c, transforms on b will effect c blah.

Destroying a object in such a hierachy will in turn destroy all child objects parented to it.

@node About Primitives
@chapter About Primitives 

Primitives are objects that you can render. There isn't really much else in a fluxus scene, except lights, a camera and lots of primitives. @xref{Primitives}, to see all the types of primitives you can render.

@section Retained Mode
    
The normal way to create a primitive is to call it's build function and then use it's returned ID (either directly, or by grabbing) to modify it later. 

@lisp
(define myobj (build-cube))
(grab myobj)
(colour (vector 1 0 0))
(ungrab) ; always remember to ungrab...	
@end lisp

@section Primitive Data [aka. pdata]

Each primitive is made up of arrays of data that describe it's shape and surface properties. The data is always stored per-vertex, and is created when you call the build function. You do not have to know anything about this data to use primitives, but it means you can modify or deform them in a more detailed way than using functions we've already looked at, and some primitives are only useful if pdata is used to control them.

So, for example @code{(build-sphere)} creates a polygonal object with a spherical distribution of vertex point data, surface normals at every vertex and texture coordinates, so you can wrap a texture around the primitive. This data (primitive data, or pdata for short) can be read and written to by your scripts, using the pdata-set and pdata-get commands (which operate on the currently grabbed object).  @xref{PrimitiveData}, function reference for more detail.

@lisp
(pdata-set name vertnumber vector)
@end lisp
Sets the data on the currently (grab)ed object to the input vector

@lisp
(pdata-get name vertnumber)
@end lisp
Returns the vector from the pdata on the currently (grab)ed object

@lisp
(pdata-size)
@end lisp
Returns the size of the pdata on the currently (grab)ed object (the number of verts)

The name describes the data we want to access, for instance "p" contains the vertex positions:

So, some examples to make sense of this:

@lisp
(pdata-set "p" 0 (vector 0 0 0))
@end lisp

Sets the first point in the primitive to the origin (not all that useful)

@lisp
(pdata-set "p" 0 (vadd (pdata-get "p" 0) (vector 1 0 0)))
@end lisp

The same, but sets it to the original position + 1 in the x offsetting the position is more useful as it constitutes a deformation of the original point. (@xref{Deforming}, for more info on deformations)

The pdata availible depends on the type of the primitive.

Polygonal based primitives (Cube, Sphere, Cylinder, Plane, Text)

@lisp
Positions:      "p" vector
Normals:        "n" vector
Texture coords: "t" vector
Vertex colours: "c" colour
@end lisp

NURBS based primitives (NURBSSphere, NURBSPlane)

@lisp
Positions:      "p" vector
Normals:        "n" vector
Texture coords: "t" vector
@end lisp

@subsection Particle primitive pdata

@lisp
Positions:      "p" vector
Colours:        "c" colour
Sizes:          "s" vector
@end lisp

@subsection Line primitive pdata

@lisp
Positions:      "p" vector
Width:          "w" float 
@end lisp

@subsection Blobby primitive pdata

Each element of pdata corresponds to an influence.

@lisp
Positions:      "p" vector
Strength:       "s" float 
Colour:         "c" vector 
@end lisp

@subsection Pixel primitive pdata

@lisp
Colour:      "c" vector
Alpha:       "a" float 
@end lisp

@section Topology and pdata

The order and meaning of the vertex pdata depends on the exact primitive, and in the case of polygonal objects, the topology of the polygons.

So a polygon primitive built from triangle lists will have the following ordering of it's pdata:

(This is a really bad way of describing something which is easier done with a picture, see your OpenGL manual, or search the net for "OpenGL Primitives" :)

@lisp
pdata index 0 : face 0 vert 0
pdata index 1 : face 0 vert 1
pdata index 2 : face 0 vert 2
pdata index 3 : face 1 vert 0
pdata index 4 : face 1 vert 1
pdata index 5 : face 1 vert 2

Quad lists:

pdata index 0 : face 0 vert 0
pdata index 1 : face 0 vert 1
pdata index 2 : face 0 vert 2
pdata index 3 : face 0 vert 3
pdata index 4 : face 1 vert 0
pdata index 5 : face 1 vert 1

Triangle strip:

pdata index 0 : face 0 vert 0 
pdata index 1 : face 0 vert 1 & face 1 vert 0 
pdata index 2 : face 0 vert 2 & face 1 vert 1 & face 2 vert 0
pdata index 3 : face 1 vert 2 & face 2 vert 1 & face 3 vert 0 
pdata index 4 : face 2 vert 2 & face 3 vert 1 & face 4 vert 0
pdata index 5 : face 3 vert 2 & face 4 vert 1 & face 5 vert 0     

Triangle fan:

pdata index 0 : vert 0 for all faces
pdata index 1 : face 0 vert 1 
pdata index 2 : face 0 vert 2 & face 1 vert 1
pdata index 3 : face 1 vert 2 & face 2 vert 1
pdata index 4 : face 2 vert 2 & face 3 vert 1
pdata index 5 : face 3 vert 2 & face 4 vert 1

Polygon (the easy one):

pdata index 0 : vert 0
pdata index 1 : vert 1
pdata index 2 : vert 2
pdata index 3 : vert 3
pdata index 4 : vert 4
pdata index 5 : vert 5
@end lisp

This lookup is the same for all the pdata on a particular primitive - vert positions, normals, colours and texture coordinates.

Although this implicit topology means the primitive is optimised to be very quick to render, it costs some memory as points are duplicated. This is a standard tradeoff, the most optimal poly topology are triangle strips, as the duplication gets less, depending on how long your strips get.

The topologies for the various polygon primitives are as follows:

@lisp
cube: quad list
plane: quad list
text: quad list
sphere: triangle list
cylinder: triangle list
@end lisp

@section Nurbs topology

Nurbs pdata are much simpler to deal with, as the topology is just a patch grid for both spheres and subdivided planes. For example:

@lisp
(build-nurbs-plane 5 5)
@end lisp
Would give you a topology like this:

@lisp
0   1   2   3   4 
5   6   7   8   9  
10  11  12  13  14
15  16  17  18  19 
20  21  22  23  24 
@end lisp

@section Instancing

Sometimes retained mode primitives can be unwieldy to deal with. For instance, if you are rendering thousands of identical objects, or doing things with recursive graphics, where you are calling the same primitive in lots of different states - keeping track of all the IDs would be annoying to say the least.

This is where instancing is helpful, all you call is:

@lisp
(draw-instance myobj)
@end lisp

Will redraw any given object in the current state (immediate mode).
An example:

@lisp
(define myobj (build-nurbs-sphere 8 10)) ; make a sphere

(define (render-spheres n)
	(push)
	(translate (vector n 0 0)) ; move in x
	(draw-instance myobj)       ; stamp down a copy
	(pop)
	(if (< n 0)
		0
		(render-spheres (- n 1)))) ; recurse!

(every-frame (render-spheres 10)) ; draw 10 copies
@end lisp

@section Built In Immediate Mode Primitives

To make life even easier than having to instance primitives, there are some built in primitives that can be rendered at any time, without being built:

@lisp
(draw-cube)
(draw-sphere)
(draw-plane)
(draw-cylinder)
@end lisp

So the it makes the code above simpler:

@lisp
(define (render-spheres n)
	(push)
    (translate (vector n 0 0)) ; move in x
	(draw-sphere)              ; render a new sphere
	(pop)
	(if (< n 0)
		0
		(render-spheres (- n 1)))) ; recurse!

(every-frame (render-spheres 10)) ; draw 10 copies
@end lisp

These built in primitives are very restricted in that you can't edit them 
or change their resolution settings etc, but they are handy to use for quick 
scripts with simple shapes.

@node Deforming
@chapter  Deforming primitives 

Deformation in this chapter signifies various operations. It can involve changing the shape of a primitive in a way not possible via a transform (ie bending, warping etc) or modifying texture coordinates or colours to achieve a per-vertex effect. (Deformation in this way is also the only way to get particle primitives to do anything interesting).

Deforming is all about pdata, so, to deform an entire object, you do something like the following:

@lisp                     
(hint-unlit)
(hint-wire)
(line-width 4)
(define myobj (build-sphere 10 10))

(define (deform n)
    (pdata-set "p" n (vadd  (pdata-get "p" n)                ; the original point, plus
        (vmul (vector (flxrnd) (flxrnd) (flxrnd)) 0.1)))     ; a small random vector
    (if (< n 0)
        0
        (deform (- n 1))))
    
(grab myobj)
(deform (pdata-size)) ; for every point
(ungrab)
@end lisp                     

@image{images/deform}
A sphere with randomly jittered vertices

When deforming geometry, moving the positions of the vertices is not usually enough, the normals will need to be updated for the lighting to work correctly. 

@lisp                     
(recalc-normals smooth)
@end lisp                     
Will regenerate the normals for polygon and nurbs primitives based on the vertex positions. not particually fast (it is better to deform the normals in your script if you can) and only works on poly primitives of type QUADS and TRILIST. if smooth is 1, the face normals are averaged with the coincident face normals to give a smooth appearance

When working on polygon primitives it will cache certain results, so it will be a lot slower on the first calculation than subsequent calls on the same primitive.

@section User PData

As well as the standard information that exists in primitives, fluxus also allows you to add your own per vertex data to the primitive. User pdata can be written or read in the same way as the built in pdata types.

@lisp                     
(pdata-add name type)
@end lisp                     
Where name is a string with the name you wish to call it, and type is a one character string consisting of:

@lisp                     
f : float data
v : vector data 
c : colour data
m : matrix data
@end lisp                     

@lisp                     
(pdata-copy source destination)
@end lisp                     
This will copy a array of pdata, or overwrite an existing one with if it already exists.

So, adding your own storage for data on primitives means you can use it as a fast way of reading and writing data, even if the data doesn't directly affect the primitive.

@lisp                     
(define particle-count 1000)

(define (init n)                                       ; setup our pdata arrays
    (pdata-set "vel" n (vmul (vsub (vector (flxrnd) (flxrnd) (flxrnd)) 
        (vector 0.5 0.5 0.5)) 0.1))                    ; randomise the velocity
    (pdata-set "c" n (vector (flxrnd) (flxrnd) 1))     ; randomise the colour
    (if (< n 0)
        0
        (init (- n 1))))

(define (update n)
    (pdata-set "vel" n (vadd (pdata-get "vel" n) (vector 0 -0.001 0))) ; add some gravity
    (pdata-set "p" n (vadd (pdata-get "p" n) (pdata-get "vel" n)))     ; add velocity to the position
    (if (< n 0)
        0
        (update (- n 1))))

(define (render)
    (grab ob)
    (update (pdata-size))                              ; update the particles
    (ungrab))

; setup the scene
(clear)
(show-fps 1)
(point-width 4)
(hint-anti-alias)

; build our particle primitive
(define ob (build-particles particle-count))

(grab ob)
(pdata-add "vel" "v") ; add the velocity user pdata of type vector
(init (pdata-size))   ; initialise the pdata arrays
(ungrab)
(blur 0.1)

(every-frame (render))
@end lisp                     

@image{images/explosion}
a particle explosion. finally - particles are useful for something

@section PData Operations

Pdata Operations are a optimisation which takes advantage of the nature of these storage arrays to allow you to process them with a single call to the scheme interpreter. This makes deforming primitive much faster as looping in 
the scheme interpreter is slow, and it also simplifies your scheme code.

@lisp                     
(pdata-op operation pdata operand)
@end lisp                     
Where operation is a string identifier for the intended operation (listed below) and pdata is the name of the target pdata to operate on, and operand is either a single data (a scheme number or vector (length 3,4 or 16)) or a name of another 
pdata array.

If the @code{(update)} and @code{(render)} functions in the script above are 
changed to the following:

@lisp                     
(define (update)
	(pdata-op "+" "vel" (vector 0 -0.002 0)) ; add this vector to all the velocities
    (pdata-op "+" "p" "vel")) ; add all the velocities to all the positions

(define (render)
    (grab ob)
    (update)
    (ungrab))
@end lisp                     
	
On my machine, this script runs over 6 times faster than the first version. 

@code{(pdata-op)} can also return information to your script from certain functions called on entire pdata arrays. 

Pdata operations

@lisp                     
"+"       : addition
"*"       : multiplication
"sin"     : writes the sine of one float pdata array into another
"cos"     : writes the cosine of one float pdata array into another
"closest" : treats the vector pdata as positions, and if given a single vector, 
            returns the closest position to it - or if given a float, uses it as a 
			index into the pdata array, and returns the nearest position.
@end lisp                     

For most pdata operations, the vast majority of the combinations of input types (scheme number, the vectors or pdata types) will not be supported, you will receive a rather criptic runtime warning message if this is the case.
		
@section Using PData to build your own primitives

The function (build_polygons) allows you to build empty primitives which you can use to either build more types of procedural shapes than fluxus supports natively, or for loading model data from disk. Once these primitives have been 
constructed they can be treated in exactly the same way as any other primitive, ie pdata can be added or modified, and you can use (recalc-normals) etc.

@node Shaders
@chapter  Hardware shading support

Hardware shaders allow you to have much finer control over the graphics pipeline used to display your objects. Fluxus has commands to set and control GLSL shaders from your scheme scripts, and even edit your shaders in the fluxus editor. GLSL is the OpenGL standard for shaders across various graphics card types, if your card and driver support OpenGL2, this should work for you.

@lisp
(shader vertshader fragshader)
@end lisp
Loads, compiles and binds the vertex and fragment shaders on to current state or grabbed primitive.

@lisp
(shader-set! paramlist)
@end lisp
Sets uniform parameters for the shader in a token, value list, eg:
@lisp
(list "specular" 0.5 "mycolour" (vector 1 0 0))
@end lisp

This is very simple to set up - in your GLSL shader you just need to declare a uniform value eg:

@lisp
uniform float deformamount;
@end lisp
This is then set by calling from scheme:
@lisp
(shader-set! (list "deformamount" 1.4))
@end lisp
The deformamount is set once per object/shader - hence it's a uniform value across the whole object.

Shaders also get given all pdata as attribute (per vertex) parameters, so you can share all this information between shaders and scripts in a similar way:

In GLSL:
@lisp
attribute vec3 testcol;
@end lisp

To pass this from scheme, first create some new pdata with a matching name:
@lisp
(pdata-add "testcol" "v")
@end lisp
Then you can set it in the same way as any other pdata, controlling shader parameters on a per-vertex basis.

@section Samplers

Samplers are the hardware shading word for textures, the word sampler is used to be a little more general in that they are used as a way of passing lots of information (which may not be visual in nature) around between shaders. Passing textures into GLSL shaders from fluxus is again fairly simple:

In your GLSL shader:
@lisp
uniform sampler2D mytexture;
@end lisp

In scheme:
@lisp
(texture (load-texture "mytexturefile.png"))
(shader-set! (list "mytexture" 0))
@end lisp
This just tells GLSL to use the first texture unit (0) as the sampler for mytexture. This is the texture unit that the standard (texture) command loads textures to.

To pass more than one texture, you need multitexturing turned on:

In GLSL:
@lisp
uniform sampler2D mytexture;
uniform sampler2D mysecondtexture;
@end lisp

In scheme:
@lisp
(multitexture 0 (load-texture "mytexturefile.png"))  ; load to texture unit 0
(multitexture 1 (load-texture "mytexturefile2.png")) ; load to texture unit 1
(shader-set! (list "mytexture" 0 "mysecondtexture" 1))
@end lisp

@node Turtle Builder
@chapter Turtle builder 

The turtle polybuilder is an experimental way of building polygonal objects using a logo style turtle in 3D space. As you drive the turtle around you can place vertices and build shapes procedurally. The turtle can also be used to deform existing polygonal primitives, by attaching it to objects you have already created. 

This script simply builds a single polygon circle, by playing the age old turtle trick of looping a function that moves a bit, turns a bit...

@lisp 
(define (build n)
    (turtle-reset)
    (turtle-prim 4)
    (build-loop n n)
    (turtle-build))

(define (build-loop n t)
    (turtle-turn (vector 0 (/ 360 t) 0))
    (turtle-move 1)
    (turtle-vert)
    (if (< n 1)
        0
        (build-loop (- n 1) t)))

    
(backfacecull 0)    
(clear)
(hint-unlit)
(hint-wire)
(line-width 4)
@end lisp 

@image{images/turtle}
A circle

For a more complex example, just modfiy the @code{(build-loop)} function as so:

@lisp 
(define (build-loop n t)
    (turtle-turn (vector 0 (/ 360 t) 0))
    (turtle-move 1)
    (turtle-vert)
    (if (< n 1)
        0
        (begin
            (build-loop (- n 1) t)          ; add another call to the recursion
            (turtle-turn (vector 0 0 45))   ; twist a bit
            (build-loop (- n 1) t))))
@end lisp 
			
@image{images/turtlecomplex}
a circle of circles
 
@node Making Movies
@chapter Making Movies

Fluxus is designed for realtime use, this means interactive performance or games mainly, but you can also use the frame dump commands to save out frames which can be converted to movies. This process can be fairly complex, involving syncing to audio, osc or keyboard input.

Used alone, frame dumping will simply save out frames as fast as your machine can render and save them to disk. This is useful in some cases, but not if we want to create a movie at a fixed framerate, but with the same timing as they are generated at - ie synced with an audio track at 25fps. 

@section Syncing to audio

The (process) command does several things, it switches the audio from the jack input source to a file, but it also makes sure that every buffer of audio is used to produce exactly one frame. Usually in realtime operation, audio buffers will be skipped or duplicated, depending on the variable framerate and fixed audio rate. 

So, what this actually means is that if we want to produce video at 25fps, with audio at 44100 samplerate, 44100/25 = 1764 audio samples per frame. Set your jack and (start-audio) buffer settings to this. Then all you need to do is make sure the calls to (process) and (start-framedump) happen on the same frame, so that the first frame is at the start of the audio. As this process is not realtime, you can set your resolution as large as you want, or make the framerate as slow as you like.

@section Syncing keyboard or OSC input

If you also want to use this technique for re-rendering animations which involve keyboard presses or OSC input, things are a little more involved. Fluxus contains a recorder for these inputs, which is not exactly easy to use, (ok, I'll admit it was a crazy hack :)) but I've used it quite a lot and it seems to work fine.

What it actually does is record the time of every keypress or OSC message, so it can replay them at different framerates correctly. 

It also works with the process command in the same way as the audio does (you always need an audio track, even if it's silence). So the recorder will advance the number of seconds per frame as it renders, rather than using the realtime clock - so again, you can make the rendering as slow as you like, it will appear correct when you view the movie.

@subsection Operating the livecode/OSC recorder

@itemize @bullet
@item F6 starts, and selects between recording or playing back recordings
@item F7 stops recording/playing back
@item F8 resets the position in time
@end itemize

So to give it a try, press F6 until "recording" is printed in the terminal window, type some keys, hit F7 to stop, delete the text, and press F6 again to select "playing". Hit F8 to reset the timer, which will then magically recreate the text you just entered.

As I said, it's not exactly obvious, but I ran out of F keys to use... I will change it at some point to be a little more friendly, ie change the colour of the cursor to indicate the mode.

You can save this recording out to a file, with (save-code "filename") and reload it with (load-code "filename"). The files are ascii format, and contain the timestamps and the information to recreate the key presses. They are not scheme files.

If you are using fluxus to recieve osc information, the details of the messages will also be stored in this file for later use. When playing back a recording, the osc interface treats the recorded messages the same as normal ones, so your script doesn't need to be modified to pick them up.

@subsection An example

It's easier to set up if you start your script from an empty workspace - ie start the recording with the (edit "myscript.scm") or write a script from scratch. Play with fluxus as you normally would, move the camera around, change bits of the script, etc. Then, after saving out the code, you can then use a little startup script which does the following:

@lisp
(start-audio "" 1764 44100)
(load-code "codefile")
(process "audiofile")
(start-framedump "outputframes" "jpg")
@end lisp

Then select all the code, hit F5 to run it, delete to remove it, F6 to start the playback and F8 to reset the recorder time. Then, if everything has worked out the recorder will type out (edit "myscript.scm") and run it, saving frames out at a fixed framerate.

@section Syncing Problems

Getting the syncing right when combining audio/keyboard and OSC input can be a bit tricky. Some common problems I've seen with the resulting movies fall into two categories.

@subsection Syncing lags, and gets worse with time

The call to (start-audio) has the wrong buffer size. As I set this in my .fluxus.scm I often forget this. Set it correctly and re-render. Some lagging may happen unavoidably with really long (over 20 minutes or so) animations.

@subsection Syncing is offset in a constant manner

This happens when the start of the audio does not quite match the first frame. You can try adding or removing some silence at the beginning of the audio track to sort this out. I often just encode the first couple of seconds until I get it right.

@node Fluxus scratchpad and modules
@chapter Fluxus scratchpad and modules

Fluxus consists of two parts. One part is the window containing a script editor rendered on top of the scene display render. This is called the fluxus scratchpad, and it's the way to use fluxus for livecoding and general playing. The functions which you call are part of the fluxus modules which can either be loaded into the fluxus scratchpad, or the drscheme IDE.

@section Fluxus modules

Fluxus's functionality is split between different Scheme modules. You don't need to know any of this to simply use fluxus as is, as they are all loaded and setup for you.

@subsection fluxus-engine
This contains the core rendering functions, and the majority of the commands.

@subsection fluxus-audio
The jack client and fft processor commands.

@subsection fluxus-osc
The osc server and client, and message commands.

@subsection scratchpad scratchpad-camera scratchpad-input
These scheme modules inteface the scratchpad with fluxus-engine.

@section Using fluxus in DrScheme

You can load the fluxus modules into the DrScheme interpreter, and use it as a better IDE for writing fluxus Scheme scripts. This is possible using PLT's interface toolkit MrEd, which allows us to call fluxus commands in an OpenGL context. This is much lower level than using the fluxus scratchpad interpreter at present, although it should be possible to do everything in DrScheme with a little work.

@lisp
(require 
 (lib "gl.ss" "sgl") ; load PLT's opengl modules
 (prefix gl- (lib "sgl.ss" "sgl")))

; load the fluxus-engine binary extension 
(load-extension "/usr/local/lib/plt/collects/fluxus-0.12/compiled/native/i386-linux/fluxus-engine.so")
(require fluxus-engine)
(clear-engine)

(define fluxus-canvas%
  (class* canvas% ()
    (inherit with-gl-context swap-gl-buffers)
    
    (define/override (on-paint)
      (with-gl-context
       (lambda ()
         (glClearColor 0.0 0.0 0.0 0.0)
         (gl-clear 'color-buffer-bit 'depth-buffer-bit)
         
		 ; we can now call fluxus commands
         (begin-scene) ; low level fluxus command to begin rendering
         (draw-cube) ; do something exciting
         (end-scene) ; low level fluxus command to end rendering
         
         (swap-gl-buffers)
         (super on-paint))))
    
    (define/override (on-size width height)
      (with-gl-context
       (lambda () 0)))
    
    (super-instantiate () (style '(gl)))))

(define frame (instantiate frame% ("fluxus in mred")))
(define fluxus-canvas (instantiate fluxus-canvas% (frame) (min-width 640) (min-height 400)))
(send frame show #t)
@end lisp

@node Functions
@chapter Functions

@lowersections
