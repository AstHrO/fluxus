(("Audio" ("Esta parte do fluxus é responsável por capturar o som entrando, e processar ele em dados harmonicos, usando fft (Fast Fourier Transform). As harmonicas são bandas de frequência em que o som é dividido, dando alguma indicação da qualidade do som. É o mesmo que você ve num equalisador gráfico - de fato, um dos scripts de exemplo (bars.scm) age como tal, e pode ser usado para testar se o áudio está funcionando." " (start-audio \"alsa_pcm:capture_1\" 1024 44100)\n (define (animate)\n\t\t(colour (vector (gh 1) (gh 2) (gh 3))) ; make a colour from the harmonics, and set it to be the current colour \n\t\t(draw-cube)) ; draw a cube with this colour\n (every-frame (animate))\n" (("start-audio" ("string-porta-do-jack número-tamanho-buffer número-taxa-amostragem" "void" "Inicia o áudio com as configurações específicadas, você precisa chamar isto primeiro, ou colocar isto em $HOME/.fluxus.scm para chamar automaticamente na inícialização. Tenha a porta do jack como uma string vazia (\"\") e ele não vai tentar conectar em nada para você. Que pode então usar qjackctrl ou equivalente para fazer a conexão manualmente. Fluxus lè uma única fonte mono." " (start-audio \"alsa_pcm:capture_1\" 1024 44100)\n EndSectionDoc\nScheme_Object *start_audio(int argc, Scheme_Object **argv)\n{\n\tMZ_GC_DECL_REG(1);\n\tMZ_GC_VAR_IN_REG(0,argv); \n\tMZ_GC_REG();\n\t\n\tif (!SCHEME_CHAR_STRINGP(argv[0]))scheme_wrong_type(\"start-audio\", \"string\", 0, argc, argv);\n\tif (!SCHEME_NUMBERP(argv[1]))scheme_wrong_type(\"start-audio\", \"number\", 1, argc, argv);\n\tif (!SCHEME_NUMBERP(argv[2]))scheme_wrong_type(\"start-audio\", \"number\", 2, argc, argv);\n\t\n\tif (Audio==NULL)\n\t{\n\t\tchar *name = scheme_utf8_encode_to_buffer(SCHEME_CHAR_STR_VAL(argv[0]),SCHEME_CHAR_STRLEN_VAL(argv[0]),NULL,0);\t\tAudio = new AudioCollector(name,(unsigned int)scheme_real_to_double(argv[1]),(int)scheme_real_to_double(argv[2]));\n\t}\n\t\n\tMZ_GC_UNREG();\n\treturn scheme_void;\n}\n\n StartFunctionDoc-en\n gh harmonic-number\n Returns: harmonic-real\n Description:\n Fluxus converts incoming audio into harmonic frequencies, which can then be plugged into your \n animations using this command. There are 16 harmonic bands availible, the harmonic-value argument \n will be wrapped around if greater or less than 16, so you can use this command without worrying \n about out of range errors.\n Example: (define (animate)\n\t\t(colour (vector (gh 1) (gh 2) (gh 3))) ; make a colour from the harmonics, and set it to be the current colour \n\t\t(draw-cube)) ; draw a cube with this colour\n (every-frame (animate))\n")) ("gh" ("número-harmonico" "void" "Fluxus converte áudio entrando em frequências harmônicas, que pode então ser ligada em suas animações através desse comando. Existem 16 bandas harmônicas disponiveis, o argumento do valor-harmônico vai ser arredondado se maior ou menor que 16, então você pode usar esse comando sem se preocupar sobre erros fora do alcance." " (define (animate)\n\t\t(colour (vector (gh 1) (gh 2) (gh 3))) ; make a colour from the harmonics, and set it to be the current colour \n\t\t(draw-cube)) ; draw a cube with this colour\n (every-frame (animate))\n EndSectionDoc\nScheme_Object *get_harmonic(int argc, Scheme_Object **argv)\n{\n\tMZ_GC_DECL_REG(1);\n\tMZ_GC_VAR_IN_REG(0,argv); \n\tMZ_GC_REG();\n\tif (!SCHEME_NUMBERP(argv[0]))scheme_wrong_type(\"gh\", \"number\", 0, argc, argv);\n\tif (Audio!=NULL)\n\t{\t\n\t\tMZ_GC_UNREG();\n    \treturn scheme_make_double(Audio->GetHarmonic((int)scheme_real_to_double(argv[0])));\n\t}\n\tMZ_GC_UNREG();\n\treturn scheme_make_double(0);\n}\n\n StartFunctionDoc-en\n gain gain-number\n Returns: void\n Description:\n Sets the gain level for the fft sound, it's 1 by default.\n Example: (gain 100) ; too quiet?!\n")) ("gain" ("número-gain" "void" "Ajusta o nível de amplificação para o som fft, é 1 por padrão." " (gain 100) ; muito quieto?!\n EndSectionDoc\nScheme_Object *gain(int argc, Scheme_Object **argv)\n{\n\tMZ_GC_DECL_REG(1);\n\tMZ_GC_VAR_IN_REG(0,argv); \n\tMZ_GC_REG();\n\tif (!SCHEME_NUMBERP(argv[0]))scheme_wrong_type(\"gain\", \"number\", 0, argc, argv);\n\tif (Audio!=NULL)\n\t{\t\n\t\tAudio->SetGain(scheme_real_to_double(argv[0]));\n\t}\n\tMZ_GC_UNREG();\n    return scheme_void;\n}\n\n StartFunctionDoc-en\n process wavfile-string\n Returns: void\n Description:\n This command temporarally disables the realtime reading of the input audio stream and reads a \n wav file instead. For use with the framedump command to process audio offline to make music \n videos. The advantage of this is that it locks the framerate so the right amount of audio gets\n read for each frame - making syncing of the frames and audio files possible.\n Example: (process \"somemusic.wav\") ; read a precorded audio file\n")) ("process" ("wavfile-string" "void" "Este comando desativa temporariamente a leitura em tempo real da entrada da pista de áudio e lê um arquivo wav ao invés. Para usar com o comando framedump para processar audio offline para fazer videos musicais. A vantagem disto é que ele trava a taxa de quadros então a quantidade certa de áudio é lida para cada quadro - fazendo com que a sincrônia entre quadros e audio seja possível." " (process \"somemusic.wav\") ; read a precorded audio file\n EndSectionDoc\nScheme_Object *process(int argc, Scheme_Object **argv)\n{\n\tMZ_GC_DECL_REG(1);\n\tMZ_GC_VAR_IN_REG(0,argv); \n\tMZ_GC_REG();\n\tif (!SCHEME_CHAR_STRINGP(argv[0]))scheme_wrong_type(\"process\", \"string\", 0, argc, argv);\n\tchar *wavname=scheme_utf8_encode_to_buffer(SCHEME_CHAR_STR_VAL(argv[0]),SCHEME_CHAR_STRLEN_VAL(argv[0]),NULL,0);\tif (Audio!=NULL)\n\t{\t\n\t\tAudio->Process(wavname);\n\t}\n\tMZ_GC_UNREG();\n    return scheme_void;\n}\n\n StartFunctionDoc-en\n smoothing-bias value-number\n Returns: void\n Description:\n A kind of weighted average for the harmonic bands which smooth them out over time. \n This setting defaults to 1.5. The best value really depends on the quality of the music, \n and the buffer sizes, and ranges from 0 -> 2. It's more obvious if you give it a try \n with the bars.scm script\n Example: (smoothing-bias 0) ; no smoothing\n")) ("smoothing-bias" ("número-valor" "void" "Uma espécie de média balanceada para as bandas harmônicas que as acalmam com o tempo. Esta opção é por padrão definida como 1.5. O melhor valor realmente depende da qualidade da música, e do tamanho do buffer, e varia de 0 -> 2. Fica mais óbvio se você tentar com o script bars.scm" " (smoothing-bias 0) ; no smoothing\n EndSectionDoc\nScheme_Object *smoothing_bias(int argc, Scheme_Object **argv)\n{\n\tMZ_GC_DECL_REG(1);\n\tMZ_GC_VAR_IN_REG(0,argv); \n\tMZ_GC_REG();\n\tif (!SCHEME_NUMBERP(argv[0]))scheme_wrong_type(\"smoothing-bias\", \"number\", 0, argc, argv);\n\tif (Audio!=NULL)\n\t{\t\n\t\tAudio->SetSmoothingBias(scheme_real_to_double(argv[0]));\n\t}\n\tMZ_GC_UNREG();\n    return scheme_void;\n}\n\n StartFunctionDoc-en\n update-audio\n Returns: void\n Description:\n Updates the audio subsytem. This function is called for you (per frame) in fluxus-canvas.ss.\n Example: (smoothing-bias 0) ; no smoothing\n")) ("update-audio" ("" "void" "Atualiza o subsistema de áudio. Esta função é chamada para você (por frame) no fluxus-canvas.ss" "\n EndSectionDoc\nScheme_Object *update_audio(int argc, Scheme_Object **argv)\n{\n\tif (Audio!=NULL)\n\t{\t\n\t\tAudio->GetFFT();\n\t}\n    return scheme_void;\n}\n\n/\n\nScheme_Object *scheme_reload(Scheme_Env*env)\n{\n\tScheme_Env*menv=NULL;\n\tMZ_GC_DECL_REG(2);\tMZ_GC_VAR_IN_REG(0,env);\n\tMZ_GC_VAR_IN_REG(1,menv);\n\tMZ_GC_REG();\t add all the modules from this extension\n\tmenv=scheme_primitive_module(scheme_intern_symbol(\"fluxus-audio\"), env);\n\n\tscheme_add_global(\"start-audio\", scheme_make_prim_w_arity(start_audio, \"start-audio\", 3, 3), menv);\n\tscheme_add_global(\"gh\", scheme_make_prim_w_arity(get_harmonic, \"gh\", 1, 1), menv);\n\tscheme_add_global(\"gain\", scheme_make_prim_w_arity(gain, \"gain\", 1, 1), menv);\n\tscheme_add_global(\"process\", scheme_make_prim_w_arity(process, \"process\", 1, 1), menv);\n\tscheme_add_global(\"smoothing-bias\", scheme_make_prim_w_arity(smoothing_bias, \"smoothing-bias\", 1, 1), menv);\n\tscheme_add_global(\"update-audio\", scheme_make_prim_w_arity(update_audio, \"update-audio\", 0, 0), menv);\n\n\tscheme_finish_primitive_module(menv);\t\n \tMZ_GC_UNREG();\n\t\n\treturn scheme_void;\n}\n\nScheme_Object *scheme_initialize(Scheme_Env*env)\n{\n\treturn scheme_reload(env);\n}\n\nScheme_Object *scheme_module_name()\n{\n\treturn scheme_intern_symbol(\"fluxus-audio\");\n"))))) ("Renderer" ("Estes comandos são os controladores de baixo nível do renderizador. Você não deveria usá-los a menos que esteja implementando um renderizador do fluxus fora da interface scratchpad." "" (("make-renderer" ("" "número-render-id" "Faz um novo renderizador de gráfico da cena [scenegraph]" " (make-renderer) \n")) ("renderer-grab" ("número-id-renderizador" "void" "Faz este renderizador o atual contexto para comandos." " (renderer-grab renderer) \n")) ("renderer-ungrab" ("" "void" "Pop o contexto da pilha do renderizador." " (renderer-grab renderer) \n")) ("fluxus-render" ("" "void" "Limpa o buffer de fundo, e renderiza tudo." " (fluxus-render)\n")) ("tick-physics" ("" "void" "Atualiza o sistema de física." " (tick-physics) \n")) ("render-physics" ("" "void" "Renderiza o sistema de física (para gráficos ajudantes)." " (render-physics)\n")) ("reset-renderers" ("" "void" "Deleta todos os renderizadores e faz um novo como padrão." " (reset-renderers)\n")) ("reshape" ("número-largura número-altura" "void" "Chama reshapa no render atual." " (reshape 100 100) \n")) ("fluxus-init" ("" "void" "Inicia todo o sistema de renderização, só precisa ser chamado uma vez." " (fluxus-init)\n"))))) ("GlobalState" ("Estado global é realmente qualquer coisa que controla o renderizador globalmente, então ele afeta todas as primitivas ou controla o renderizador diretamente - p.e. controle de câmera ou efeitos de tela cheia como \"embaçamento\"." " accum\n shadow-debug\n shadow-length\n shadow-light\n set-colour-mask\n set-stereo-mode\n read-buffer\n draw-buffer\n desiredfps\n select\n set-screen-size\n get-screen-size\n get-projection-transform\n set-camera \n get-locked-matrix\n get-camera\n clear-accum\n clear-zbuffer\n clear-frame\n clear-colour\n backfacecull\n set-ortho-zoom\n persp\n ortho\n clip\n frustum\n force-load-texture\n load-texture\n camera-lag\n lock-camera\n show-fps\n show-axis\n fog\n blur\n clear-engine\n" (("clear-engine" ("" "void" "Limpa o renderizador, e o sistema de física. Este comando não deve ser chamado diretamente, use clear ao invés, já que limpa algumas outras coisas também, e chama clear-engine ele mesmo." " (clear-engine) ; woo hoo!\n")) ("blur" ("número-quantidade" "void" "Ajusta a opção de blur na tela inteira. Menos é mais, mas se você ajustar isto muito baixo vai fazer com que a edição na tela fique impossível de ler, então salve seus scripts primeiro :)." " (blur 0.1) ; para belos rastros\n")) ("fog" ("cor-nuvem-vetor número-quantidade número-ínicio númeor-final" "void" "Ajusta os paramêtros da neblina pra dar uma indicação de profundidade visual (perspectiva aérea no jargão de pintores). Isto pode obscurecer a edição na tela, então mantenha a quantidade baixa." " (clear-colour (vector 0 0 1)) ; fica legal se o fundo de tela bate.\n (fog (vector 0 0 1) 0.01 1 100) ; neblina azul\n")) ("show-axis" ("número-mostrar" "void" "Mostra os eixos de origem do espaço usado;" " (show-axis 1)\n")) ("show-fps" ("número-mostrar" "void" "Mostra uma contaem de fps na parte inferior esquerda da tela." " (show-fps 1)\n")) ("lock-camera" ("número-id-primitiva" "void" "Trava a transformação da camera em cima da transformação do objeto específicado. É como parentear a câmera ao objeto. Esta é a forma mais fácil de dirigir a câmera proceduralmente. Use um número id de 0 para destravar a câmera." " (clear)\n (define obj (build-cube)) ; make a cube for the camera to lock to\n \n (push) ; make a background cube so we can tell what's happening\n (hint-wire)  \n (hint-unlit) \n (colour (vector 0 0.4 0))\n (scale (vector -50 -50 -50))\n (build-cube)\n (pop)\n \n (lock-camera obj) ; lock the camera to our first cube\n \n (define (animate)\n     (grab obj)\n     (rotate (vector 1 0 0)) ; rotate the cube\n     (ungrab))\n \n (every-frame (animate))\n")) ("camera-lag" ("número-quantidade" "void" "O travamento da câmera tem um atraso construído junto o que significa que o movimento vai ser macio em relativo a primitiva ao qual ela está travada." " (clear)\n (define obj (build-cube)) ; make a cube for the camera to lock to\n \n (push) ; make a background cube so we can tell what's happening\n (hint-wire)\n (hint-unlit)\n (colour (vector 0 0.4 0))\n (scale (vector -50 -50 -50))\n (build-cube)\n (pop)\n \n (lock-camera obj) ; lock the camera to our first cube\n (camera-lag 0.1)  ; set the lag amount, this will smooth out the cube jittery movement\n \n (define (animate)\n     (grab obj)\n     (identity)\n     (translate (vector (modulo (round (inexact->exact (time))) 6) 0 0)) ; make a jittery movement\n     (ungrab))\n \n (every-frame (animate))\n")) ("load-texture" ("pngnomedoarquivo-string" "void" "Carrega uma imagem do disco, converte esta a uma textura e retorna o número id. O carregamento da textura se dá no cache de memória, então repetidamente chamar esta função não vai causar que carregue de novo. Use force-load-texture se você está mudando a textura enquanto o script estiver rodando. O png pode ser RGB ou RGBA para usar transparência alpha." " (texture (load-texture \"mytexture.png\"))\n (build-cube) ; o cubo vai ser mapeado com a textura da imagem\n")) ("force-load-texture" ("pngnomedoarquivo-string" "void" "Carregamento de texturas do disco sem cache, converte esta a uma textura e retorna o número id. Útil se você está mudando a textura enquanto está rodando o script, ou então usando load-texture, o que vai ser muito mais rápido. A png pode ser RGB ou RGBA para usar transparência alpha." " (texture (force-load-texture \"mytexture.png\"))\n (build-cube) ; o cubo vai ser mapeado com a textura da imagem\n")) ("frustum" ("número-topo número-baixo número-esquerda número-direita" "void" "Ajusta o frustum da camera, e portanto o quociente de aspecto do frame." " (frustum -1 1 -0.75 0.75) ; definições padrão\n")) ("clip" ("número-frente número-trás" "void" "Ajusta os planos de clipagem da frente e de trás para o frustum da câmera, portanto o ângulo de visão. Mude a distância da frente do clip para alterar a perspectiva de telephoto para fisheye." " (clip 1 10000) ; default settings\n")) ("ortho" ("" "void" "Ajusta a projeção ortográfica - p.e. sem perspectiva." " (ortho)\n")) ("persp" ("" "void" "Ajusta a projeção como perspectiva (o padrão) depois que ortho foi acionada." " (persp)\n")) ("set-ortho-zoom" ("número-quantidade" "void" "Ajusta o nível de zoom para a projeção ortográfica." " (set-ortho-zoom 2)\n")) ("backfacecull" ("número-ajuste" "void" "Liga ou desliga o corte de face-traseira. Backface culling acelera a renderização removendo faces não orientadas em direção da câmera. É ligado por padrão, mas isto não é desejado sempre, eg para poligonos com dupla face." " (backfacecull 0)\n")) ("clear-colour" ("vetor-cor" "void" "Ajusta a cor que vai limpar o renderizador, isto forma a cor do fundo da cena." " (clear-colour (vector 1 0 0)) ; RED!!!\n")) ("clear-frame" ("número-ajuste" "void" "ajusta a limpeza do frame, desligado ou ligado." " (clear-frame 0)\n")) ("clear-zbuffer" ("número-ajuste" "void" "Ajusta a limpeza do zbuffer, desligado ou ligado." " (clear-zbuffer 0)\n")) ("clear-accum" ("número-ajuste" "void" "Ajusta a limpeza do buffer de acumulação, ligado ou desligado" " (clear-accum 1)\n")) ("get-camera" ("" "vetor-matriz" "Pega a transformação da camera. Esta é a função de baixo nível, use get-camera-transform ao invés." " (get-camera)\n")) ("get-locked-matrix" ("" "vetor-matriz" "Pega a matriz de tranformação da câmera travada. Leva em consideração o atraso." " (get-locked-matrix)\n")) ("set-camera" ("" "void" "Ajusta a matriz de transformação da câmera. Esta é a interface de baixo nível usada por set-camera-transform, a qual você devia usar geralmente ao invés." " (set-camera)\n")) ("get-projection-transform" ("" "matriz-de-projeção" "Pega a matriz de projeção atual." " (get-projection-transform)\n")) ("get-screen-size" ("" "vetor-tamanho" "Retorna um vetor contendo a atual largura e altura da janela" " (get-screen-size)\n")) ("set-screen-size" ("vetor-tamanho" "void" "Ajusta a altura e largura da janela." " (set-screen-size (vector 10 10)) ; small window time :)\n")) ("select" ("número-janelaposX número-janelaposY número-tamanho-pixel" "número-id-primitiva" "Olha na região específicada e retorna a id da primitiva mais próxima à renderização da câmera lá, ou 0 se não existente." " (display (select 10 10 2))(newline)\n")) ("desiredfps" ("número-fps" "void" "Desacelera o renderizador de forma a não pegar 100% de cpu. Isto dá um limite acima na taxa de fps, o que não completamente bate o número dado, mas nós estamos trabalhando nisto..." " (desiredfps 100000) ; faz fluxus renderizar tão rápido quanto pode\n                     ; e levar 100% de cpu.\n")) ("draw-buffer" ("nome-buffer" "void" "Seleciona qual buffer para desenhar, se em modo estéreo você iria fazer 'back-right e 'back-left" " (draw-buffer 'back)\n")) ("read-buffer" ("nome-buffer" "void" "Seleciona qual buffer para ler." " (read-buffer 'back)\n")) ("set-stereo-mode" ("modo" "bool" "seleciona qual modo estéreo a usar, atualmente somente 'cristal-eyes e 'no-stereo são suportados o retorno indica se a operação foi bem sucedida ou não 'crystal-eyes vai retornar falso se você não tem uma janela estéreo." " (set-stereo-mode 'crystal-eyes)\n")) ("set-colour-mask" ("vetor" "void" "Ajusta a máscara de cor dando a esta um quatérnio de booleanos que correspondem aos canais vermelho, verde, azul e alpha respectivamente depois desta operação você vai ver apenas aquelas cores que você ajustar como verdadeiras (isto é útil apenas para estéreo com óculos azul-vermelhos)" " (set-colour-mask #(#t #f #f #t))\n")) ("shadow-light" ("número-ajuste" "void" "Ajusta a luz para usar na geração de sombras, ajuste para 0 para desativar renderização de sombras." " (shadow-light 1)\n")) ("shadow-length" ("número-ajuste" "void" "Ajusta o alcance do volume da renderização da sombra." " (shadow-length 10)\n")) ("shadow-debug" ("número-ajuste" "void" "Liga debug na renderização do volume da sombra." " (shadow-debug 1)\n")) ("accum" ("simbolo-modo número-valor" "void" "Controla o buffer de acumulação (somente chama glAccum embaixo do tapete). Símbolos possíveis são: accum load return add mult" " (accum 'add 1)\n"))))) ("Lights" ("Sem luzes você não seria capaz de ver nada. Por sorte fluxus te dá uma de graça por padrão, uma luz pontual difusa e branca fixa à camêra. Para iluminações mais interessantes, você vai precisar destas funções. Usando as funções fixas de pipeline gráfico padrão, falando simplisticamente, OpenGL multiplica estes valores pela superficie do material (ajustado com comandos do estado local [local state] como ambient e diffuse) e o valor cor da textura dando a cor final." "" (("make-light" ("simbolo-tipo simbolo-travado-camera[cameralocked]" "lightid-number" "Faz uma luz nova. O tipo pode ser um destes: point, directional ou spot. Se a string de cameralocked não estiver livre então esta vai ser fixa à câmera, e mexer ao redor quando você mover a câmera." " (make-light 'spot 'locked)\n")) ("light-ambient" ("número-id-luz colour" "void" "Ajusta a contribuição do ambiente para a luz especificada." " (light-ambient mylight (vector 1 1 1)) ; a boring light\n")) ("light-diffuse" ("número-id-luz colour" "void" "Ajusta a contribuição difusa para a luz especificada." " (light-diffuse mylight (vector 1 1 1)) \n")) ("light-specular" ("número-id-luz colour" "void" "Ajusta a contribuição especular para a luz específicada." " (light-specular mylight (vector 1 1 1)) \n")) ("light-position" ("número-id-luz vetor-posição" "void" "Ajusta a posição da luz especificada. Em espaço global se livre, em espaço da câmera se fixa." " (light-position mylight (vector 0 100 0)) \n")) ("light-spot-angle" ("número-id-luz número-ângulo" "void" "Ajusta o ângulo do cone da luz spot especificada. Se não é uma luz spot este comando não tem nenhum efeito." " (light-position mylight (vector 0 100 0)) \n")) ("light-spot-exponent" ("número-id-luz número-exponente" "void" "Ajusta a exponencial da luz spot (dispersão do cone) específicada. Não funciona com outra lâmpada senão a spot." " (light-spot-exponent mylight 0.1) \n")) ("light-attenuation" ("número-id-luz símbolo-tipo número-atenuação" "void" "Ajusta a atenuação da luz (decaimento com distância) da luz especificada. O símbolo-tipo, pode ser um dos: constant, linear ou quadratic." " (light-attenuation 'constant 0.1) \n")) ("light-direction" ("número-id-luz vetor-direção" "void" "Ajusta a direção da luz direcional. Se não é uma luz direcional, este comando não tem efeito." " (light-spot-exponent mylight 0.1) \n"))))) ("LocalState" ("As funções de estado local controlam a renderização ou do estado corrente - ou do estado da primitiva correntemente pega(grabbed). Em Fluxus estado significa significa a forma que as coisas são mostradas, tanto ligando/desligando opções de render, mudando o estilo de diferentes opções, ou alterando a transformação corrente." " push \n pop\n grab\n ungrab\n apply\n opacity\n shinyness\n colour\n wire-colour\n specular\n ambient\n opacity\n identity\n concat\n translate\n rotate\n scale\n get-transform\n parent\n line-width\n point-width\n blend-mode\n hint-solid\n hint-wire\n hint-normal\n hint-points\n hint-anti-alias\n hint-unlit\n hint-vertcols\n hint-box\n hint-multitex\n hint-none\n hint-origin\n hint-cast-shadow\n hint-depth-sort\n hint-ignore-depth\n hint-lazy-parent\n texture\n multitexture\n print-scene-graph \n hide\n selectable\n shader\n shader-set!\n" (("push" ("" "void" "Empurra uma cópia do estado corrente de desenho para o topo da pilha. O estado de desenho contém informação sobre coisas como cor corrente, transformação e dicas(hints)." " (colour (vector 1 0 0)) ; aplica cor corrente pra vermelho\n (push)                  ; copia e empurra estado de desenho\n (colour (vector 0 1 0)) ; aplica cor corrente pra verde\n (draw-cube)\t\t\t   ; desenha um cubo verde\n (pop)\t\t\t\t   ; esquece estado de desenho antigo\n ; cor corrente é vermelha de novo.\n")) ("pop" ("" "void" "Destrói o estado de desenho corrente, e aplica para o estado corrente o antigo anteriormente empurrado na pilha. O estado de desenho contém informação sobre coisas como cor corrente, transformação e dicas(hints)." " (colour (vector 1 0 0)) ; aplica cor corrente pra vermelho\n (push)                  ; copia e empurra estado de desenho\n (colour (vector 0 1 0)) ; aplica cor corrente pra verde\n (draw-cube)             ; desenha um cubo verde\n (pop)                   ; esquece estado de desenho antigo\n ; cor corrente é vermelha de novo.\n")) ("grab" ("id-do-objeto" "void" "Pega o objeto especificado. Uma vez que o objeto foi pego seu estado pode ser modificado usando os mesmos comandos usados pra ajustar o estado de desenho atual. (ungrab) precisa ser usado para retornar ao estado de desenho normal. \"grabbing\" também pode ser \"pilhado\", neste caso (ungrab) pula para a próxima primitiva pega." " (colour (vector 1 0 0))      ; aplica a cor atual para vermelho\n (define mycube (build-cube)) ; faz um cubo vermelho\n (grab mycube)  \t\t\t\t       \n (colour (vector 0 1 0)) ; aplica a cor do cubo como verde \n (ungrab)\t\t\t\t   ; retorna ao estado normal\n")) ("ungrab" ("" "void" "Solta o objeto pego atualmente, e ou retorna ao estado de desenho normal, ou tira a ultima primitiva pega do topo da pilha." " (colour (vector 1 0 0))      ; aplica a cor atual para vermelho\n (define mycube (build-cube)) ; faz um cubo vermelho\n (grab mycube)  \t\t\t\t       \n (colour (vector 0 1 0)) ; aplica a cor verde ao cubo \n (ungrab)\t\t\t\t   ; retorna ao estado normal\n")) ("apply" ("id-do-objeto" "void" "Aplica a transformação corrente às posições dos vértices do objeto dado e ajusta sua tranformação para identidade." " (rotate (vector 45 0 0))     \n (define mycube (build-cube)) ; faz um cubo com uma rotação\n (apply mycube)  \t      ; aplica a rotação aos pontos do cubo\n")) ("opacity" ("valor" "void" "Ajusta a opacidade do estado de desenho atual, ou da primitiva pega atualmente." " (opacity 0.5)     \n (define mycube (build-cube)) ; faz um cubo semi-transparente.\n")) ("shinyness" ("valor" "void" "Ajusta o brilho do estado atual de desenho, ou da primitiva atualmente pega. Esse valor ajusta a densidade do brilho especular." " (shinyness 100)     \n (specular (vector 1 1 1)) ; ajusta a cor especular\n (define mysphere (build-sphere 10 10)) ; makes a shiny cube \n")) ("colour" ("vetor-cor" "void" "Ajusta a cor do estado de desenho atual, ou a primitiva atualmente pega." " (colour (vector 1 0.5 0.1)) ; mmm laranja...   \n (define mycube (build-cube)) ; faz um cubo laranja \n")) ("wire-colour" ("vetor-cor" "void" "Ajusta a cor do \"wire frame\" do estado de desenho atual, ou a primitiva atualmente pega. Visível com (hint-wire) na maioria das primitivas." " (wire-colour (vector 1 1 0)) ; ajusta a cor do fio como amarelo\n (hint-wire)   \n (define mycube (build-cube)) ; faz um cubo com wireframe amarelo\n")) ("specular" ("vetor-cor" "void" "Ajusta a cor especular do estado de desenho corrente, ou o objeto atualmente pego." " (specular (vector 0 0 1)) ; ajusta azul como a cor especular\n (define mysphere (build-sphere 10 10)) ; faz uma esfera azul brilhante.\n")) ("ambient" ("vetor-cor" "void" "Ajusta a cor ambiente do estado de desenho corrente, ou a primitiva atualmente pega." " (ambient (vector 0 0 1)) ; ajusta a cor ambiente como azul\n (define mysphere (build-sphere 10 10)) ; faz uma chata esfera azul \n")) ("opacity" ("valor" "void" "Ajusta a cor emissiva do estado de desenho atual, ou da primitiva atualmente pega." " (emissive (vector 0 0 1)) ; ajusta a cor emissiva para azul\n (define mysphere (build-sphere 10 10)) ; faz uma esfera azul brilhante \n")) ("identity" ("" "void" "Ajusta a transformação do estado de desenho para identidade, no estado de pilha, ou a primitiva atualmente pega." " (push)\n (scale (vector 2 2 2)) ; ajusta o tamanho atual pro dobro em cada dimensão\n (define mycube (build-cube)) ; faz um cubo aumentado\n (pop)\n (grab mycube)\n (identity) ; apaga a transformação e coloca o cubo de volta ao seu\n            ; estado original\n (ungrab)\n")) ("concat" ("matrix" "void" "Concatena (multiplica) uma matriz para o estado de desenho atual ou primitiva pega." " (define mymatrix (mrotate (vector 0 45 0))) ; faz uma matriz\n (concat mymatrix) ; concat ela no estado atual\n (build-cube) ; faz um cubo com esta rotação\n")) ("translate" ("vetor" "void" "Aplica uma translação ao estado de desenho atual ou primitiva pega" " (transform (vector 0 1.4 0)) ; translada a transformação atual pra\n                              ; cima um pouco\n (build-cube) ; constrói um cubo com esta transformação\n")) ("rotate" ("vetor-ou-quaternion" "void" "Aplica uma rotação ao estado de desenho atual ou primitiva pega." " (rotate (vector 0 45 0)) ; vira 45 graus no eixo Y \n (build-cube) ; constrói um cubo com esta transformação\n")) ("scale" ("vetor" "void" "Aplica uma escalagem ao estado de desenho atual ou primitiva pega." " (scale (vector 0.5 0.5 0.5)) ; escala a tranformação atual para\n                              ; metade do tamanho\n (build-cube) ; constrói um cubo com esta transformação\n")) ("get-transform" ("" "vetor-matriz" "Retorna uma matriz representando o estado de tranformação corrente ou para a primitiva pega." " (translate (vector 1 0 0))\n (display (get-transform))(newline) ; imprime a transformação corrente\n (define shape (build-sphere 10 10))\n (grab shape)\n (translate (vector 0 1 0))\n (display (get-transform))(newline) ; imprime a transformação da forma\n (ungrab)\n")) ("parent" ("id-primitiva" "void" "Parenteia a primitiva correntemente pega à primitiva pai dada. A primitiva corrente vai ser agora movida junto com o pai por adquirir todas as suas transformações." " (define parent-prim (build-cube)) ; make a parent cube\n (translate (vector 2 0 0)) ; move a bit in x\n (parent parent-prim) ; set parent-prim as the current parent\n (define child-prim (build-cube)) ; make a child cube\n (grab parent-prim) \n (rotate (vector 0 45 0)) ; the child will now be moved by this transform in addition to its own\n (ungrab)\n")) ("line-width" ("valor" "void" "Ajusta a largura da linha (em espaço de tela) do estado de desenho corrente, ou da primitiva correntemente pega, Afeta wireframe e afins." " (line-width 5)\n (hint-wire)\n (build-sphere 10 10) ; faz uma esfera com um denso wireframe\n")) ("point-width" ("value" "void" "Ajusta o tamanho do ponto (em espaço na tela) do estado de desenho corrente, ou da primitiva pega. Afeta a renderização de pontos e particulas no hardware." " (point-width 5)\n (hint-points)\n (build-sphere 10 10) ; faz uma esfera com pontos grossos\n")) ("blend-mode" ("src dst" "void" "Ajusta o modo de mistura do estado de desenho corrente, ou da primitiva pega. Esse é o modo que o alpha é composto no superficie renderizada." " ; list out all the possible blendmodes\n \n (define src-blend (vector 'zero 'one 'dst-color 'one-minus-dst-color 'src-alpha\n                     'one-minus-src-alpha 'dst-alpha 'one-minus-dst-alpha\n                     'src-alpha-saturate))\n \n (define dst-blend (vector 'zero 'one 'dst-color 'one-minus-dst-color 'src-alpha\n                     'one-minus-src-alpha 'dst-alpha 'one-minus-dst-alpha))\n \n ; picks a random element\n (define (pick-rnd-item l)\n     (vector-ref l (random (vector-length l))))\n \n ; make lots of random spheres\n (define (rnd-sphere n)\n     (push)\n     (hint-depth-sort)\n     (opacity 0.5)\n     (colour (vector (flxrnd) (flxrnd) (flxrnd)))\n \n     ; set a random blendmode\n     (blend-mode (pick-rnd-item src-blend) (pick-rnd-item dst-blend))\n \n     (translate (vector (flxrnd) (flxrnd) (flxrnd)))\n     (scale (vector 0.1 0.1 0.1))\n     (build-sphere 10 10)\n     (pop)\n     (if (zero? n)\n         0\n         (rnd-sphere (- n 1))))\n \n (clear)\n (clear-colour (vector 0.5 0.5 0.5))\n (rnd-sphere 100)\n")) ("hint-solid" ("" "void" "Ajusta as dicas pra renderizar como solid no estado de desenho corrente, ou a primitiva pega. Dicas de render mudam a forma como as primitivas são renderizadas, mas podem ter efeitos diferentes - ou nenhum efeito em certas primitivas portanto o nome dicas." " (hint-solid) ; esse é o estilo de render original então não deve\n              ; muito estimulante\n (build-cube) ; faz um cubo renderizado sólido \n")) ("hint-wire" ("" "void" "Ajusta o render para wireframe no modo de estado corrente, ou da primitiva pega. Dicas de render mudam a forma como as primitivas são renderizadas, mas podem ter efeitos diferentes - ou nenhum efeito em certas primitivas portanto o nome dicas." " (hint-wire)\n (build-cube) ; faz um cubo em wireframe \n")) ("hint-normal" ("" "void" "Ajusta as dicas de render para fazer aparecer normais no estado de desenho corrente, ou da primitiva pega. Dicas de render mudam a forma como as primitivas são renderizadas, mas podem ter efeitos diferentes - ou nenhum efeito em certas primitivas portanto o nome dicas." " (hint-normal)\n (build-cube) ; mostra as normais do cubo\n")) ("hint-points" ("" "void" "Ajusta as dicas para aparecer pontos no estado de desenho corrente, ou da primitiva pega. Dicas de render mudam a forma como as primitivas são renderizadas, mas podem ter efeitos diferentes - ou nenhum efeito em certas primitivas portanto o nome dicas." " (hint-points)\n (build-cube) ; mostra os pontos dos vertices deste cubo\n")) ("hint-anti-alias" ("" "void" "Ajusta as dicas de render para anti-alias no estado de desenho atual, ou da primitiva pega. Dicas de render mudam a forma como as primitivas são renderizadas, mas podem ter efeitos diferentes - ou nenhum efeito em certas primitivas portanto o nome dicas." " (hint-anti-alias)\n (build-cube) ; mostra um cubo macio\n")) ("hint-unlit" ("" "void" "Ajusta as dicas de render para luzes desligadas no estado de desenho corrente, ou da primitiva pega. Dicas de render mudam a forma como as primitivas são renderizadas, mas podem ter efeitos diferentes - ou nenhum efeito em certas primitivas portanto o nome dicas." " (hint-unlit)\n (build-cube) ; mostra um cubo sem iluminação\n")) ("hint-vertcols" ("" "void" "Ajusta as dicas de render pra usar cores de vértices no estado de desenho corrente, ou da primitiva pega. Dicas de render mudam a forma como as primitivas são renderizadas, mas podem ter efeitos diferentes - ou nenhum efeito em certas primitivas portanto o nome dicas. Cores de vértices modificam o estado atual de (colour)." " (hint-vertcols)\n (define mycube (build-cube)) ; faz um cubo com vertcols ativado\n (grab mycube)\n (pdata-set \"c\" 0 (vector 0 1 0)) ; ajusta a cor do primeiro vert\n                                  ; pra verde\n (ungrab)\n")) ("hint-box" ("" "void" "Ajusta as dicas de render para mostrar a caixa envolvente no estado de desenho corrente, ou a primitiva pega. Dicas de render mudam a forma como as primitivas são renderizadas, mas podem ter efeitos diferentes - ou nenhum efeito em certas primitivas portanto o nome dicas." " (hint-box)\n (build-sphere 10 10) ; faz uma esfera com a bounding box\n")) ("hint-multitex" ("" "void" "Ajusta as dicas de render para usar multiplas texturas no estado de desenho corrente. Dicas de render mudam a forma como as primitivas são renderizadas, mas podem ter efeitos diferentes - ou nenhum efeito em certas primitivas portanto o nome dicas." " (hint-multitexture)\n (multitexture 0 (load-texture \"tex1.png\"))\n (multitexture 1 (load-texture \"tex2.png\"))\n (build-sphere 10 10) ; faz uma esfera com texturas sobrepostas\n")) ("hint-none" ("" "void" "Limpa as dicas de render no estado de desenho corrente, ou da primitiva pega. Isso permite que você se livre do estilo sólido default, mas também significa que voce pode ligar e desligar dicas sem usar push ou pop" " (hint-none)\n (hint-wire)\n (build-cube) ; faz um cubo vísivel apenas em wireframe\n")) ("hint-origin" ("" "void" "Ajusta as dicas de render para mostrar a origem espacial do objeto no estado de desenho corrente, ou da primitiva pega. Dicas de render mudam a forma como as primitivas são renderizadas, mas podem ter efeitos diferentes - ou nenhum efeito em certas primitivas portanto o nome dicas." " (hint-origin)\n (build-sphere 10 10) ; make a sphere with the origin displayed\n")) ("hint-cast-shadow" ("" "void" "(nota: não implementado ainda) Ajusta as dicas de render para fazer sombra para o estado de desenho atual, ou a primitiva pega. Dicas de render podem mudar a forma que as primitivas são renderizadas, mas pode ter efeitos diferentes- ou nenhum efeito em certas primitivas, portanto o nome dica." " (hint-origin)\n (build-sphere 10 10) ; make a sphere with the origin displayed\n")) ("hint-depth-sort" ("" "void" "Ajusta as dicas de render para separar em profundidade o estado corrente, ou a primitiva pega. Dicas de render mudam a forma como as primitivas são renderizadas, mas podem ter efeitos diferentes - ou nenhum efeito em certas primitivas portanto o nome dicas." " (hint-depth-sort)\n (build-sphere 10 10) \n")) ("hint-ignore-depth" ("" "void" "Ajusta as dicas de render para ignorar tested de profundidade no estado corrente de desenho, ou da primitiva pega. Dicas de render mudam a forma como as primitivas são renderizadas, mas podem ter efeitos diferentes - ou nenhum efeito em certas primitivas portanto o nome dicas. Essa capacidade é util para renderizar objetos transparentes, já que ela significa que objetos vão aparecer atrás de outros já renderizados." "")) ("hint-lazy-parent" ("" "void" "Ajusta as dicas de render para prevenir esta primitiva de passar suas transformações a um filho. Dicas de render mudam a forma como as primitivas são renderizadas, mas podem ter efeitos diferentes - ou nenhum efeito em certas primitivas portanto o nome dicas." "")) ("texture" ("número-id-textura" "void" "Ajusta a textura do estado corrente, ou da primitiva pega. Ids de textura podem ser geradas pela função load-texture." " (texture (load-texture \"mytexture.png\"))\n (build-sphere 10 10) ; faz uma textura com mytexture.png\n")) ("multitexture" ("número-textureunit número-id-primitiva" "void" "Ajusta a textura do estado corrente de desenho, ou da primitiva pega da mesma forma que a função textura, mas permite que você especifique a unidade de textura (0-7) para aplicar-lá.Multitextura permite você aplicar diferentes texturas e coordenadas ao mesmo objeto de uma vez. Unidade de textura 0 é o padrão (que usa a pdata \"t\" para suas coordenadas) unidade de textura n olha pela pdata \"tn\" - ie multitexture 1 olha por \"t1\". Você precisa adicionar estas você mesmo usando (pdata-add) ou (pdata-copy). Multitexturas é útil quando a textura contém alpha, já que elas podem ser sobrepostas, por exemplo adesivos colocados em texturas de fundo. Nota: Fluxus precisa ser compilado usando scons MULTITEXTURE=1 para ativar essa capacidade." " (define obj (build-sphere 10 10)) ; make a sphere \n (grab obj)\n (multitexture 0 (load-texture \"mytextureA.png\")) \n (multitexture 1 (load-texture \"mytextureB.png\"))\n (pdata-add \"t1\" \"v\")   ; make some texture coords for texture B\n (pdata-copy \"t\" \"t1\")  ; copy them from the default texture coords\n (ungrab)\n")) ("print-scene-graph" ("" "void" "Mostra o scene graph corrente, útil para debug." " (print-scene-graph) ; exciting...\n")) ("hide" ("número-escondido" "void" "Ajusta o estado escondido para a primitiva pega (tbm afeta todas as primitivas filhas). Primitivas escondidas podem ser tratadas normalmente em todas as formas - elas apenas não serão renderizadas." " (define obj (build-cube))\n (grab obj)\n (hide 1) ; hide this cube\n (ungrab)\n")) ("selectable" ("número-selecionável" "void" "Ajusta se a primitiva pega pode ser selecionada ou não." " (define obj (build-cube))\n (grab obj)\n (selectable 0) ; agora ela nao vai ser \"vista\", quando chamar select\n (ungrab)\n")) ("shader" ("vertexprograma-string fragmentprogram-string" "void" "Abre, compila e ajusta o pard de GLSL hardware shader para o estado de desenho atual, ou a primitiva pega. Requer OpenGL 2. Os dados uniformes do shader podem ser controlados via shader-set! e todas as pdatas são enviadas como um atributo por vértice ao shader." " (push)\n ; assign the shaders to the surface\n (shader \"simplevert.glsl\" \"simplefrag.glsl\")\n (define s (build-sphere 20 20))\n (pop)\n \n (grab s)\n ; add and set the pdata - this is then picked up in the vertex shader \n ; as an input attribute called \"testcol\"\n (pdata-add \"testcol\" \"v\")\n (set-cols (pdata-size))\n (ungrab)\n \n (define (animate)\n     (grab s)\n \t; animate the deformamount uniform input parameter \n     (shader-set! (list \"deformamount\" (cos (time))))\n     (ungrab))\n \n (every-frame (animate))\n")) ("shader-set!" ("lista-argumentos" "void" "Ajusta os parâmetros do shader uniforme para o shader GLSL. A lista contém valores pares simbolos-strings, que relacionam os parâmetros de shader correspondentes nomes e valores" " (push)\n ; assign the shaders to the surface\n (shader \"simplevert.glsl\" \"simplefrag.glsl\")\n (define s (build-sphere 20 20))\n (pop)\n \n (grab s)\n ; add and set the pdata - this is then picked up in the vertex shader \n ; as an input attribute called \"testcol\"\n (pdata-add \"testcol\" \"v\")\n (set-cols (pdata-size))\n (ungrab)\n \n (define (animate)\n     (grab s)\n \t; animate the deformamount uniform input parameter \n     (shader-set! (list \"deformamount\" (cos (time))))\n     (ungrab))\n \n (every-frame (animate))\n"))))) ("Matemática" ("Estas funções sao optimizadas para gráficos em 3d, e a colisão entre ciência da computação e matemática é aparente aqui, então vetores representando \"vectors\" são nesse contexto tidos como 3 elementos em tamanho, quaternions são vetores de tamanho 4, e matrizes são vetores de 16 elementos." " vmul\n vadd\n vsub\n vdiv\n vtransform\n vtransform-rot\n vnormalise\n vdot\n vmag\n vdist\n vcross\n mmul\n madd\n msub\n mdiv\n mident\n mtranslate\n mrotate\n mscale\n mtranspose\n minverse\n maim\n qaxisangle\n qmul\n qnormalise\n qtomatrix\n qconjugate\n" (("vmul" ("vetor número" "vetor resultante" "Multiplica um vetor por um número." " (vmul (vector 1 2 3) 2)\n")) ("vadd" ("vetor vetor" "vetor resultante" "Adiciona dois vetores, um ao outro." " (vadd (vector 1 2 3) (vector 1 2 3))\n")) ("vsub" ("vetor vetor" "vetor resultante" "Subtrai um vetor de outro." " (vsub (vector 1 2 3) (vector 1 2 3))\n")) ("vdiv" ("vetor número" "vetor resultante" "Divide um vetor por um número" " (vdiv (vector 1 2 3) 2)\n")) ("vtransform" ("vetor matriz" "vetor resultante" "Multiplica (transforma) um vetor por uma matriz." " (vtransform (vector 0 1 0) (mrotate (vector 90 0 0)))\n")) ("vtransform-rot" ("vetor matriz" "vetor resultante" "Multiplica (transforma) um vetor por uma matriz, mas deixa de fora a parte de translação. Para ser usado em operações involvendo normais." " (vtransform-rot (vector 0 1 0) (mrotate (vector 90 0 0)))\n")) ("vnormalise" ("vetor" "vetor resultante" "Retorna a forma normalisada do vetor (length=1)" " (vtransform-rot (vector 0 1 0) (mrotate (vector 90 0 0)))\n")) ("vdot" ("vetor vetor" "número resultante" "Retorna o produto multiplicado de dois vetores." " (vdot (vector 0 1 0) (vector 1 0 0))\n")) ("vmag" ("vetor" "número resultante" "Retorna a magnitude, ou alcance do vetor" " (vmag (vector 0 1 1))\n")) ("vdist" ("vetor vetor" "número resultante" "Tratando os vetores como pontos, retorna a distancia entre eles." " (vdist (vector 100 100 0) (vector 0 0 100))\n")) ("vcross" ("vetor vetor" "vetor resultante" "Retorna o produto cruzado entre dois vetores, resultando em um vetor que é perpendicular aos cruzados." " (vcross (vector 100 100 0) (vector 0 0 100)) \n")) ("mmul" ("vetor-matriz vetor-matriz" "vetor-matriz" "Multiplica duas matrizes." " (vmul (mtranslate (vector 1 0 0)) (mrotate (vector 0 90 0)))\n")) ("madd" ("vetor-matriz vetor-matriz" "vetor-matriz" "Adiciona duas matrizes." " (vadd (mtranslate (vector 1 0 0)) (mrotate (vector 0 90 0)))\n")) ("msub" ("vetor-matriz vetor-matriz" "vetor-matriz" "Subtrai uma matriz de outra." " (vsub (mtranslate (vector 1 0 0)) (mrotate (vector 0 90 0)))\n")) ("mdiv" ("vetor-matriz vetor-matriz" "vetor-matriz" "Divide uma matriz por outra." " (vdiv (mtranslate (vector 1 0 0)) (mrotate (vector 0 90 0)))\n")) ("mident" ("" "vetor-matriz" "Retorna a matriz identidade" " (mident)\n")) ("mtranslate" ("vetor" "vetor-matriz" "Retorna uma matriz representando a tranformação(translação) especificada." " (mtransform (vector 100 0 0))\n")) ("mrotate" ("vetor" "vetor-matriz" "Retorna uma matriz representando a rotação especificada. Aceita um vetor de angulos euler, ou um quatérnio." " (mrotate (vector 0 45 0))\n")) ("mscale" ("vetor" "vetor-matriz" "Retorna uma matriz representando a escalagem especificada." " (mscale (vector 0.5 2 0.5))\n")) ("mtranspose" ("vetor-matriz" "vetor matriz" "Retorna a transposta do vetor de entrada" " (mtranspose (mident))\n")) ("minverse" ("vetor-matriz" "vetor-matriz" "Retorna o inverso do vetor de entrada." " (minverse (mscale (vector 0.5 2 0.5)))\n")) ("maim" ("vetor-mira vetor-acima" "vetor-matriz" "Retorna uma matriz representando uma rotação de mira de forma que o eixo X aponta pra baixo da direção de mira, e o eixo y aponta pra cima do vetor de cima. Provavelmente sofre do Gimbal Lock." " (maim (vector 0 0 1) (vector 0 1 0))\n")) ("qaxisangle" ("vetor-eixo angulo" "vetor-quaternion" "Retorna o quatérnio representando o ângulo de rotação sobre o eixo especificado." " (qaxisangle (vector 0 1 0) 45)\n")) ("qmul" ("vetor-quatérnio vetor-quatérnio" "vetor-quatérnio" "Multiplica um quatérnio por outro." " (qmul (qaxisangle (vector 0 1 0) 45) (qaxisangle (vector 0 0 1) 180))\n")) ("qnormalise" ("vetor-quatérnio" "vetor-quatérnio" "Normalisa um quatérnio" " (qnormalise (qaxisangle (vector 0 19 0) 45))\n")) ("qtomatrix" ("vetor-quatérnio" "vetor-matriz" "Converte um quatérnio em uma matriz de rotação" " (qtomatrix (qaxisangle (vector 0 1 0) 45))\n")) ("qconjugate" ("vetor-quatérnio" "vetor-quatérnio" "Conjuga um quatérnio" " (qconjugate (qaxisangle (vector 0 1 0) 45))\n"))))) ("PrimitiveData" ("Dados primitivos (pdata para diminuir) é o nome fluxus' para dados que formam primitivas. Em primitivas poligonais isto significa informação dos vértices, em primitivas de partículas isto corresponde a informação da partícula, em primitivas NURBS são os vértices de controle. Acesso a pdata dá a você a habilidade de usar primitivas que de outra forma não seria tão interessante, e deformar e fazer outras primitivas resultando em modelos muito mais detalhados e animações. Você pode também adicionar sua própria pdata, que é tratado exatamente como os tipos já existentes. Dados primitivos são nomeados por strings de tipo, os nomes de qual depende a ordem da primitiva. Todos os comandos Pdata operam na primitiva atualmente pega [grabbed]." "" (("pdata-ref" ("string-tipo número-index" "vetor-valor/cor/matriz/número" "Retorna o elemento pdata correspondente." " (pdata-ref \"p\" 1)\n")) ("pdata-set!" ("string-tipo número-index vetor-valor/cor/matriz/número" "void" "Escreve ao elemento pdata correspondente." " (pdata-set! \"p\" 1 (vector 0 100 0))\n")) ("pdata-add" ("string-tipo nome-string" "void" "Adiciona um novo usuario de disposição ao pdata. Tipo é um dos sequintes \"v\":vector, \"c\":colour, \"f\":float ou \"m\":matrix." " (pdata-add \"v\" \"mydata\")\n (pdata-set \"mydata\" 0 (vector 1 2 3))\n")) ("pdata-op" ("string-nomefunc string-nomepdata operador" "void" "Esta é uma função experimental que permite a você fazer operações na pdata muito rapidamente, para constar adicionar elemento por elemento de uma array de pdata para outra. Você pode implementar isto em scheme como um loop sobre cada elemento, mas isto é devagar já que o interpretador está fazendo todo o trabalho. É muito mais rápido se você puder usar um pdata-op já que a mesma operação vai ser apenas uma chamada à scheme." " (pdata-op \"+\" \"mydata\" (vector 1 2 3))  adiciona um vetor a todos os vetores pdata\n (pdata-op \"+\" \"mydata\" \"myotherdata\")  adiciona dois vetores pdata elemento por elemento\n (pdata-op \"*\" \"mydata\" (vector 1 2 3))  multiplica um vetor a todos os vetores pdata\n (pdata-op \"*\" \"mydata\" \"myotherdata\")  multiplica dois vetores pdata elemento por elemento\n (pdata-op \"closest\" \"p\" (vector 100 0 0))  retorna posição do vertice mais perto a este ponto\n (pdata-op \"sin\" \"mydata\" \"myotherdata\")  seno de um pdata float a outro\n (pdata-op \"cos\" \"mydata\" \"myotherdata\")  cosine of one float pdata to another\n")) ("pdata-copy" ("string-pdata-de string-pdata-para" "void" "Copia o conteúdo de uma array pdata para outra. As arrays tem que ser do mesmo tipo." " (pdata-copy \"p\" \"mydata\") ; copia as posições de vértices para uma array do usuário\n")) ("pdata-size" ("" "número-contador" "Retorna o tamanho das arrays pdata (elas precisam ser todas a mesma). Isto é principal para iterar através das arrays." " (define (mashup n)\n     (pdata-set \"p\" n (vector (flxrnd) (flxrnd) (flxrnd))) ; randomise the vertex position\n     (if (zero? n)\n         0\n         (mashup (- n 1)))) ; loops till n is 0\n\n (define shape (build-sphere 10 10))\n (grab shape)\n (mashup (pdata-size)) ; randomise verts on currently grabbed primitive\n (ungrab)\n")) ("finalise" ("" "void" "Não faz nada mais, precisa ser removido :)" "")) ("recalc-normals" ("número-macioounão" "void" "Para primitivas poligonais apenas. Olha a posição dos vértices e cálcula as normais da luz pra você automaticamente. Chame com \"1\" para normais macias, \"0\" para normais facetadas." " (define shape (build-sphere 10 10)) ; build a sphere (which is smooth by default)\n (grab shape)\n (recalc-normals 0) ; make the sphere faceted\n (ungrab)\n"))))) ("Physics" ("O sistema de física em fluxus é baseado na biblioteca ODE, que permite a você adicionar propriedades físicas a objetos e colocá-los em movimento. Já que ODE foi projetada para simulações em corpos rígidos, estruturas são descritas em termos de objetos, dobras e forças. Uma explicação muito mais compreensiva destes conceitos pode ser encontrada na documentação de ODE, que você provavelmente baixou se teve que compilar fluxus, ou pode ser encontrado em @url{http://ode.org/ode-docs.html} Para ajudar com a depuração de dobras, tente chamar (render-physics) em cada frame, o que vai renderizar locators mostrando a você posições e eixos de dobras que possuem informação posicional." "" (("collisions" ("on/off-número" "void" "Habilita ou desabilita detecção de colisão. Padrão é desligado." " (collisions 1)\n")) ("ground-plane" ("vetor-plano número-offset" "void" "Cria um plano passivo infinito pra usar como 'chão'." " (ground-plane (vector 0 1 0) 0)\n")) ("active-box" ("número-id-primitiva" "void" "Permite que o objeto seja afetado pelo sistema físico, usando uma caixa como um volume limite. Como um objeto ativo, ele vai ser transformado por ODE. Nota: rotações só funcionam corretamente se você específicar suas escalagens primeiro, depois rotacionar (translação não importa) basicamente, ode não pode lidar com tranformações cortadas." " (define mycube (build-cube))\n (active-box mycube)\n")) ("active-cylinder" ("número-id-primitiva" "void" "Permite que o objeto seja afetado pelo sistema físico, usando um cilindro como um volume limite. Como um objeto ativo, ele vai ser transformado por ODE. Nota: rotações só funcionam corretamente se você específicar suas escalagens primeiro, depois rotacionar (translação não importa) basicamente, ode não pode lidar com tranformações cortadas." " (define mycube (build-cube))\n (active-cylinder mycube)\n")) ("active-sphere" ("número-id-primitiva" "void" "Permite que o objeto seja afetado pelo sistema físico, usando uma esfera como um volume limite. Como um objeto ativo, ele vai ser transformado por ODE. Nota: rotações só funcionam corretamente se você específicar suas escalagens primeiro, depois rotacionar (translação não importa) basicamente, ode não pode lidar com tranformações cortadas." " (define mycube (build-cube))\n (active-sphere mycube)\n")) ("passive-box" ("número-id-primitiva" "void" "Permite que o objeto seja resolvido pelo sistema de física, usando uma caixa como o limite. Como um objeto passivo, objetos ativos vão colidir com ele, mas este não vai ser transformado. Nota: rotações só funcionam corretamente se você especificar suas transformaçoes de escala primeiro, depois rotacionar (translação não importa) basicamente, ode não pode lidar com transformações cortadas." " (define mycube (build-cube))\n (passive-box mycube)\n")) ("passive-cylinder" ("número-id-primitiva" "void" "Permite que o objeto seja resolvido pelo sistema de física, usando um cilindro como o limite. Como um objeto passivo, objetos ativos vão colidir com ele, mas este não vai ser transformado. Nota: rotações só funcionam corretamente se você especificar suas transformaçoes de escala primeiro, depois rotacionar (translação não importa) basicamente, ode não pode lidar com transformações cortadas." " (define mycube (build-cube))\n (passive-cylinder mycube)\n")) ("passive-sphere" ("número-id-primitiva" "void" "Permite que o objeto seja resolvido pelo sistema de física, usando uma esfera como o limite. Como um objeto passivo, objetos ativos vão colidir com ele, mas este não vai ser transformado. Nota: rotações só funcionam corretamente se você especificar suas transformaçoes de escala primeiro, depois rotacionar (translação não importa) basicamente, ode não pode lidar com transformações cortadas." " (define mycube (build-cube))\n (passive-sphere mycube)\n")) ("surface-params" ("slip1-número slip2-número softerp-número softcfm-número" "void" "Ajusta alguns parâmetros globais de superfície que afetam o atrito e reflexão. Veja seção 7.3.7 dos docs de ODE para uma explicação desses parâmetros." " (surface-params 0.1 0.1 0.1 0.1)\n")) ("build-balljoint" ("número-id-primitiva número-id-primitiva vetor-eixo" "void" "Cria um balljoint para conectar dois objetos (veja os docs de ode para uma descrição detalhada das diferenças entre os tipos de dobras). ODE considera as juntas(joints) serem uma restrição imposta entre dois objetos. Quando criando uma junção, é importante ter as duas primitivas sendo juntas na posição desejada antes de criar uma junção. Junções podem ser criadas, modificadas e indexadas de uma maneira similar a outras primitivas." " (build-balljoint shape1 shape2 (vector 0 1 0)) \n")) ("build-fixedjoint" ("número-id-primitiva" "void" "Cria uma junção para conectar um objeto ao ambiente global. Isto trava o objeto no lugar." " (build-fixedjoint shape)\n")) ("build-hingejoint" ("numero-id-primitiva1 número-id-primitiva2 vetor-ancora vetor eixo" "void" "Cria uma junção circular para conectar dois objetos ( veja os docs de ODE para uma descrição detalhada entre tipos de junções). ODE considera as juntas(joints) serem uma restrição imposta entre dois objetos. Quando criando uma junção, é importante ter as duas primitivas sendo juntas na posição desejada antes de criar uma junção. Junções podem ser criadas, modificadas e indexadas de uma maneira similar a outras primitivas." " (build-hingejoint shape1 shape2 (vector 0 1 0) (vector 0 1 0)) \n")) ("build-sliderjoint" ("número-id-primitiva1 número-id-primitiva2 vetor-eixo" "hingeid-number" "Cria uma junção deslizante entre dois objetos (veja a documentação de ODE para uma descrição detalhada das diferenças entre os tipos de conexões). ODE considera as juntas(joints) serem uma restrição imposta entre dois objetos. Quando criando uma junção, é importante ter as duas primitivas sendo juntas na posição desejada antes de criar uma junção. Junções podem ser criadas, modificadas e indexadas de uma maneira similar a outras primitivas." " (build-sliderjoint shape1 shape2 (vector 0 1 0)) \n")) ("build-hinge2joint" ("número-id-primitiva1 número-id-primitiva2 vetor-ancora vetor-eixo1 vetor-eixo2" "numero-id-dobradiça(hinge)" "Cria uma dobradiça de junções para conectar dois objetos (veja a documentação de ODE para uma descrição detalhada das diferenças entre os tipos de conexões). ODE considera as juntas(joints) serem uma restrição imposta entre dois objetos. Quando criando uma junção, é importante ter as duas primitivas sendo juntas na posição desejada antes de criar uma junção. Junções podem ser criadas, modificadas e indexadas de uma maneira similar a outras primitivas." " (build-hinge2joint shape1 shape2 (vector 0 100 0) (vector 0 1 0) (vector 0 1 0))\n")) ("build-amotorjoint" ("número-id-primitiva1 número-id-primitiva2 vetor-eixo" "número-id-dobradiça(hinge)" "Cria uma junção com mobilidade angular para conectar dois objetos (veja a documentação de ODE para uma descrição detalhada das diferenças entre os tipos de conexões). ODE considera as juntas(joints) serem uma restrição imposta entre dois objetos. Quando criando uma junção, é importante ter as duas primitivas sendo juntas na posição desejada antes de criar uma junção. Junções podem ser criadas, modificadas e indexadas de uma maneira similar a outras primitivas." " (build-amotorjoint shape1 shape2 (vector 0 1 0))\n")) ("joint-param" ("número-id-junção param-string número-valor" "número-id-dobradiça(hinge)" "Ajusta o parâmetro da junção para uma junta onde param é um dos seguintes: \"HiStop\", \"Vel\", \"FMax\", \"FudgeFactor\", \"Bounce, \"CFM\", \"StopERP\", \"StopCFM\", \"SuspensionERP\", \"SuspensionCFM\", \"Vel2\", \"FMax2\". Veja Seção 7.5.1 da documentação de ODE para uma explicação de cada um desses parâmetros, e a qual tipos de junções eles aplicam." " (joint-param joint \"Vel\" 0.1)\n")) ("joint-angles" ("jointid-number número-angulo número-vel" "void" "Ajusta um novo ângulo para este joint, com uma velocidade dada para chegar lá." " (joint-angle joint 90 0.1)\n")) ("set-max-physical" ("número-max" "void" "Ajusta o máximo número de objetos que o sistema de física pode lidar. Quando o máximo nível foi alcançado os objetos mais antigos são automaticamente destroidos." " (set-max-physical 100)\n")) ("set-mass" ("número-id-primitiva número-massa" "void" "Ajusta a massa de um objeto ativo no sistema de física" " (set-mass myshape 100)\n")) ("gravity" ("vetor-gravidade" "void" "Ajusta a força e direção da gravidade." " (gravity (vector 0 -1 0))\n")) ("kick" ("número-id-primitiva vetor-chute" "void" "Aplica força de translação ao objeto." " (kick myshape (vector 0 1 0))\n")) ("twist" ("número-id-primitiva vetor-giro" "void" "Aplica força rotacional ao objeto" " (twist myshape (vector 2 0 0))\n")) ("has-collided" ("número-id-primitiva" "void" "Retorna verdadeiro se a primitiva pega colidiu no ultimo frame." " (if (has-collided myshape) (display \"bang!\"))\n"))))) ("Primitivas" ("Primitivas são objetos que você pode renderizar. Não há muito mais coisas numa cena do fluxus, exceto luzes, uma camera e muitas primitivas." " build-cube\n build-polygons\n build-sphere\n build-plane\n build-seg-plane\n build-cylinder\n build-line\n build-text\n build-nurbs-sphere\n build-nurbs-plane\n build-particles\n build-locator\n build-pixels\n pixels-upload\n pixels->texture\n build-blobby\n blobby->poly\n draw-instance\n draw-cube \n draw-plane\n draw-sphere\n draw-cylinder\n destroy\n poly-set-index\n poly-convert-to-indexed\n build-copy\n make-pfunc\n pfunc-set!\n pfunc-run\n" (("build-cube" ("" "número-de-id-da-primitiva" "Um simples cubo, mapeamento de textura por face. @image{images/cube}" " (define mynewcube (build-cube))\n")) ("build-polygons" ("número-de-vértices tipo-de-número" "número-de-id-primitiva" "Cónstroi uma primitiva de polígono cru com tamanho de vértices (tudo é inicialmente tido como zero). Tipo é um número que referencia a forma as quais os vértices são interpretados para construir os poligonos, e podem ser os seguintes: 0=TRISTRIP, 1=QUADS, 2=TRILIST, 3=TRIFAN, 4=POLYGON." " (define mynewshape (build-polygons 100 'triangle-strip))\n")) ("build-sphere" ("número-de-cortes-horizontais número-de-cortes-verticais" "número-id-primitiva" "Uma esfera com a resolução especificada, a textura mapeada no estilo normal \"world map\". @image{images/sphere}" " (define mynewshape (build-sphere 10 10))\n")) ("build-plane" ("" "número-id-primitiva" "Um único plano quadrado, mapeado de 0->1 em ambas as dimensões. @image{images/plane}" " (define mynewshape (build-plane))\n")) ("build-seg-plane" ("número-de-vértices-x número-de-vértices-y" "número-id-primitiva" "Um plano poligonal tesselado, mapeado de 0->1 em ambas dimensões." " (define mynewshape (build-plane))\n")) ("build-cylinder" ("h-segmentos r-segmentos" "número-id-primitiva" "Um cilindro coberto, textura mapeada em volta, e mal mapeada em volta do fim. @image{images/cylinder}" " (define mynewshape (build-cylinder 10 10))\n")) ("build-line" ("numpoints-número" "número-id-primitiva" "Cónstroi uma linha consistindo de numpoints pontos. A geometria aponta para a câmera constantemente e a textura é mapeada de forma que se alonga na linha do início ao fim. Você usa as funções pdata para editar as posições e largura das linhas. Se usado iluminado, as normais são falseadas para aproximar uma seção circular cruzada. Adicionalmente, se renderização sólida for limpa com (hint-none) e (hint-wire) ativado, uma rápida linha constante vai ser desenhada - largura específicada pelo comando (line-width). @image{images/line}" " (define mynewshape (build-line 10))\n")) ("build-text" ("string-texto" "número-id-primitiva" "Constrói uma sequencia de planos, mapeados de forma que uma textura de fonte possa ser usada para visualização. Pode vir a ser útil para coisas mais abstratas. A fonte é assumida como não proporcional - tem um exemplo de fonte acompanhando o fluxus. @image{images/text} Ok, so this isn't a very good font texture :)" " (texture (texture-load \"font.png\"))\n (define mynewshape (build-text \"hello\"))\n")) ("build-nurbs-sphere" ("h-segmentos r-segmentos" "número-id-primitiva" "Constrói uma esfera nurbs tesselada, mapead da mesma forma que a esfera poligonal. @image{images/nurbs-sphere}" " (define mynewshape (build-nurbs-sphere 10 10))\n")) ("build-nurbs-plane" ("h-segmento r-segmento" "número-id-primitiva" "Constrói um plano nurbs tesselado, mapeado na direção uv. @image{images/nurbs-plane}" " (define mynewshape (build-nurbs-plane 10 10))\n")) ("build-particles" ("número-contagem" "número-id-primitiva" "Cónstroi uma primitiva de partículas contendo num pontos, tudo inicialmente aplicado à origem. Você usa as funções pdata para editar as posições, cores e tamanhos. Partículas vêm em dois tipos, sprites apontando pra câmera, que são o padrão, podem ser texturizadas e escaladas individualmente; e pontuais (quando hint-points está aplicado), que não podem ser texturizadas mas são muito mais rápidas de renderizar, já que elas são pontos gl suportados pelo hardware. Por defeito essas partículas pontuais são quadradas, ligue hint-anti-alias para faze-las circulares. @image{images/sprites}" " (define mynewshape (build-particles 100))\n")) ("build-locator" ("" "número-id-primitiva" "Um locator é uma primitiva vazia, útil para parentesco (quando você não quer ter o objeto pai visivel). Essa primitiva só pode ser visualizada com (hint-origin) para mostrar sua origem de transformação local." " (define mynewshape (build-locator))\n")) ("build-pixels" ("número-largura número-altura" "número-id-primitiva" "Faz uma nova primitiva pixel. Uma primitiva pixel é usada pra fazer texturas procedurais, que podem então ser aplicadas em outras primitivas. Por essa razão, primitivas pixel não vão ser renderizadas muito, mas você pode renderizar elas para visualizar a texturas em um plano." " (define mynewshape (build-pixels 100 100))\n")) ("pixels-upload" ("" "void" "Traz os dados da textura, você precisa chamar isto quando você finalizou escrever ao pixelprim, e enquanto ele está \"grabbed\"." " (define mynewshape (build-pixels 100 100))\n (pixels-upload mynewshape)\n")) ("pixels->texture" ("número-id-pixelprim" "número-id-textura" "Retorna uma textura que você pode usar exatamente igual uma que foi carregada normalmente." " (define mynewshape (build-pixels 100 100))\n (upload-pixels mynewshape)\n (texture (pixels->texture mynewshape))\n")) ("build-blobby" ("número-influencias vecsubdvision vecfronteira" "número-id-primitiva" "Primitivas blobby no fluxus são uma representação de superfície implicita de alto nível que é definida usando influências no espaço em 3 dimensões. Estas influências são então somadas, e um valor particular é \"malheado\" (usando o algorítmo dos cubos marchando) para formar uma superfície macia. Estas influências podem ser animadas, e a superfície macia mexe e deforma para adaptar, dando a primitiva seu nome blobby. build-blobby retorna uma nova primitiva blobby. número-influências é o número de \"blobs\", Subdivisão permite a você controlar a resolução da superfície em cada dimensão, enquanto vecfronteira ajusta a área fronteriça da primitiva em espaço de objeto local. A malha não vai ser calculada fora desta área limite. Influências de cores e posições precisam ser ajustadas usando pdata-set." " (define mynewshape (build-blobby 7 (vector 30 30 30) (vector 3 3 3)))\n")) ("blobby->poly" ("número-id-blobbyprimitiva" "número-id-primitivapoly" "Converte a malha de uma primitiva blobby em uma primitiva poligonal de lista de triângulos." " (define mynewshape (blobby->poly myblobby))\n")) ("draw-instance" ("número-id-primitiva" "void" "Copia um modo retido da primitiva e desenha ela no estado corrente como um no modo imediato." " (define mynewshape (build-cube))\n (colour (vector 1 0 0))\n (draw-instance mynewshape) ; draws a copy of mynewshape\n")) ("draw-cube" ("" "void" "Desenha um cubo no estado imediato corrente." " (define (render)\n     (draw-cube))\n (every-frame (render))\n")) ("draw-plane" ("" "void" "Desenha um plano no estado corrente em modo imediato" " (define (render)\n     (draw-plane))\n (every-frame (render))\n")) ("draw-sphere" ("" "void" "Desenha uma esfera no estado corrente em modo imediato." " (define (render)\n     (draw-sphere))\n (every-frame (render))\n")) ("draw-cylinder" ("" "void" "Desenha um cilindro no estado corrente em modo imediato." " (define (render)\n     (draw-cylinder))\n (every-frame (render))\n")) ("destroy" ("número-id-primitive" "void" "Deleta uma primitiva construída do renderizador." " (define mynewshape (build-sphere 10 10))\n (destroy mynewshape)\n")) ("poly-set-index" ("lista-indexada" "void" "Troca a primitiva por modo indexado,e usa a lista como valores de index para essa primitiva." " (clear)\n (define p (build-polygons 8 1))\n \n (grab p)\n ; setup the vertex data\n (pdata-set \"p\" 0 (vector -1 -1 -1))\n (pdata-set \"p\" 1 (vector  1 -1 -1))\n (pdata-set \"p\" 2 (vector  1 -1  1))\n (pdata-set \"p\" 3 (vector -1 -1  1))\n (pdata-set \"p\" 4 (vector -1  1 -1))\n (pdata-set \"p\" 5 (vector  1  1 -1))\n (pdata-set \"p\" 6 (vector  1  1  1))\n (pdata-set \"p\" 7 (vector -1  1  1))\n \n (hint-wire)\n (hint-unlit)\n \n ; connect the verts together into faces\n (poly-set-index (list 7 6 5 4  5 6 2 1 \n                        4 5 1 0  1 2 3 0\n                        3 7 4 0  6 7 3 2))\n \n (ungrab)\n")) ("poly-convert-to-indexed" ("" "void" "Converte o atual poligono primitivo que está \"grabbed\" de arrays de vértices crus para arrays indexadas. Isto remove vértices duplicados do polígono, fazendo a array de pdata menor, o que aumenta a velocidade do processo." " (define mynewshape (build-sphere 10 10))\n (grab mynewshape)\n (poly-convert-to-indexed)\n (ungrab)\n")) ("build-copy" ("número-primitiva-fonte" "número-id-primitiva" "Retorna uma cópia da primitiva" " (define mynewshape (build-sphere 10 10))\n (define myothernewshape (build-copy mynewshape))\n")) ("make-pfunc" ("string-nome" "número-pfuncid" "Faz uma nova primitiva funcional. Pfuncs variam de propósito geral até operações complexas e especializadas que você pode rodar em primitivas. Todas as pfuncs dividem a mesma interface para controlar e ajustar - pfunc-set! Todos os tipos e argumentos pfunc são como os seguintes: arithmetic Para aplicar aritmética geral para qualquer array pdata. operator string : um dos add sub mul div src string : nome pdata array other string : nome pdata array (opcional) constant float : valor constante (opcional) dst string : nome pdata array genskinweights Gera pesos de skinning - adiciona float pdata chamada \"s1\" -> \"sn\" aonde n é o número de nós no esqueleto - 1 skeleton-root primid-number : a raiz da posebind do esqueleto para skinning sharpness float : um controle de quão afiado o vinco vai ser quando \"skineado\". skinweights->vertcols Uma utilidade para visualizar pesos de skin para debugar. sem argumentos. skinning Skin uma primitiva - deforma ela para seguir os movimentos de um esqueleto. Primitivas que a gente quer usar isto deve conter extra pdata - cópias das posições iniciais das posições dos vértices chamadas \"pref\" e o mesmo para normais, se as normais estão sendo skineadas , chamada \"nref\". skeleton-root primid-number : a primitiva raiz do esqueleto animado bindpose-root primid-number : a raiz primitiva da pose bind do esqueleto skin-normals number : se devemos usar skin nas normais como nas posições" " (define mypfunc (make-pfunc 'arithmetic))\n")) ("pfunc-set!" ("número-id-pfunc lista-argumento" "void" "Ajusta argumentos na função primitiva. Veja a documentação de make-pfunc para todos os argumentos." " (define mypfunc (make-pfunc 'arithmetic))\n (pfunc-set! mypfunc (list 'operator \"add\"\n                           'src \"p\"\n                           'const 0.4\n                           'dst \"p\"))\n")) ("pfunc-run" ("número-id" "void" "Roda uma função primitiva na primitiva atualmente pega." " (define mypfunc (make-pfunc \"arithmetic\"))\n"))))) ("Turtle" ("O construtor polygonal Turtle é um modo experimental de construir objetos poligonais usando uma tartaruga do estilo logo no espaço 3d. Em que você pode dirigir a tartaruga ao redor colocando vértices e construindo formas proceduralmente. A tartaruga também pode ser usa para deformar objetos poligonais existentes, fixando ela a objetos que você já criou." "" (("turtle-prim" ("número-tipo" "void" "Inicia a construção de uma nova primitiva poligonal com a tartaruga. O tipo especifica o tipo da face do poligono e é um dos seguintes: 0: triangle strip, 1: quad list, 2: triangle list, 3: triangle fan, 4: general polygon" " (turtle-prim 0)\n")) ("turtle-vert" ("" "void" "Cria um novo vértice na posição atual, ou ajusta o vértice atual se o construtor tartaruga estiver fixado." " (turtle-vert)\n")) ("turtle-build" ("" "void" "Constrói o objeto com a lista de vértices definida e dá isto ao renderizador. Não tem efeito se o construtor tartaruga estive fixado a uma primitiva." " (define mynewshape (turtle-build))\n")) ("turtle-move" ("número-distância" "void" "Move a tartaruga pra frente na sua orientação atual." " (turtle-move 1)\n")) ("turtle-push" ("" "void" "O construtor tartaruga tem sua própria pilha de transformações, Push lembra a posição atual e orientação." " (turtle-push)\n")) ("turtle-pop" ("" "void" "O construtor tartaruga tem sua própria pilha de transformações. Pop esquece a posição atual e orientação, e vai de volta para o estado do último push." " (turtle-pop)\n")) ("turtle-turn" ("vetor-rotação" "void" "Rotaciona a orientação da tartaruga com o ângulos euler fornecidos (rotações em x, y e z)" " (turtle-turn (vector 45 0 0))\n")) ("turtle-reset" ("" "void" "Reinicia a atual posição e rotação da tartaruga para a origem." " (turtle-reset)\n")) ("turtle-attach" ("número-id-primitiva" "void" "Anexa a tartaruga a uma primitiva poligonal existente. Isso significa que você será capaz de deformar pontos de objetos existentes usando o construtor tartaruga." " (define myshape (build-sphere 10 10))\n (turtle-attach myshape)\n")) ("turtle-skip" ("número-contador" "void" "Quando anexado, faz com que a tartaruga pule vértices. Este valor pode ser negativo, o que vai resultar na tartaruga escrevendo para vértices anteriores." " (turtle-skip -1)\n")) ("turtle-position" ("" "void" "Quando anexado, retorna o índice atual da pdata que a tartaruga esta escrevendo para." " (display (turtle-position))(newline)\n")) ("turtle-seek" ("número-posição" "void" "Quando anexado, ajusta o índice absoluto da pdata que a tartaruga está escrevendo para." " (turtle-seek 0)\n"))))) ("UtilFunctions" ("Fun????es pr??ticas para fazer a sua vida mais f??cil." " time\n delta\n flxrnd\n flxseed\n searchpaths\n fullpath\n framedump\n" (("time" ("" "numero do tempo(transcorrido, passado)" "Retorna o numero de segundos (+ fracao) desde meia noite do dia 1 de janeiro de 1970. Essa e a forma mais simples de animacao para seus scripts" " (define (animate)\n     (rotate (vector (sin (time)) 0 0))\n     (draw-cube))\n (every-frame (animate))    \n")) ("delta" ("" "numero do tempo(transcorrido, passado)" "Tempo em segundos desde o ultimo frame. Usado pra fazer animacoes com taxa de frames independendente(constante)." " (define (animate)\n     (rotate (* (delta) 10) 0 0) \n     (draw-cube))\n (every-frame (animate))    \n")) ("flxrnd" ("" "n??mero rand??mico" "Retorna um n??mero rand??mico entre 0 e 1." " (define (animate)\n     (colour (flxrnd) (flxrnd) (flxrnd)) \n     (draw-cube))\n (every-frame (animate))\n")) ("flxseed" ("n??mero da semente" "void" "Alimenta o gerador de n??mero rand??mico de forma que n??s consigamos a mesma sequ??ncia." " (define (animate)\n     (colour (flxrnd) (flxrnd) (flxrnd)) \n     (draw-cube))\n (flxseed 10) \n (every-frame (animate)) ; a mesma sequ??ncia de cores ser?? gerada\n")) ("searchpaths" ("lista de diret??rios" "void" "Arranja um lista de diret??rios de busca para procurar por arquivos relacionado ao fluxus, como texturas, shaders etc. Os diret??rios ser??o procurados em ordem a cada vez." " (searchpaths (list \"/path/to/my/textures\" \"/path/to/my/other/textures\"))\n")) ("fullpath" ("string do nome do arquivo" "fullpath-string" "Busca os diret??rios de procura para o arquivo especificado e retorna a primeira localiza????o que encontra." " (fullpath \"myfile\")\n")) ("framedump" ("nome-do-arquivo" "void" "Salva o buffer OpenGL da frente no disco. L?? a extens??o do arquivo pra decidir qual qual formato ser?? usado pra salvar, \"tif\", \"jpg\" ou \"ppm\" s??o suportados. Esta ?? a forma de frame dumping de baixo nivel, use start-framedump e end-framedump ao inv??s." " (framedump \"picture.jpg\")\n"))))) ("OSC" ("OSC significa Open Sound Control, e é um protocolo amplamente usado para passar dados entre aplicações multimidia. Fluxus pode enviar e/ou receber mensagens." " Um exemplo de uso de osc para comunicar entre pd e fluxus.\n Um script fluxus para mover um cubo baseado em mensagens osc\n entrando.\n -- osc.scm\n\n (define value 0)\n\n (define (test)\n     (push)\n     (if (osc-msg \"/zzz\")\n         (set! value (osc 0)))\n     (translate (vector 1 0 value))\n     (draw-cube)\n     (pop))\n \n (osc-source \"6543\")\n (every-frame (test))\n \n --- EOF\n Um patch PD para enviar mensagens de controle ao fluxus:\n --- zzz.pd\n #N canvas 618 417 286 266 10;\n #X obj 58 161 sendOSC;\n #X msg 73 135 connect localhost 6543;\n #X msg 58 82 send /zzz \\$1;\n #X floatatom 58 29 5 0 0 0 - - -;\n #X obj 58 54 / 100;\n #X obj 73 110 loadbang;\n #X connect 1 0 0 0;\n #X connect 2 0 0 0;\n #X connect 3 0 4 0;\n #X connect 4 0 2 0;\n #X connect 5 0 1 0;\n" (("osc-source" ("string-porta" "void" "Inicia o servidor osc, ou muda a porta. Bug conhecido: parece falhar se você usa de volta pra uma mesma porta já usada anteriormente." " (osc-source \"4444\")\t ; listen to port 4444 for osc messages\n")) ("osc-msg" ("string-nome" "void" "Retorna verdadeiro se a mensagem foi recebida desde o último quadro, e ajusta ela como a mensagem atual para chamadas subsequente ao (osc) para ler argumentos." " (cond \n     ((osc-msg \"/hello\")              ; if a the /hello message is recieved\n         (display (osc 1))(newline)))\t; print out the first argument\n")) ("osc" ("número-argumento" "void" "Retorna o argumento da mensagem osc atual." " (cond \n     ((osc-msg \"/hello\")              ; if a the /hello message is recieved\n         (display (osc 1))(newline)))\t; print out the first argument\n")) ("osc-destination" ("string-porta" "void" "Específica o destino para mensagens osc que estejam saindo. O nome da porta precisa ser específicado com todo o url e deve ser algo do tipo \"osc.udp://localhost:4444\"" " (osc-destination \"osc.udp:localhost:4444\")\n (osc-send \"/hello\" \"s\" (list \"boo!\"))  ; send a message to this destination\n")) ("osc-peek" ("" "msg-string" "Esta útil função retorna o nome, formato da string e número/string dos argumentos da última mensagem enviada como uma string - para debugar sua rede osc." " (display (osc-peek))(newline) \n")) ("osc-send" ("string-nome string-formato lista-argumento" "void" "Envia uma mensagem osc com o argumento da lista como dado osc. Somente suporta floats, ints e strings como dados. O formato-string deve ser composto de \"i\", \"f\" e \"s\", e deve bater com os tipos dados na lista. Isto poderia ser removido provavelmente, usando os tipos diretamente, mas fazendo isto desta forma permite que você diga o tipo da mensagem osc explicitamente." " (osc-destination \"osc.udp:localhost:4444\")\n (osc-send \"/hello\" \"sif\" (list \"boo!\" 3 42.3))  ; send a message to this destination\n"))))) ("ScratchPad" ("O scratchpad é o editor fluxus e a janela gl. Example: EndSectionDoc (module scratchpad mzscheme (require fluxus-engine) (require fluxus-audio) ; todo: get rid of burnt in versions (require (lib \"scratchpad-input.ss\" \"fluxus-0.13\")) (require (lib \"scratchpad-camera.ss\" \"fluxus-0.13\")) (require (only (lib \"13.ss\" \"srfi\") string-pad)) (provide fluxus-reshape-callback fluxus-input-callback fluxus-input-release-callback fluxus-frame-callback override-frame-callback set-user-callback! every-frame clear start-framedump end-framedump get-eye-separation set-eye-separation init-help help) ;------------------------------------------------- ; every frame stuff (define user-callback '()) (define (set-user-callback! s) (set! user-callback s)) StartFunctionDoc-en every-frame callback-function Returns: void Description: Sets a function to be called every time the render is about to draw a new frame. Example: (define count 0) (define (myfunc) (display count)(display \" frames have been rendered!\") (newline) (set! count (+ count 1))) (every-frame (myfunc)) EndFunctionDoc StartFunctionDoc-pt every-frame função-callback Retorna: void Descrição: Ajusta uma função pra ser chamada todo o tempo em que o render está para desenhar um novo quadro." "   (define count 0)\n  \n   (define (myfunc)\n       (display count)(display \" frames have been rendered!\")\n       (newline)\n       (set! count (+ count 1)))\n  \n   (every-frame (myfunc)) \n   EndFunctionDoc\n  ; define the every-frame syntax\n  (define-syntax every-frame\n    (syntax-rules ()\n      ((every-frame expr)\n       (set-user-callback! (lambda () expr)))))\n  \n   StartFunctionDoc-en\n   clear\n   Returns: void\n   Description:\n   Clears out the renderer of all objects and lights. Clears the physics system\n   and resets the every-frame callback. Generally a Good Thing to put this at the\n   beginning of scripts to make sure everything is cleared out each time you execute.\n   Example:   (clear) ; without this we would accumulate a new cube every time F5 was pressed\n   (build-cube) \n   EndFunctionDoc\n  \n   StartFunctionDoc-pt\n   clear\n   Retorna: void\n   Descrição:\n   Limpa o renderizador de todos os objetos e luzes. Limpa o sistema\n   de física e re-inicializa a chamada de volta em\n   every-frame. Geralmente uma boa coisa a fazer é colocar isto no\n   ínicio dos scripts pra ter certeza que tudo esta limpo cada vez\n   que você chamar a execução.\n   Exemplo:   (clear) ; sem isso a gente ia acumular um novo cubo toda vez que F5 fosse pressionado\n   (build-cube) \n   EndFunctionDoc\n  (define (clear)\n    (set! user-callback '())\n    (clear-engine)\n    (unlock-camera))\n  \n  (define width 0)\n  (define height 0)\n  \n  (define framedump-frame -1)\n  (define framedump-filename \"\")\n  (define framedump-type \"\")\n  \n   StartFunctionDoc-en\n   start-framedump name-string type-string\n   Returns: void\n   Description:\n   Starts saving frames to disk. Type can be one of \"tif\", \"jpg\" or \"ppm\". \n   Filenames are built with the frame number added, padded to 5 zeros.\n   Example:   (start-framedump \"frame\" \"jpg\") \n   EndFunctionDoc\n  \n   StartFunctionDoc-pt\n   start-framedump string-nome string-tipo\n   Retorna: void\n   Descrição:\n   Inicia a gravação de quadros no disco. Tipo pode ser um dos:\n   \"tif\", \"jpg\" ou \"ppm\". Nomes dos arquivos são construidos junto\n   com o número do quadro adicionado, prefixado em 5 zeros.\n   Exemplo:   (start-framedump \"frame\" \"jpg\")\n   EndFunctionDoc\n  (define (start-framedump filename type)\n    (set! framedump-frame 0)\n    (set! framedump-filename filename)\n    (set! framedump-type type))\n  \n   StartFunctionDoc-en\n   end-framedump \n   Returns: void\n   Description:\n   Stops saving frames to disk. \n   Example:   (end-framedump) \n   EndFunctionDoc\n\n   StartFunctionDoc-pt\n   end-framedump\n   Retorna: void\n   Descrição:\n   Para a gravação de quadros para o disco.\n   Exemplo:   (end-framedump)\n   EndFunctionDoc  \n  (define (end-framedump)\n    (set! framedump-frame -1))\n  \n  (define (framedump-update)\n    (cond \n      ((>= framedump-frame 0)\n       (let ((filename (string-append framedump-filename \n                                      (string-pad (number->string framedump-frame) 5 #\\0) \n                                      \".\" framedump-type)))\n         (display \"saving frame: \")(display filename)(newline)\n         (framedump filename)\n         (set! framedump-frame (+ framedump-frame 1))))))\n  \n  ;-------------------------------------------------\n  ; online help system\n      \n  (define helpmap '())\n  \n  (define (insert-linebreaks src dst count i n)\n    (if (>= i (string-length src))\n        dst\n        (if (and (> n count) (char=? (string-ref src i) #\\space))\n            (insert-linebreaks src \n                               (string-append dst (string (string-ref src i)) (string #\\newline)) count (+ i 1) 0)\n            (insert-linebreaks src \n                               (string-append dst (string (string-ref src i))) count (+ i 1) (+ n 1)))))\n \n  (define (func-help funcname)  \n    (define (inner-help l)\n      (let ((ret (assoc funcname (list-ref (cadr (car l)) 2))))\n        (cond\n          (ret\n           (display \"Function\")(newline)\n           (display \"(\")(display (car ret))\n           (let ((arguments (list-ref (list-ref ret 1) 0)))\n             (cond \n               ((not (zero? (string-length arguments)))\n                (display \" \")\n                (display arguments))))\n           (display \")\")(newline)(newline)\n           (display \"Returns \")\n           (display (list-ref (list-ref ret 1) 1))(newline)(newline)\n           (display \"Description\")(newline)\n           (display (insert-linebreaks (list-ref (list-ref ret 1) 2) \"\" 50 0 0))\n           (newline)(newline)\n           (display \"Example\")(newline)           (display (list-ref (list-ref ret 1) 3))\n           (newline))\n          (else\n           (if (null? (cdr l))\n               \"Function not found\"\n               (inner-help (cdr l)))))))\n    (cond \n      ((null? helpmap)\n       (display \"No helpmap exists...\")(newline)\n       (display \"Try running \\\"makedocs.sh\\\" in the fluxus docs directory\")(newline))\n      (else\n       (inner-help helpmap))))\n\n  ; just print out the example for (preformatted) documentation which isn't\n  ; really a function - need to do this in a more general way...!\n  (define (func-help-example funcname)  \n    (define (inner-help l)\n      (let ((ret (assoc funcname (list-ref (cadr (car l)) 2))))\n        (cond\n          (ret\n           (display (list-ref (list-ref ret 1) 3))\n           (newline))\n          (else\n           (if (null? (cdr l))\n               \"Function not found\"\n               (inner-help (cdr l)))))))\n    (cond \n      ((null? helpmap)\n       (display \"No helpmap exists...\")(newline)\n       (display \"Try running \\\"makedocs.sh\\\" in the fluxus docs directory\")(newline))\n      (else\n       (inner-help helpmap))))\n  \n  (define (init-help helpmapfile)\n    (cond \n      ((file-exists? helpmapfile)\n       (let ((file (open-input-file helpmapfile)))\n         (set! helpmap (read file))\n         (close-input-port file)))))\n\n  ; (these aren't really functions, but the documentation printed when you\n  ; type (help) for more general things - maybe I need to make the documentation \n  ; more general to cope better with bits of extra documentation like this)\n  ; -greb- i agree here, not that it is bad as it is, what we need are\n  ; ways to navigate trough functions definitions, perhaps we could\n  ; make it more fancy using those \"thought bubbles\" and make it\n  ; toggleable  to appear with a key like F1 when the cursor is over a\n  ; function name? (just an idea)\n  \n   StartFunctionDoc-en\n   tophelp\n   Returns: \n   Description:\n   Example:   Fluxus documentation\n   --------------------\n   \n   Fluxus is a realtime rendering engine for livecoding in Scheme.\n   \n   The fluxus scratchpad has two modes of operation, the console\n   (you are using this now) which allows you to enter commands and\n   see the results immediately. The other mode is the editor which \n   is more like a normal text editor - there are 9 workspaces,\n   (which allow you to edit more than one script at once) switch to \n   them using ctrl-1 to ctrl-9 and switch back to the console with \n   ctrl-0.\n  \n   More help topics:\n   (help \"keys\") for keyboard commands for controlling fluxus \n   (help \"console\") for more help on the console \n   (help \"editor\") for more help on the livecoding editor\n   (help \"camera\") for help on the camera controls \n   (help \"functionname\") to find out more information about a function\n   (help \"misc\") for miscellaneous fluxus info \n   EndFunctionDoc\n  \n   StartFunctiondoc-pt\n   tophelp\n   Retorna:\n   Descrição:\n   Exemplo:   Fluxus docs\n   -----------\n   Fluxus é uma máquina de renderização em tempo real para\n   livecoding em Scheme.\n   \n   O scratchpad de Fluxus têm dois modos de operação, o console\n   (você está usando ele agora) que permite que você entre comandos\n   e veja o resultado imediatamente. O outro modo é o editor que se\n   parece mais com um editor de texto normal -  você tem 9 áreas de\n   trabalho( que permite que você edite mais de um script de uma\n   vez) vá para eles usando ctrl-1 até ctrl-9 e venha de volta para\n   o console através do atalho ctrl-0.                                   \n  \n   Mais tópicos de ajuda:\n   (help \"keys\") para comandos do teclado que controlam o fluxus.\n   (help \"console\") para mais ajuda sobre o console\n   (help \"editor\") para mais ajuda no editor de livecoding\n   (help \"camera\") para ajuda nos controles da câmera.\n   (help \"functionname\") para encontrar mais informação sobre uma função.\n   (help \"misc\") para informações miscelâneas sobre o fluxus\n   EndFunctionDoc\n   StartFunctionDoc-en\n   keys\n   Returns: \n   Description:\n   Example:   Fluxus keys\n   -----------\n  \n   ctrl-f : Fullscreen mode.\n   ctrl-w : Windowed mode.\n   ctrl-h : Hide/show the editor.\n   ctrl-l : Load a new script (navigate with cursors and return).\n   ctrl-s : Save current script.\n   ctrl-d : Save as - current script (opens a filename dialog).\n   ctrl-1 to 9 : Switch to selected workspace.\n   ctrl-0 : Switch to the REPL.   F3 : Resets the scene camera.\n   F5 : Executethe selected text, or all if none is selected.\n   F9 : Randomise the text colour (aka the panic button)\n   F10-F11 : Make text thinner/thicker (these two are for use with\n   projectors to make the text more visible)\n   EndFunctionDoc \n   StartFunctionDoc-pt\n   keys\n   Retorna: \n   Descrição:\n   Exemplo:   Teclas do Fluxus\n   ----------------\n   \n   ctrl-f : modo Tela cheia.\n   ctrl-w : modo Janela.\n   ctrl-h : esconder/mostrar o editor.\n   ctrl-l : Carregar um novo script (navegue com os cursores e enter)\n   ctrl-s : Salve o script atual.\n   ctrl-d : Salvar como - o script atual (abre um caixa com nome)\n   ctrl-1 to 9 : Vai para a área de trabalho selecionada.\n   ctrl-0 : Vai para o REPL.   F3 : Reinicia a câmera.\n   F5 : Executao texto selecionado, ou tudo se não tem nada selecionado.\n   F9 : Randomisa a cor do texto (aka botão panico)\n   F10-F11 ; Faz o texto mais fino/grosso (estes dois são para uso com\n   projetores para fazer com que o texto fique visivel)\n   EndFunctionDoc\n   StartFunctionDoc-en\n   console\n   Returns: \n   Description:\n   Example:   Fluxus console (or REPL)\n   ------------------------\n  \n   If you press ctrl and 0, instead of getting another script workspace, \n   you will be presented with a Read EvaluatePrint Loop interpreter, or \n   repl for short. This is really just an interactive interpreter similar \n   to the commandline, where you can enter scheme code for immediate \n   evaluation. This code is evaluated in the same interpreter as the other \n   scripts, so you can use the repl to debug or inspect global variables \n   and functions they define. This window is also where error reporting is\n   printed, along with the terminal window you started fluxus from.\n   EndFunctionDoc\n\n   StartFunctionDoc-pt\n   console\n   Retorna: \n   Descrição:\n   Exemplo:   Console do Fluxus (ou REPL)   ---------------------------\n  \n   Se você pressionar ctrl e 0, ao invés de abrir outra área de\n   trabalho para scripts você vai ser apresentado a um interpretador\n   de Leitura EvaluaçãoImpressão e Loop, ou repl por\n   diminutivo. Isto realmente é um interpretador interativo similar\n   a uma linha de comando, onde você pode entrar código scheme para\n   evaluação imediata. Estecódigo é evaluado no mesmo interpretador\n   que os outros scripts, então você pode usar o repl para debug ou\n   inspecionar variáveis globais e funções que elas definem. Esta   janela é também onde todo os erros são impressos, junto com a\n   janela de terminal que você iniciou o fluxus.\n   EndFunctionDoc\n   StartFunctionDoc-en\n   editor\n   Returns: \n   Description:\n   Example:   Fluxus editor \n   -------------\n  \n   When using the fluxus scratchpad, the idea is that you only need the one \n   window to build scripts, or play live. f5 is the key that runs the script \n   when you are ready.  Selecting some text (using shift) and pressing f5 will \n   execute the selected text only. This is handy for reevaluating functions \n   without running the whole script each time.\n  \n   Workspaces\n   ----------\n  \n   The script editor allows you to edit 9 scripts simultaneously by using\n   workspaces. To switch workspaces, use ctrl+number key. Only one can be run \n   at once though, hitting f5 will execute the currently active workspace\n   script. \n   EndFunctionDoc\n\n   StartFunctionDoc-pt\n   editor\n   Retorna: void\n   Descrição:\n   Exemplo:   EditorFluxus\n   -------------\n  \n   Quando usar o scratchpad do fluxus, a idéia é que você só precise\n   da única tela para construir os scripts, ou tocar ao vivo, F5 é a\n   chave que roda o script quando vc estiver pronto. Selecionando\n   texto (usando shift) e pressionando F5 vai executar somente o\n   texto selecionado. Isto é uma mão na roda para re-evaluar funções\n   sem rodar o script inteiro toda vez.\n  \n   Áreas de trabalho\n   -----------------\n  \n   O editor de script permite que voce edite até 9 scripts\n   simultaneamente usando diferentes áreas de trabalho. Para trocas\n   de área, use ctrl+tecla de número. Somente um script pode rodar\n   de uma vez no entanto, apertando F5 vai executar o script da área\n   de trabalho ativa atualmente.\n   EndFunctionDoc\n   StartFunctionDoc-en\n   camera\n   Returns: \n   Description:\n   Example:   Fluxus camera control\n   ---------------------\n  \n   The camera is controlled by moving the mouse and pressing mouse buttons.\n  \n   Left mouse button: Rotate\n   Middle mouse button: Move\n   Right mouse button: Zoom\n   EndFunctionDoc\n   StartFunctionDoc-pt\n   camera\n   Retorna: void\n   Descrição:\n   Exemplo:   Fluxus camera control\n   ---------------------\n   \n   A câmera é controlada ao mover o mouse e pressionar os botões ao\n   mesmo tempo.\n  \n   Botão esquerdo do mouse: Rotaciona\n   Botão do meio do mouse: Movimenta\n   Botão direito do mouse: Afasta/Aproxima(zoom)\n   EndFunctionDoc\n   StartFunctionDoc-en\n   misc\n   Returns: \n   Description:\n   Example:   Misc\n   ----\n  \n  \n   EndFunctionDoc\n   StartFunctionDoc-pt\n   misc\n   Retorna: void\n   Descrição:\n  \n   Exemplo:   Misc\n   ----\n  \n  \n   EndFunctionDoc\n   StartFunctionDoc-en\n   help function-string\n   Returns: void\n   Description:\n   Displays help information on a fluxus function. For running in the repl mainly.\n   Example:   (help \"pop\") \n   EndFunctionDoc\n\n   StartFunctionDoc-pt\n   help string-função\n   Retorna: void\n   Descrição:\n   Mostra informação de ajuda numa função do fluxus. Para rodar no\n   repl principalmente.\n   Exemplo:   (help \"pop\")\n   EndFunctionDoc  \n  (define (help . args)\n    (if (null? args) ; help without an argument prints out some \n        (func-help-example \"tophelp\")   ; top level help information (defined above)\n        (cond\n          ((string=? (car args) \"keys\") (func-help-example (car args)))\n          ((string=? (car args) \"console\") (func-help-example (car args)))\n          ((string=? (car args) \"editor\") (func-help-example (car args)))\n          ((string=? (car args) \"camera\") (func-help-example (car args)))\n          ((string=? (car args) \"misc\") (func-help-example (car args)))\n          (else\n           (func-help (car args))))))\n  \n  ;-------------------------------------------------\n  ; stereo mode\n  \n  (define eye-separation 0.3)\n  (define (get-eye-separation) eye-separation)\n  (define (set-eye-separation val) (set! eye-separation val))\t\n  \n  (define (stereo-render)\n    (let ((stereo-mode (get-stereo-mode))\n\t\t  (half_sep (/ (get-eye-separation) 2))\n          (left-eye-colour-mask #(#t #f #f #t))\n          (right-eye-colour-mask #(#f #f #t #t)))\n      (cond \n        ((eq? stereo-mode 'crystal-eyes)\n         ; draw for left eye\n         (draw-buffer 'back-left)\n         (set-camera \n          (mmul \n           (mtranslate (vector (- half_sep) 0 0))\n           (get-camera-transform)))\n         (if (not (null? user-callback))\n             (user-callback))\n         (fluxus-render)\n         \n         ; draw for right eye\n         (draw-buffer 'back-right)\n         (set-camera \n          (mmul \n           (mtranslate (vector half_sep 0 0))\n           (get-camera-transform)))\n         (if (not (null? user-callback))\n             (user-callback))\n         (fluxus-render)\n         \n         ; reset for other drawing\n         (draw-buffer 'back))\n        \n\t((eq? stereo-mode 'colour)\n         ;left\n         (set-colour-mask left-eye-colour-mask)\n\t\t (clear-frame 1)\n         (set-camera \n          (mmul \n           (mtranslate (vector (- half_sep) 0 0))\n           (get-camera-transform)\n           ))\n         (if (not (null? user-callback))\n             (user-callback))\n         (fluxus-render)\n         \n         ;right\n         (set-colour-mask right-eye-colour-mask)\n\t\t (clear-frame 0)\n         (set-camera \n          (mmul \n           (mtranslate (vector half_sep 0 0))\n           (get-camera-transform)\n           ))\n         (if (not (null? user-callback))\n             (user-callback))\n         (fluxus-render)\n         ;reset\n         (set-colour-mask #(#t #t #t #t))))))\n  \n  ;-------------------------------------------------\n  ; callback-override\n  \n   StartFunctionDoc-en\n   callback-override callback-function\n   Returns: void\n   Description:\n   Allows you to override the frame callback, to control\n   the rendering loop of fluxus in a more detailed way.\n   Example:   (callback-override myfunc) \n   EndFunctionDoc\n\n   StartFunctionDoc-pt\n   callback-override\n   Retorna: void\n   Descrição:\n   Permite que você substitua a chama de volta (callback) do quadro,\n   para controlar o loop de renderização do fluxus de uma forma mais detalhada.\n   Exemplo:   (callback-override myfunc)\n   EndFunctionDoc  \n  (define (override-frame-callback fn)\n  \t(set! fluxus-frame-callback fn))\n  \n  ;-------------------------------------------------\n  ; callbacks - these are called directly from the\n  ; fluxus application\n  \n  ; reshape function\n  \n  (define (fluxus-reshape-callback x y)\n    (set! width x)\n    (set! height y)\n    (reshape x y))\n  \n  ; input functions\n  \n  (define (fluxus-input-callback key button special state x y mod)\n    (register-down key button special state x y mod)\n    (input-camera key button special state x y mod width height))\n  \n  (define (fluxus-input-release-callback key button special state x y mod)\n    (register-up key button special state x y mod))\n  \n  ; the main callback every frame\n  \n  (define (fluxus-frame-callback) \n  \t(identity) ; clear the last transform (I can't decide if this should \n\t           ; be the standard behavour, so it's here for now)\n    (cond \n      ((eq? (get-stereo-mode) 'no-stereo)\n\t        (draw-buffer 'back)\n            (set-camera (get-camera-transform))\n            (framedump-update)\n            (if (not (null? user-callback))\n               (user-callback))\n            (fluxus-render)\n            (tick-physics)\n            (update-audio))\n      (else\n       (stereo-render)))\n\t (display (fluxus-error-log)))\n  " ())))