fluxa documentation
-------------------

an experimental non-deterministic synth where each 'note' is it's own synth graph

fluxa is a framework for constructing and sequencing sound. it uses a minimal and
purely functional style which is designed for livecoding. it can be broken down into
two parts, the descriptions of synthesis graphs and a set of language forms for
describing procedural sequences.

(fluxa is also a kind of primitive homage to supercollider - see also rsc,
which is a scheme binding to sc)

example:

(require (lib "fluxa.ss" "fluxus-0.14"))

(seq
  (lambda (time clock)
    (play time (mul (sine 440) (adsr 0 0.1 0 0)))
    0.2))

plays a sine tone with a decay of 0.1 seconds every 0.2 seconds

non-determinism
---------------

fluxa has decidedly non-deterministic properties - synth lifetime is bound to
some global constraints:

* a fixed number of operators, which are recycled (allocation time/space constraint)
* a maximum number of synths playing simultaneously (cpu time constraint)

what this means is that synths are stopped after a variable length of time,
depending on the need for new operators. nodes making up the synth graph may also
be recycled while they are in use - resulting in interesting artifacts (which is
considered a feature!)

synthesis commands
------------------

(play time node-id)
schedules the node id to play at the supplied time. this is for general musical use.

(play-now node-id)
plays the node id as soon as possible - mainly for testing

operator nodes
--------------

all these commands create and return a nodes which can be played. parameters in the
synthesis graph can be other nodes or normal number values.

generators
----------

(sine frequency)
a sinewave at the specified frequency

(saw frequency)
a saw wave at the specified frequency

(squ frequency)
a square wave at the specified frequency

(white)
white noise

(pink)
pink noise

(sample sample-filename frequency)
loads and plays a sample - files can be relative to specified searchpaths. samples
will be loaded asyncronously, and won't interfere with realtime audio.

(adsr attack decay sustain release)
generates an envelope signal

maths
-----

(add a b)
(sub a b)
(mul a b)
(div a b)

remember that parameters can be nodes or number values, so you can do things like:

(play time (mul (sine 440) 0.5))

or

(play time (mul (sine 440) (adsr 0 0.1 0 0)))

filters
-------

(mooghp input-node cutoff resonance)
(moogbp input-node cutoff resonance)
(mooglp input-node cutoff resonance)
(formant input-node cutoff resonance)

global audio
------------

(volume 1)
does what is says on the tin

(eq 1 1 1)
tweak bass, mid, treble

(max-synths 20)
change the maximum concurrent synths playing - default is a measly 10

(searchpath path)
add a path for sample loading

(reset)
aka panic button - deletes all synth graphs and reinitialises all the
operators - not rt safe

sequencing commands
-------------------

fluxa provides a set of forms for sequencing.

(seq (lambda (time clock) 0.1))

the top level sequence - there can only be one of these, and all code within
the supplied procedure will be called when required. the time between calls is
set by the returned value of the procedure - so you can change the global timing
dynamically.

the parameters time and clock are passed to the procedure - time is the float real
time value in seconds, to be passed to play commands. it's actually a little bit
ahead of real time, in order to give the network messages time to get to the server.
you can also mess with the time like so:

(play (+ time 0.5) ...)

will offset the time half a second into the future. you can also make them happen
earlier - but only a little bit.

clock is an ever increasing value, which increments by one each time the procedure
given to seq is called. the value of this is not important, but you can use zmod,
which is simply this predefined procedure:

(define (zmod clock v) (zero? (modulo clock v)))

which is common enough to make this shortening helpful, so:

(if (zmod clock 4) (play (mul (sine 440) (adsr 0 0.1 0 0))))

will play a note every 4 beats.

(note 10)

a utility for mapping note numbers to frequencies (I think the current scale is
equal temperment) [todo: sort scala loading out]

(seq
    (lambda (time clock)
        (clock-map
            (lambda (n)
                (play time (mul (sine (note n)) (adsr 0 0.1 0 0))))
            clock
            (list 10 12 14 15))
        0.1))

clock-map maps the list to the play command each tick of the clock - the list
can be used as a primitive sequence, and can obviously be used to drive much
more than just the pitch.

(seq
    (lambda (time clock)
        (clock-switch clock 128
            (lambda ()
                (play time (mul (sine (note n)) (adsr 0 0.1 0 0))))
            (lambda ()
                (play time (mul (saw (note n)) (adsr 0 0.1 0 0)))))
        0.1))

this clock-switch switches between the procedures every 128 ticks of the clock -
for higher level structure.

syncing
-------

a osc message can be sent to the client for syncing for collaborative performances
the format of the sync message is as follows:

/sync [iiii] timestamp-seconds timestamp-fraction beats-per-bar tempo

when syncing, fluxa provides you with two extra global definitions:

sync-clock : a clock which is reset when a /sync is received
sync-tempo : the current requested tempo (you are free to modify or ignore it)

[note: there is a program which adds timestamps to /sync messages coming from a
network, which makes collaborative sync work properly (as it doesn't require clocks
to be in sync too) email me if you want more info]

known problems/todos
--------------------

* syntax errors in fluxus scratchpad causes insane flood of notes - don't really
  want to change this but I probably should.
* record execution - for cyclic graphs and ->
* permenant execution of some nodes - will fix delay/reverb
* not positive sample loading is rt safe, might be a disk issue on my laptop

server documentation
--------------------

the fluxa server is called by the scheme layer, and represents a low level
interface which is not really designed to be called by hand.

osc interface
-------------

/create ii...iif...
[id type ... id TERMINAL_TYPE value ...]
creates new synth nodes, type can be one of:

0 TERMINAL
1 SINOSC
2 SAWOSC
3 TRIOSC
4 SQUOSC
5 WHITEOSC
6 PINKOSC
7 ADSR
8 ADD
9 SUB
10 MUL
11 DIV
12 MOOGLP
13 MOOGBP
14 MOOGHP
15 FORMANT
16 SAMPLER
17 CRUSH
18 DISTORT
19 CLIP
20 DELAY

if type is 0 (a terminal node) the message also needs a value float to initialise
the terminal to.

/connect iii...
[from arg to ...]
connects multiple nodes together - each connection is defined by from and to node
ids and an argument index to connect the to node to.

/play iii
[seconds fraction id]
plays the node id and outputs the sound. triggers, and starts playing the node at
the time specified. if both time values are set to 0 then it will play it as soon as
possible.

[todo: complete this]
